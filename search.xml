<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>back/LangChain4j/LangChain4j实战教程</title>
      <link href="/posts/14547.html"/>
      <url>/posts/14547.html</url>
      
        <content type="html"><![CDATA[<h1 id="LangChain4j"><a href="#LangChain4j" class="headerlink" title="LangChain4j"></a>LangChain4j</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前主流的 Java AI 开发框架有 Spring AI 和 LangChain4j，它们都提供了很多 <strong>开箱即用的 API</strong> 来帮你调用大模型、实现 AI 开发常用的功能，例如：</p><ul><li>对话记忆</li><li>结构化输出</li><li>RAG 知识库</li><li>工具调用</li><li>MCP</li><li>SSE 流式输出</li></ul><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p>两个注意点，一个JDK必须得大于17，因为 LangChain4j 最低支持 17 版本，这里选择和鱼皮一致的21，第二个点，使用 3.5.x 版本的 Spring Boot，引入 Spring MVC 和 Lombok 注解库</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/15/image-20251215160519216-50b343.png" alt="image-20251215160519216"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/15/image-20251215160532514-5180a2.png" alt="image-20251215160532514"></p><h2 id="AI对话-ChatModel"><a href="#AI对话-ChatModel" class="headerlink" title="AI对话-ChatModel"></a>AI对话-ChatModel</h2><p>ChatModel 是最基础的概念，负责和 AI 大模型交互。</p><p>首先需要引入至少一个 AI 大模型依赖，这里选择国内的阿里云大模型，提供了和 Spring Boot 项目的整合依赖包，比较方便：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-community-dashscope-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0-beta7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要到 阿里云百炼平台 获取大模型调用 key，可以在下面网站查询免费剩余额度</p><p><a href="https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.7a42ce01JM4Txl&tab=model#/model-market/detail/qwen-max">https://bailian.console.aliyun.com/?spm=a2c4g.11186623.0.0.7a42ce01JM4Txl&amp;tab=model#/model-market/detail/qwen-max</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>然后到项目里面，在配置文件里面添加大模型配置，指定模型名称和API key</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">langchain4j:</span></span><br><span class="line">  <span class="attr">community:</span></span><br><span class="line">    <span class="attr">dashscope:</span></span><br><span class="line">      <span class="attr">chat-model:</span></span><br><span class="line">        <span class="attr">model-name:</span> <span class="string">qwen-max</span></span><br><span class="line">        <span class="attr">api-key:</span> <span class="string">&lt;You</span> <span class="string">API</span> <span class="string">Key</span> <span class="string">here&gt;</span></span><br></pre></td></tr></table></figure><p>除了编写配置让 Spring Boot 自动构建 ChatModel 外，也可以通过构造器自己创建 ChatModel 对象。这种方式更灵活，在 LangChain4j 中我们会经常用到这种方式来构造对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChatModel</span> <span class="variable">qwenModel</span> <span class="operator">=</span> QwenChatModel.builder()</span><br><span class="line">                    .apiKey(<span class="string">&quot;You API key here&quot;</span>)</span><br><span class="line">                    .modelName(<span class="string">&quot;qwen-max&quot;</span>)</span><br><span class="line">                    .enableSearch(<span class="literal">true</span>)</span><br><span class="line">                    .temperature(<span class="number">0.7</span>)</span><br><span class="line">                    .maxTokens(<span class="number">4096</span>)</span><br><span class="line">                    .stops(List.of(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><h3 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiCodeHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChatModel qwenChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String prompt)</span> &#123;</span><br><span class="line">        <span class="comment">//构建用户消息</span></span><br><span class="line">        <span class="type">UserMessage</span> <span class="variable">userMessage</span> <span class="operator">=</span> UserMessage.from(prompt);</span><br><span class="line">        <span class="comment">//调用模型</span></span><br><span class="line">        <span class="type">ChatResponse</span> <span class="variable">chat</span> <span class="operator">=</span> qwenChatModel.chat(userMessage);</span><br><span class="line">        <span class="comment">//获取ai消息</span></span><br><span class="line">        <span class="type">AiMessage</span> <span class="variable">aiMessage</span> <span class="operator">=</span> chat.aiMessage();</span><br><span class="line">        log.info(<span class="string">&quot;aiMessage: &#123;&#125;&quot;</span>, aiMessage.toString());</span><br><span class="line">        <span class="keyword">return</span> aiMessage.text();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/15/image-20251215171614505-9316b3.png" alt="image-20251215171614505"></p><h2 id="多模态"><a href="#多模态" class="headerlink" title="多模态"></a>多模态</h2><p>多模态是指能够同时处理、理解和生成多种不同类型数据的能力，比如文本、图像、音频、视频、PDF 等等。</p><p>LangChain4j 中使用多模态的方法很简单，用户消息中是可以添加图片、音视频、PDF 等媒体资源的。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/15/image-20251215171017155-398b72.png" alt="image-20251215171017155"></p><p>编写一个支持传入自定义 UserMessage 的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">chatWithMessage</span><span class="params">(UserMessage userMessage)</span> &#123;</span><br><span class="line">    <span class="comment">//调用模型</span></span><br><span class="line">    <span class="type">ChatResponse</span> <span class="variable">chat</span> <span class="operator">=</span> qwenChatModel.chat(userMessage);</span><br><span class="line">    <span class="comment">//获取ai消息</span></span><br><span class="line">    <span class="type">AiMessage</span> <span class="variable">aiMessage</span> <span class="operator">=</span> chat.aiMessage();</span><br><span class="line">    log.info(<span class="string">&quot;aiMessage: &#123;&#125;&quot;</span>, aiMessage.toString());</span><br><span class="line">    <span class="keyword">return</span> aiMessage.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testChatWithMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserMessage</span> <span class="variable">userMessage</span> <span class="operator">=</span> UserMessage.from(</span><br><span class="line">            TextContent.from(<span class="string">&quot;描述图片&quot;</span>),</span><br><span class="line">            ImageContent.from(<span class="string">&quot;https://pic.rmb.bdstatic.com/bjh/news/732c313925cd9f04f887e06e9bd37bbf.png&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    aiCodeHelper.chatWithMessage(userMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是效果不理想，qwen-max 模型无法直接查看或分析图片：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251215171113148-71724b-5689c8.png" alt="image-20251215171113148"></p><p>目前多模态开发最关键的问题，虽然编码不难，但需要大模型本身支持多模态。可以在 LangChain 官网看到 大模型能力支持表，不过一切以实际测试为准。</p><h2 id="系统提示词"><a href="#系统提示词" class="headerlink" title="系统提示词"></a>系统提示词</h2><p>系统提示词是设置 AI 模型行为规则和角色定位的隐藏指令，用户通常不能直接看到。系统 Prompt 相当于给 AI 设定人格和能力边界，也就是告诉 AI “你是谁？你能做什么？”。</p><p>根据我们的需求，编写一段系统提示词：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你是编程领域的小助手，帮助用户解答编程学习和求职面试相关的问题，并给出建议。重点关注 4 个方向：</span><br><span class="line">1. 规划清晰的编程学习路线</span><br><span class="line">2. 提供项目学习建议</span><br><span class="line">3. 给出程序员求职全流程指南（比如简历优化、投递技巧）</span><br><span class="line">4. 分享高频面试题和面试技巧</span><br><span class="line">请用简洁易懂的语言回答，助力用户高效学习与求职。</span><br></pre></td></tr></table></figure><p>想要使用系统提示词，最直接的方法是创建一个系统消息，把它和用户消息一起发送给 AI。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYSTEM_PROMPT</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        你是编程领域的小助手，帮助用户解答编程学习和求职面试相关的问题，并给出建议。重点关注 4 个方向：</span></span><br><span class="line"><span class="string">        1. 规划清晰的编程学习路线</span></span><br><span class="line"><span class="string">        2. 提供项目学习建议</span></span><br><span class="line"><span class="string">        3. 给出程序员求职全流程指南（比如简历优化、投递技巧）</span></span><br><span class="line"><span class="string">        4. 分享高频面试题和面试技巧</span></span><br><span class="line"><span class="string">        请用简洁易懂的语言回答，助力用户高效学习与求职。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String prompt)</span> &#123;</span><br><span class="line">    <span class="comment">//构建系统消息</span></span><br><span class="line">    <span class="type">SystemMessage</span> <span class="variable">systemMessage</span> <span class="operator">=</span> SystemMessage.from(SYSTEM_PROMPT);</span><br><span class="line">    <span class="comment">//构建用户消息</span></span><br><span class="line">    <span class="type">UserMessage</span> <span class="variable">userMessage</span> <span class="operator">=</span> UserMessage.from(prompt);</span><br><span class="line">    <span class="comment">//调用模型</span></span><br><span class="line">    <span class="type">ChatResponse</span> <span class="variable">chat</span> <span class="operator">=</span> qwenChatModel.chat(systemMessage,userMessage);</span><br><span class="line">    <span class="comment">//获取ai消息</span></span><br><span class="line">    <span class="type">AiMessage</span> <span class="variable">aiMessage</span> <span class="operator">=</span> chat.aiMessage();</span><br><span class="line">    log.info(<span class="string">&quot;aiMessage: &#123;&#125;&quot;</span>, aiMessage.toString());</span><br><span class="line">    <span class="keyword">return</span> aiMessage.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然生效了</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251215171745981-3f0fe9-068ad9.png" alt="image-20251215171745981"></p><h2 id="AI-服务-AI-Service"><a href="#AI-服务-AI-Service" class="headerlink" title="AI 服务 - AI Service"></a>AI 服务 - AI Service</h2><p>在学习更多特性前，我们要了解 LangChain4j 最重要的开发模式 —— AI Service，提供了很多高层抽象的、用起来更方便的 API，把 AI 应用当做服务来开发。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>然后创建一个编程助手 AI Service 服务，采用声明式开发方法，编写一个对话方法，然后可以直接通过 <code>@SystemMessage</code> 注解定义系统提示词。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AiCodeHelperService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SystemMessage(&quot;你是一位编程小助理！&quot;)</span></span><br><span class="line">    String <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过由于我们提示词较长，写到注解里很不优雅，所以单独在 resources 目录下新建文件 <code>system-prompt.txt</code> 来存储系统提示词。</p><p><code>@SystemMessage</code> 注解支持从文件中读取系统提示词：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AiCodeHelperService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">    String <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>需要编写工厂类，用于创建 AI Service：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiCodeHelperServiceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChatModel qwenChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AiCodeHelperService <span class="title function_">aiCodeHelperService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AiServices.create(AiCodeHelperService.class, qwenChatModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>AiServices.create</code> 方法就可以创建出 AI Service 的实现类了，背后的原理是利用 Java 反射机制创建了一个实现接口的代理对象，代理对象负责输入和输出的转换，比如把 String 类型的用户消息参数转为 UserMessage 类型并调用 ChatModel，再将 AI 返回的 AiMessage 类型转换为 String 类型作为返回值。</p><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AiCodeHelperServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AiCodeHelperService aiCodeHelperService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> aiCodeHelperService.chat(<span class="string">&quot;你好，我是程序员鱼皮&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251215174332798-422624-a61b58.png" alt="image-20251215174332798"></p><h3 id="Spring-Boot-项目中使用"><a href="#Spring-Boot-项目中使用" class="headerlink" title="Spring Boot 项目中使用"></a><strong>Spring Boot 项目中使用</strong></h3><p>如果你觉得手动调用 create 方法来创建 Service 比较麻烦，在 Spring Boot 项目中可以引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0-beta7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后给 AI Service 加上 <code>@AiService</code> 注解，就能自动创建出服务实例了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AiService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AiCodeHelperService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">    String <span class="title function_">chat</span><span class="params">(String userMessage)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得注释掉之前工厂类的 @Configuration 注解，否则会出现 Bean 冲突</p><p>再次运行单元测试，也是可以正常对话的</p><blockquote><p>这种方式虽然更方便了，但是缺少了自主构建的灵活性（可以自由设置很多参数），所以还是自主构建比较好</p></blockquote><h2 id="会话记忆"><a href="#会话记忆" class="headerlink" title="会话记忆"></a>会话记忆</h2><p>会话记忆是指让 AI 能够记住用户之前的对话内容，并保持上下文连贯性，这是实现 AI 应用的核心特性。</p><p>LangChain4j 为我们提供了开箱即用的 <code>MessageWindowChatMemory</code> 会话记忆，最多保存 N 条消息，多余的会自动淘汰。创建会话记忆后，在构造 AI Service 设置 chatMemory</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiCodeHelperServiceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChatModel qwenChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AiCodeHelperService <span class="title function_">aiCodeHelperService</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置会话记忆</span></span><br><span class="line">        <span class="type">ChatMemory</span> <span class="variable">chatMemory</span> <span class="operator">=</span> MessageWindowChatMemory.withMaxMessages(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">                .chatModel(qwenChatModel)</span><br><span class="line">                .chatMemory(chatMemory)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> aiCodeHelperService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">chatWithMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> aiCodeHelperService.chat(<span class="string">&quot;你好，我是程序员鱼皮&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    result = aiCodeHelperService.chat(<span class="string">&quot;你好，我是谁来着&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/15/image-20251215213633834-21e2b1.png" alt="image-20251215213633834"></p><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>会话记忆默认是存储在内存的，重启后会丢失，可以通过自定义 ChatMemoryStore 接口的实现类，将消息保存到 MySQL 等其他数据源中。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/15/640-74f1ae.webp" alt="图片"></p><p>如果有多个用户，希望每个用户之间的消息隔离，可以通过给对话方法增加 memoryId 参数和注解，在调用对话时传入 memoryId 即可（类似聊天室的房间号）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">chat</span><span class="params">(<span class="meta">@MemoryId</span> <span class="type">int</span> memoryId, <span class="meta">@UserMessage</span> String userMessage)</span>;</span><br></pre></td></tr></table></figure><p>构造 AI Service 时，可以通过 chatMemoryProvider 来指定 <strong>每个 memoryId 单独创建会话记忆</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造 AI Service</span></span><br><span class="line"><span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">        .chatModel(qwenChatModel)</span><br><span class="line">        .chatMemoryProvider(memoryId -&gt; MessageWindowChatMemory.withMaxMessages(<span class="number">10</span>))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="结构化输出"><a href="#结构化输出" class="headerlink" title="结构化输出"></a>结构化输出</h2><p>结构化输出是指将大模型返回的文本输出转换为结构化的数据格式，比如一段 JSON、一个对象、或者是复杂的对象列表。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/17/640-c64a1c.webp" alt="图片"></p><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><ul><li>利用大模型的 JSON schema</li><li>利用 Prompt + JSON Mode</li><li>利用 Prompt</li></ul><p>默认是使用prompt模型，即使用提示工程</p><p>默认是 Prompt 模式，也就是在原本的用户提示词下 <strong>拼接一段内容</strong> 来指定大模型强制输出包含特定字段的 JSON 文本。</p><p>不过我们开发时无需关心这些，只要修改对话方法的返回值，框架就会自动帮我们实现结构化输出</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-91260f-443ce2.webp" alt="图片"></p><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">  Report <span class="title function_">chatReport</span><span class="params">(String message)</span>;</span><br><span class="line">  <span class="comment">//定义一个临时类</span></span><br><span class="line">  <span class="keyword">record</span> <span class="title class_">Report</span><span class="params">(String message, List&lt;String&gt; messages)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userMessage</span> <span class="operator">=</span> <span class="string">&quot;你好，我是程序员鱼皮，学编程两年半，请帮我制定学习报告&quot;</span>;</span><br><span class="line">  AiCodeHelperService.<span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> aiCodeHelperService.chatForReport(userMessage);</span><br><span class="line">  System.out.println(report);</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217153249706-479cf3-7306d3.png" alt="image-20251217153249706"></p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>如果你发现 AI 有时无法生成准确的 JSON，那么可以采用 JSON Schema 模式，直接在请求中约束 LLM 的输出格式。这是目前最可靠、精确度最高的结构化输出实现</p><p>但是不推荐使用，因为太死板了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResponseFormat</span> <span class="variable">responseFormat</span> <span class="operator">=</span> ResponseFormat.builder()</span><br><span class="line">        .type(JSON)</span><br><span class="line">        .jsonSchema(JsonSchema.builder()</span><br><span class="line">                .name(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line">                .rootElement(JsonObjectSchema.builder()</span><br><span class="line">                        .addStringProperty(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                        .addIntegerProperty(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">                        .addNumberProperty(<span class="string">&quot;height&quot;</span>)</span><br><span class="line">                        .addBooleanProperty(<span class="string">&quot;married&quot;</span>)</span><br><span class="line">                        .required(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;height&quot;</span>, <span class="string">&quot;married&quot;</span>) </span><br><span class="line">                        .build())</span><br><span class="line">                .build())</span><br><span class="line">        .build();</span><br><span class="line"><span class="type">ChatRequest</span> <span class="variable">chatRequest</span> <span class="operator">=</span> ChatRequest.builder()</span><br><span class="line">        .responseFormat(responseFormat)</span><br><span class="line">        .messages(userMessage)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="检索增强生成-RAG"><a href="#检索增强生成-RAG" class="headerlink" title="检索增强生成 - RAG"></a>检索增强生成 - RAG</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成）是一种结合信息检索技术和 AI 内容生成的混合架构，可以解决大模型的知识时效性限制和幻觉问题。</p><p>简单来说，RAG 就像给 AI 配了一个 “小抄本”，让 AI 回答问题前先查一查特定的知识库来获取知识，确保回答是基于真实资料而不是凭空想象。很多企业也基于 RAG 搭建了自己的智能客服，可以用自己积累的领域知识回复用户。</p><p>RAG 的完整工作流程如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-2ed2eb-6e5e5a.webp" alt="图片"></p><h3 id="极简版-RAG"><a href="#极简版-RAG" class="headerlink" title="极简版 RAG"></a><strong>极简版 RAG</strong></h3><p><strong>极简版适合快速查看效果</strong>，首先需要引入额外的依赖，里面包含了内置的离线 Embedding 模型，开箱即用：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-easy-rag<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0-beta7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码如下，使用内置的文档加载器读取文档，然后利用内置的 Embedding 模型将文档转换成向量，并存储在内置的 Embedding 内存存储中，最后给 AI Service 绑定默认的内容检索器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAG</span></span><br><span class="line"><span class="comment">// 1. 加载文档</span></span><br><span class="line">List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocuments(<span class="string">&quot;src/main/resources/docs&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 使用内置的 EmbeddingModel 转换文本为向量，然后存储到自动注入的内存 embeddingStore 中</span></span><br><span class="line">EmbeddingStoreIngestor.ingest(documents, embeddingStore);</span><br><span class="line"><span class="comment">// 构造 AI Service</span></span><br><span class="line"><span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">        .chatModel(qwenChatModel)</span><br><span class="line">        .chatMemory(chatMemory)</span><br><span class="line">        <span class="comment">// RAG：从内存 embeddingStore 中检索匹配的文本片段</span></span><br><span class="line">        .contentRetriever(EmbeddingStoreContentRetriever.from(embeddingStore))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="标准版本"><a href="#标准版本" class="headerlink" title="标准版本"></a>标准版本</h3><p>下面来试试标准版 RAG 实现，为了更好地效果，我们需要：</p><ul><li>加载 Markdown 文档并按需切割</li><li>Markdown 文档补充文件名信息</li><li>自定义 Embedding 模型</li><li>自定义内容检索器</li></ul><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>在 Spring Boot 配置文件中添加 Embedding 模型配置，使用阿里云提供的 <code>text-embedding-v4</code> 模型：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">langchain4j:</span></span><br><span class="line">  <span class="attr">community:</span></span><br><span class="line">    <span class="attr">dashscope:</span></span><br><span class="line">      <span class="attr">chat-model:</span></span><br><span class="line">        <span class="string">model-name:qwen-max</span></span><br><span class="line">        <span class="string">api-key:&lt;YouAPIKeyhere&gt;</span></span><br><span class="line">      <span class="attr">embedding-model:</span></span><br><span class="line">        <span class="string">model-name:text-embedding-v4</span></span><br><span class="line">        <span class="string">api-key:&lt;YouAPIKeyhere&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构建RAG相关配置"><a href="#构建RAG相关配置" class="headerlink" title="构建RAG相关配置"></a>构建RAG相关配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RagConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EmbeddingModel qwenEmbeddingModel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于内存的一个存储</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EmbeddingStore&lt;TextSegment&gt; embeddingStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ContentRetriever <span class="title function_">contentRetriever</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// -- RAG ---</span></span><br><span class="line">        <span class="comment">//1.加载文档</span></span><br><span class="line">        List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocuments(<span class="string">&quot;src/main/resources/docs&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.文档切割，每个文档按照段落进行分割，最大1000个字符，每次最多重叠200个字符， 重叠意思是第一个切片和第二个切片里面的内容有重复的，即一个头能连接上一个尾部</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DocumentByParagraphSplitter</span> <span class="variable">documentByParagraphSplitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DocumentByParagraphSplitter</span>(<span class="number">1000</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.自定义文档加载器，把文档转化成向量并且保存到向量数据库中</span></span><br><span class="line">        <span class="type">EmbeddingStoreIngestor</span> <span class="variable">ingestor</span> <span class="operator">=</span> EmbeddingStoreIngestor.builder()</span><br><span class="line">                <span class="comment">//指定文档切割器</span></span><br><span class="line">                .documentSplitter(documentByParagraphSplitter)</span><br><span class="line">                <span class="comment">//为了提高文档的质量，为每个切割后的文档碎片 TextSegment，添加文档名称作为元信息</span></span><br><span class="line">                .textSegmentTransformer(textSegment -&gt; TextSegment.from(textSegment.metadata().getString(<span class="string">&quot;file_name&quot;</span>) +</span><br><span class="line">                        <span class="string">&quot;\n&quot;</span> + textSegment.text(), textSegment.metadata()))</span><br><span class="line">                <span class="comment">//指定向量模型</span></span><br><span class="line">                .embeddingModel(qwenEmbeddingModel)</span><br><span class="line">                <span class="comment">//指定向量存储</span></span><br><span class="line">                .embeddingStore(embeddingStore)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载文档</span></span><br><span class="line">        ingestor.ingest(documents);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.构建内容检索器</span></span><br><span class="line">        <span class="type">EmbeddingStoreContentRetriever</span> <span class="variable">build</span> <span class="operator">=</span> EmbeddingStoreContentRetriever.builder()</span><br><span class="line">                .embeddingStore(embeddingStore)</span><br><span class="line">                .embeddingModel(qwenEmbeddingModel)</span><br><span class="line">                .maxResults(<span class="number">5</span>)<span class="comment">//最多几个结果</span></span><br><span class="line">                .minScore(<span class="number">0.75</span>) <span class="comment">//最低得分 过滤分数小于0.75相似度</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChatModel qwenChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ContentRetriever contentRetriever;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AiCodeHelperService <span class="title function_">aiCodeHelperService</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置会话记忆</span></span><br><span class="line">        <span class="type">ChatMemory</span> <span class="variable">chatMemory</span> <span class="operator">=</span> MessageWindowChatMemory.withMaxMessages(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">                .chatModel(qwenChatModel)</span><br><span class="line">                .chatMemory(chatMemory)<span class="comment">//会话记忆</span></span><br><span class="line">                .contentRetriever(contentRetriever)<span class="comment">//RAG 检索增强生成</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> aiCodeHelperService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="回答结果"><a href="#回答结果" class="headerlink" title="回答结果"></a>回答结果</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217162902511-b4b1ca-b83890.png" alt="image-20251217162902511"></p><p>可以看到询问内容的时候附带上信息了<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/17/image-20251217163044112-ee737b.png" alt="image-20251217163044112"></p><h4 id="带来源的信息"><a href="#带来源的信息" class="headerlink" title="带来源的信息"></a>带来源的信息</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-2a2aae-8b3c5c.webp" alt="图片"></p><p>在 LangChain4j 中，实现这个功能很简单。在 AI Service 中新增方法，在原本的返回类型外封装一层 Result 类，就可以获得封装后的结果，从中能够获取到 RAG 引用的源文档、以及 Token 的消耗情况等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回封装后的结果</span></span><br><span class="line">    <span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">    Result&lt;String&gt; <span class="title function_">chatWithRag</span><span class="params">(String message)</span>;</span><br></pre></td></tr></table></figure><p>修改单元测试，输出更多信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">chatWithRag1</span><span class="params">()</span> &#123;</span><br><span class="line">    Result&lt;String&gt; stringResult = aiCodeHelperService.chatWithRag(<span class="string">&quot;怎么学习java？有哪些常见的面试题？&quot;</span>);</span><br><span class="line">    System.out.println(stringResult.sources());</span><br><span class="line">    System.out.println(stringResult.content());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217173617879-2be44c-e01a66.png" alt="image-20251217173617879"></p><h3 id="进阶版本RAG"><a href="#进阶版本RAG" class="headerlink" title="进阶版本RAG"></a>进阶版本RAG</h3><p>这就是一套标准的 RAG 实现了，大多数时候，使用标准版就够了。进阶版会更加灵活，额外支持查询转换器、查询路由、内容聚合器、内容注入器等特性，将整个 RAG 的流程流水线化（RAG pipeline）。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-3ac226-594a4b.webp" alt="图片"></p><p>简单来说就是规定了很多格式，例如转化成规定的用法，从特定的查询路由上查询想要的内容，聚合输出给大模型</p><p>定义好 RAG 流程后，最后通过 RetrievalAugmentor 提供给 AI Service：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AiServices.builder(xxx.class)</span><br><span class="line">    ...</span><br><span class="line">    .retrievalAugmentor(retrievalAugmentor)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>此外，之前我们使用的是内存向量存储，每次启动都要重新加载文档、调用嵌入模型，比较耗时，所以实际开发中建议使用独立的存储，官方支持很多第三方存储，但是个人比较推荐 PG Vector，在原有关系库的基础上安装插件来支持向量存储，而且支持的特性很多。</p><h2 id="工具调用-Tools"><a href="#工具调用-Tools" class="headerlink" title="工具调用 - Tools"></a>工具调用 - Tools</h2><p>工具调用（Tool Calling）可以理解为让 AI 大模型 <strong>借用外部工具</strong> 来完成它自己做不到的事情。</p><p>工具可以是任何东西，比如网页搜索、对外部 API 的调用、访问外部数据、或执行特定的代码等。</p><p>工具调用的本质 <strong>并不是 AI 服务器自己调用这些工具、也不是把工具的代码发送给 AI 服务器让它执行</strong>，它只能提出要求，表示 “我需要执行 XX 工具完成任务”。而真正执行工具的是我们自己的应用程序，执行后再把结果告诉 AI，让它继续工作。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-7d808b-ff3333.webp" alt="图片"></p><h3 id="案例–抓取鱼皮网页的内容"><a href="#案例–抓取鱼皮网页的内容" class="headerlink" title="案例–抓取鱼皮网页的内容"></a>案例–抓取鱼皮网页的内容</h3><h4 id="引入工具–Jsoup库"><a href="#引入工具–Jsoup库" class="headerlink" title="引入工具–Jsoup库"></a>引入工具–Jsoup库</h4><p>先引入 Jsoup 库：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.20.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构建工具类"><a href="#构建工具类" class="headerlink" title="构建工具类"></a>构建工具类</h4><p>使用 <code>@Tool</code> 注解就能声明工具，下面是写好的一个样例，注意 <strong>要认真编写工具和工具参数的描述</strong>，这直接决定了 AI 能否正确地调用工具</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterviewQuestionTool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从面试鸭网站获取关键词相关的面试题列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyword 搜索关键词（如&quot;redis&quot;、&quot;java多线程&quot;）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 面试题列表，若失败则返回错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Tool(name = &quot;interviewQuestionSearch&quot;, value = &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">            Retrieves relevant interview questions from mianshiya.com based on a keyword.</span></span><br><span class="line"><span class="meta">            Use this tool when the user asks for interview questions about specific technologies,</span></span><br><span class="line"><span class="meta">            programming concepts, or job-related topics. The input should be a clear search term.</span></span><br><span class="line"><span class="meta">            &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">searchInterviewQuestions</span><span class="params">(<span class="meta">@P(value = &quot;the keyword to search&quot;)</span> String keyword)</span> &#123;</span><br><span class="line">        List&lt;String&gt; questions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构建搜索URL（编码关键词以支持中文）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedKeyword</span> <span class="operator">=</span> URLEncoder.encode(keyword, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.mianshiya.com/search/all?searchText=&quot;</span> + encodedKeyword;</span><br><span class="line">        <span class="comment">// 发送请求并解析页面</span></span><br><span class="line">        Document doc;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = Jsoup.connect(url)</span><br><span class="line">                    .userAgent(<span class="string">&quot;Mozilla/5.0&quot;</span>)</span><br><span class="line">                    .timeout(<span class="number">5000</span>)</span><br><span class="line">                    .get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;get web error&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提取面试题</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">questionElements</span> <span class="operator">=</span> doc.select(<span class="string">&quot;.ant-table-cell &gt; a&quot;</span>);</span><br><span class="line">        questionElements.forEach(el -&gt; questions.add(el.text().trim()));</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;\n&quot;</span>, questions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绑定工具"><a href="#绑定工具" class="headerlink" title="绑定工具"></a>绑定工具</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">              .chatModel(qwenChatModel)</span><br><span class="line">              .chatMemory(chatMemory)<span class="comment">//会话记忆</span></span><br><span class="line">              .contentRetriever(contentRetriever)<span class="comment">//RAG 检索增强生成</span></span><br><span class="line">              .tools(<span class="keyword">new</span> <span class="title class_">InterviewQuestionTool</span>())<span class="comment">//工具调用</span></span><br><span class="line">              .build();</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/17/image-20251217211650240-c45172.png" alt="image-20251217211650240"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217211747562-5528c1-0dc19a.png" alt="image-20251217211747562"></p><h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><p>除了联网搜索外，还有一些经典的工具，比如文件读写、PDF 生成、调用终端、输出图表等等。这些工具我们可以自己开发，也可以通过 MCP 直接使用别人开发好的工具。</p><p>即就是自己开发一个MCP的工具，供大模型使用，但是要注意使用范围，确保大模型能精准的调用到。</p><h2 id="模型上下文协议-MCP"><a href="#模型上下文协议-MCP" class="headerlink" title="模型上下文协议 - MCP"></a>模型上下文协议 - MCP</h2><p>MCP（Model Context Protocol，模型上下文协议）是一种开放标准，目的是增强 AI 与外部系统的交互能力。MCP 为 AI 提供了与外部工具、资源和服务交互的标准化方式，让 AI 能够访问最新数据、执行复杂操作，并与现有系统集成。</p><p>可以将 MCP 想象成 AI 应用的 USB 接口。就像 USB 为设备连接各种外设和配件提供了标准化方式一样，MCP 为 AI 模型连接不同的数据源和工具提供了标准化的方法。</p><p>简单来说，通过 MCP 协议，AI 应用可以轻松接入别人提供的服务来实现更多功能，比如查询地理位置、操作数据库、部署网站、甚至是支付等等。</p><h3 id="MCP服务市场"><a href="#MCP服务市场" class="headerlink" title="MCP服务市场"></a><a href="https://mcp.so/">MCP服务市场</a></h3><p>首先从 MCP 服务市场搜索 Web Search 服务，推荐 下面这个，因为它提供了 SSE 在线调用服务，不用我们自己在本地安装启动，很方便。</p><p><a href="https://mcp.so/zh/server/zhipu-web-search/BigModel">https://mcp.so/zh/server/zhipu-web-search/BigModel</a></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217214035750-5b31ee-19985c.png" alt="image-20251217214035750"></p><p><a href="https://bigmodel.cn/usercenter/proj-mgmt/apikeys">在质谱市场设置Key</a></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217214336598-6d0873-abb529.png" alt="image-20251217214336598"></p><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;langchain4j-mcp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.1</span><span class="number">.0</span>-beta7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="新增配置"><a href="#新增配置" class="headerlink" title="新增配置"></a>新增配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bigmodel:</span><br><span class="line">  api-key: &lt;Your Api Key&gt;</span><br></pre></td></tr></table></figure><h3 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h3><p>按照官方的开发方式，初始化和 MCP 服务的通讯，并创建 McpToolProvider 的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">McpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;bigmodel.api-key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String apiKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> McpToolProvider <span class="title function_">mcpToolProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 和 MCP 服务通讯</span></span><br><span class="line">        <span class="type">McpTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpMcpTransport</span>.Builder()</span><br><span class="line">                .sseUrl(<span class="string">&quot;https://open.bigmodel.cn/api/mcp/web_search/sse?Authorization=&quot;</span> + apiKey)</span><br><span class="line">                .logRequests(<span class="literal">true</span>) <span class="comment">// 开启日志，查看更多信息</span></span><br><span class="line">                .logResponses(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 创建 MCP 客户端</span></span><br><span class="line">        <span class="type">McpClient</span> <span class="variable">mcpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMcpClient</span>.Builder()</span><br><span class="line">                .key(<span class="string">&quot;McpClient&quot;</span>)</span><br><span class="line">                .transport(transport)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 从 MCP 客户端获取工具</span></span><br><span class="line">        <span class="type">McpToolProvider</span> <span class="variable">toolProvider</span> <span class="operator">=</span> McpToolProvider.builder()</span><br><span class="line">                .mcpClients(mcpClient)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> toolProvider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面我们是通过 SSE 的方式调用 MCP。如果你是通过 npx 或 uvx 本地启动 MCP 服务，需要先安装对应的工具，并且利用下面的配置建立通讯：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">McpTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdioMcpTransport</span>.Builder()</span><br><span class="line">    .command(List.of(<span class="string">&quot;/usr/bin/npm&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;@modelcontextprotocol/server-everything@0.6.2&quot;</span>))</span><br><span class="line">    .logEvents(<span class="literal">true</span>) <span class="comment">// only if you want to see the traffic in the log</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="在-AI-Service-中应用-MCP-工具："><a href="#在-AI-Service-中应用-MCP-工具：" class="headerlink" title="在 AI Service 中应用 MCP 工具："></a>在 AI Service 中应用 MCP 工具：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> McpToolProvider toolProvider;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> AiCodeHelperService <span class="title function_">aiCodeHelperService</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置会话记忆</span></span><br><span class="line">      <span class="type">ChatMemory</span> <span class="variable">chatMemory</span> <span class="operator">=</span> MessageWindowChatMemory.withMaxMessages(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">              .chatModel(qwenChatModel)</span><br><span class="line">              .chatMemory(chatMemory)<span class="comment">//会话记忆</span></span><br><span class="line">              .contentRetriever(contentRetriever)<span class="comment">//RAG 检索增强生成</span></span><br><span class="line">              .tools(<span class="keyword">new</span> <span class="title class_">InterviewQuestionTool</span>())<span class="comment">//工具调用</span></span><br><span class="line">              .toolProvider(toolProvider)<span class="comment">// MCP 工具调用</span></span><br><span class="line">              .build();</span><br><span class="line">      <span class="keyword">return</span> aiCodeHelperService;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="编写单元测试-1"><a href="#编写单元测试-1" class="headerlink" title="编写单元测试"></a>编写单元测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">chatWithMcp</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> aiCodeHelperService.chat(<span class="string">&quot;什么是圣诞节？&quot;</span>);</span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/17/image-20251217215100078-04451d.png" alt="image-20251217215100078"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217215119159-d30433-9737cc.png" alt="image-20251217215119159"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目前，文档中并没有提到利用 LangChain4j 开发 MCP 的方法，不过目前也不建议用 Java 开发 MCP。</span><br></pre></td></tr></table></figure><h2 id="护轨-Guardrail（相当于拦截器）"><a href="#护轨-Guardrail（相当于拦截器）" class="headerlink" title="护轨 - Guardrail（相当于拦截器）"></a>护轨 - Guardrail（相当于拦截器）</h2><p>分为输入护轨（input guardrails）和输出护轨（output guardrails），可以在请求 AI 前和接收到 AI 的响应后执行一些额外操作，比如调用 AI 前鉴权、调用 AI 后记录日志。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-59abd3-c26b53.webp" alt="图片"></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在调用 AI 前进行敏感词检测，如果用户提示词包含敏感词，则直接拒绝。</span><br></pre></td></tr></table></figure><h3 id="新建输入护轨"><a href="#新建输入护轨" class="headerlink" title="新建输入护轨"></a>新建输入护轨</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeInputGuardrail</span> <span class="keyword">implements</span> <span class="title class_">InputGuardrail</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; sensitiveWords = Set.of(<span class="string">&quot;kill&quot;</span>, <span class="string">&quot;evil&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测用户输入是否安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputGuardrailResult <span class="title function_">validate</span><span class="params">(UserMessage userMessage)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用户输入并转换为小写以确保大小写不敏感</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">inputText</span> <span class="operator">=</span> userMessage.singleText().toLowerCase();</span><br><span class="line">        <span class="comment">// 使用正则表达式分割输入文本为单词</span></span><br><span class="line">        String[] words = inputText.split(<span class="string">&quot;\\W+&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历所有单词，检查是否存在敏感词</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sensitiveWords.contains(word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> fatal(<span class="string">&quot;Sensitive word detected: &quot;</span> + word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>LangChain4j 提供了几种快速返回的方法，简单来说，想继续调用 AI 就返回 success、否则就返回 fatal。failure是这个不满足，但是继续调用下面的验证</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-29b894-bf120d.webp" alt="图片"></p><h3 id="引入护轨"><a href="#引入护轨" class="headerlink" title="引入护轨"></a>引入护轨</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InputGuardrails(&#123;SafeInputGuardrail.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AiCodeHelperService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">    String <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">    Report <span class="title function_">chatReport</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Report</span><span class="params">(String message, List&lt;String&gt; messages)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回封装后的结果</span></span><br><span class="line">    <span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">    Result&lt;String&gt; <span class="title function_">chatWithRag</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h3><p>编写单元测试，写一个包含敏感词的提示词：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">chatWithGuardrail</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> aiCodeHelperService.chat(<span class="string">&quot;kill the game&quot;</span>);</span><br><span class="line">     System.out.println(result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20251217220408888-56cc7e-d955d6.png" alt="image-20251217220408888"></p><h2 id="日志和可观测性"><a href="#日志和可观测性" class="headerlink" title="日志和可观测性"></a>日志和可观测性</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>开启日志的方法很简单，直接构造模型时指定开启、或者直接编写 Spring Boot 配置，支持打印 AI 请求和响应日志。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">OpenAiChatModel.builder()</span><br><span class="line">    ...</span><br><span class="line">    .logRequests(true)</span><br><span class="line">    .logResponses(true)</span><br><span class="line">    .build();</span><br><span class="line">langchain4j.open-ai.chat-model.log-requests = true</span><br><span class="line">langchain4j.open-ai.chat-model.log-responses = true</span><br><span class="line">logging.level.dev.langchain4j = DEBUG</span><br></pre></td></tr></table></figure><p>但并不是所有的 ChatModel 都支持，比如我测试下来 QwenChatModel 就不支持。这时只能把希望交给可观测性了。</p><h3 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h3><h4 id="监听类"><a href="#监听类" class="headerlink" title="监听类"></a>监听类</h4><p>可以通过自定义 Listener 获取 ChatModel 的调用信息，比较灵活。</p><p>新建 <code>listener.ChatModelListenerConfig</code>，输出请求、响应、错误信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatModelListenerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ChatModelListener <span class="title function_">chatModelListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChatModelListener</span> () &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequest</span> <span class="params">(ChatModelRequestContext requestContext)</span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;onRequest(): &#123;&#125;&quot;</span>, requestContext.chatRequest());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span> <span class="params">(ChatModelResponseContext responseContext)</span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;onResponse(): &#123;&#125;&quot;</span>, responseContext.chatResponse());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span> <span class="params">(ChatModelErrorContext errorContext)</span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;onError(): &#123;&#125;&quot;</span>, errorContext.error().getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手动构造模型"><a href="#手动构造模型" class="headerlink" title="手动构造模型"></a>手动构造模型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;langchain4j.community.dashscope.chat-model&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QwenChatModelConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String apiKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChatModelListener chatModelListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChatModel <span class="title function_">myQwenChatModel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QwenChatModel.builder()</span><br><span class="line">                .apiKey(apiKey)</span><br><span class="line">                .modelName(modelName)</span><br><span class="line">                .listeners(List.of(chatModelListener))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="替换即可"><a href="#替换即可" class="headerlink" title="替换即可"></a>替换即可</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ChatModel myQwenChatModel;</span><br></pre></td></tr></table></figure><p>可以看到控制台能看到对应的输出内容：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/12/18/image-20251218000502008-568ad4.png" alt="image-20251218000502008"></p><h2 id="AI-服务化"><a href="#AI-服务化" class="headerlink" title="AI 服务化"></a>AI 服务化</h2><p>AI 的能力基本开发完成，但是目前只支持本地运行，需要编写一个接口提供给前端调用，让 AI 能够成为一个服务。</p><p>推荐使用 SSE（Server-Sent Events）技术实现实时流式输出，类似打字机效果，大幅提升用户体验。</p><h3 id="SSE-流式接口开发"><a href="#SSE-流式接口开发" class="headerlink" title="SSE 流式接口开发"></a>SSE 流式接口开发</h3><p>LangChain 提供了 2 种方式来支持流式响应（注意，流式响应不支持结构化输出）。</p><p>一种方法是 TokenStream，先让 AI 对话方法返回 TokenStream，然后创建 AI Service 时指定流式对话模型 StreamingChatModel：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Assistant</span> &#123;</span><br><span class="line"></span><br><span class="line">    TokenStream <span class="title function_">chat</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">StreamingChatModel</span> <span class="variable">model</span> <span class="operator">=</span> OpenAiStreamingChatModel.builder()</span><br><span class="line">    .apiKey(System.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>))</span><br><span class="line">    .modelName(GPT_4_O_MINI)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Assistant</span> <span class="variable">assistant</span> <span class="operator">=</span> AiServices.create(Assistant.class, model);</span><br><span class="line"></span><br><span class="line"><span class="type">TokenStream</span> <span class="variable">tokenStream</span> <span class="operator">=</span> assistant.chat(<span class="string">&quot;Tell me a joke&quot;</span>);</span><br><span class="line"></span><br><span class="line">tokenStream.onPartialResponse((String partialResponse) -&gt; System.out.println(partialResponse))</span><br><span class="line">    .onRetrieved((List&lt;Content&gt; contents) -&gt; System.out.println(contents))</span><br><span class="line">    .onToolExecuted((ToolExecution toolExecution) -&gt; System.out.println(toolExecution))</span><br><span class="line">    .onCompleteResponse((ChatResponse response) -&gt; System.out.println(response))</span><br><span class="line">    .onError((Throwable error) -&gt; error.printStackTrace())</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure><h3 id="使用Flux响应式编程"><a href="#使用Flux响应式编程" class="headerlink" title="使用Flux响应式编程"></a>使用Flux响应式编程</h3><h4 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.langchain4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>langchain4j-reactor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0-beta7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h4><p>这里顺便新增了一下多用户的会话记忆，隔离开来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回流式结果</span></span><br><span class="line"><span class="meta">@SystemMessage(fromResource = &quot;system-prompt.txt&quot;)</span></span><br><span class="line">Flux&lt;String&gt; <span class="title function_">chatStream</span><span class="params">(<span class="meta">@MemoryId</span> <span class="type">int</span> memoryID, <span class="meta">@UserMessage</span> String message)</span>;</span><br></pre></td></tr></table></figure><h4 id="增加流式模型"><a href="#增加流式模型" class="headerlink" title="增加流式模型"></a>增加流式模型</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">langchain4j:</span></span><br><span class="line">  <span class="attr">community:</span></span><br><span class="line">    <span class="attr">dashscope:</span></span><br><span class="line">      <span class="attr">streaming-chat-model:</span></span><br><span class="line">        <span class="attr">model-name:</span> <span class="string">qwen-max</span></span><br><span class="line">        <span class="attr">api-key:</span> <span class="string">&lt;Your</span> <span class="string">Api</span> <span class="string">Key&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构造-AI-Service"><a href="#构造-AI-Service" class="headerlink" title="构造 AI Service"></a>构造 AI Service</h4><p>构造 AI Service 时指定流式对话模型（自动注入即可），并且补充会话记忆提供者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiCodeHelperServiceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> QwenChatModel myQwenChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ContentRetriever contentRetriever;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> McpToolProvider toolProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> QwenStreamingChatModel qwenStreamingChatModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AiCodeHelperService <span class="title function_">aiCodeHelperService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AiCodeHelperService</span> <span class="variable">aiCodeHelperService</span> <span class="operator">=</span> AiServices.builder(AiCodeHelperService.class)</span><br><span class="line">                .chatModel(myQwenChatModel)</span><br><span class="line">                .streamingChatModel(qwenStreamingChatModel)<span class="comment">//流式模型</span></span><br><span class="line">                .chatMemoryProvider(memoryId -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 为每个memoryId创建独立的聊天记忆</span></span><br><span class="line">                    <span class="keyword">return</span> MessageWindowChatMemory.withMaxMessages(<span class="number">10</span>);</span><br><span class="line">                &#125;) <span class="comment">// 每个会话独立存储</span></span><br><span class="line">                .contentRetriever(contentRetriever)<span class="comment">//RAG 检索增强生成</span></span><br><span class="line">                .tools(<span class="keyword">new</span> <span class="title class_">InterviewQuestionTool</span>())<span class="comment">//工具调用</span></span><br><span class="line">                .toolProvider(toolProvider)<span class="comment">// MCP 工具调用</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> aiCodeHelperService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写Controller接口"><a href="#编写Controller接口" class="headerlink" title="编写Controller接口"></a>编写Controller接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aicontroller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AiCodeHelperService aiCodeHelperService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/chat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;ServerSentEvent&lt;String&gt;&gt; <span class="title function_">chat</span><span class="params">(<span class="type">int</span> MemoryID, String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> aiCodeHelperService.chatStream(MemoryID, message).</span><br><span class="line">                map(chunk -&gt; ServerSentEvent.&lt;String&gt;builder()</span><br><span class="line">                        .data(chunk)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨域设置"><a href="#跨域设置" class="headerlink" title="跨域设置"></a>跨域设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局跨域配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 覆盖所有请求</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 允许发送 Cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 放行哪些域名（必须用 patterns，否则 * 会和 allowCredentials 冲突）</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AI生成前端"><a href="#AI生成前端" class="headerlink" title="AI生成前端"></a>AI生成前端</h2><p>首先准备一段详细的 Prompt，一般要包括需求、技术选型、后端接口信息，还可以提供一些原型图、后端代码等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你是一位专业的前端开发，请帮我根据下列信息来生成对应的前端项目代码。你应该使用 Windows 支持的命令来完成任务</span><br><span class="line"></span><br><span class="line">## 需求</span><br><span class="line"></span><br><span class="line">应用为《AI 编程小助手》，帮助用户解答编程学习和求职面试相关的问题，并给出建议。</span><br><span class="line"></span><br><span class="line">只有一个页面，就是主页：页面风格为聊天室，上方是聊天记录（用户信息在右边，AI 信息在左边），下方是输入框，进入页面后自动生成一个聊天室 id，用于区分不同的会话。通过 SSE 的方式调用 chat 接口，实时显示对话内容。</span><br><span class="line"></span><br><span class="line">## 技术选型</span><br><span class="line"></span><br><span class="line">1. Vue3 项目</span><br><span class="line">2. Axios 请求库</span><br><span class="line"></span><br><span class="line">## 后端接口信息</span><br><span class="line"></span><br><span class="line">接口地址前缀：http://localhost:8081/api</span><br><span class="line"></span><br><span class="line">## SpringBoot 后端接口代码</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/ai&quot;)</span><br><span class="line">public class AiController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/chat&quot;)</span><br><span class="line">    public Flux&lt;ServerSentEvent&lt;String&gt;&gt; chat(int memoryId, String message) &#123;</span><br><span class="line">        return aiCodeHelperService.chatStream(memoryId, message)</span><br><span class="line">                .map(chunk -&gt; ServerSentEvent.&lt;String&gt;builder()</span><br><span class="line">                        .data(chunk)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果使用的是 Windows 系统，最好在 prompt 中补充“你应该使用 Windows 支持的命令来完成任务”。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/image-20260105214514915-90ad48-8a0a09.png" alt="image-20260105214514915"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/640-1adce5.webp" alt="图片"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/mp/wappoc_appmsgcaptcha?poc_token=HMrAW2mjXQcAlmbzvmGks_Uk_D_lnQ5lHDlgwiHY&target_url=https://mp.weixin.qq.com/s/7cNh7ndeiWiHBjnkTkz_Zg">笔记</a></p><p><a href="https://www.bilibili.com/video/BV1X4GGziEyr/?vd_source=c587df609e4b42494103d3455c04caab&spm_id_from=333.788.videopod.sections&p=14">学习地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LangChain4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Consul服务中心</title>
      <link href="/posts/3876.html"/>
      <url>/posts/3876.html</url>
      
        <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>现在比较流行的也就是Consul和Nacos，Zookeeper没有管理界面，一般不建议使用，而Eureka已经处于停更，并且本身就存在很多bug，一般不建议使用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/08/67d964c81a0cdb575285c8b838bce8e5-862ffc.png" alt="在这里插入图片描述"></p><h1 id="Consul介绍"><a href="#Consul介绍" class="headerlink" title="Consul介绍"></a>Consul介绍</h1><p>Consul 官网：<a href="https://www.consul.io/">https://www.consul.io/</a><br>Consul 官网介绍：<a href="https://www.consul.io/docs">https://www.consul.io/docs</a><br>Consul 中文教程：<a href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a><br>SpringCloud官网介绍Consul：<a href="https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/#spring-cloud-consul-discovery">https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/#spring-cloud-consul-discovery</a></p><h2 id="Consul特性"><a href="#Consul特性" class="headerlink" title="Consul特性"></a>Consul特性</h2><ol><li><p>服务发现：Consul 的客户端可以注册服务，其他客户端可以使用 Consul 发现给定服务的提供者。使用DNS 或 HTTP，应用程序可以轻松找到它们所依赖的服务。</p></li><li><p>健康检查：Consul客户端可以提供任意数量的健康检查，可以与给定的服务关联(“web服务器是否返回200 OK”)，也可以与本地节点关联(“内存利用率是否低于90%”)。操作人员可以使用此信息监视集群运行状况，服务发现组件也可以使用此信息将通信流量路由到远离不健康主机的地方，支持多种方式,HTTP, TCP、 Docker, Shell脚本定制化监控。</p></li><li><p>KV 存储：应用程序可以使用Consul的分级 key&#x2F;value 存储来实现各种目的，包括动态配置、特性标记、协调、leader选举等等。简单的HTTP API使其易于使用。</p></li><li><p>安全服务通信：Consul可以生成和分发服务的TLS证书，以建立相互的TLS连接。可以使用意图来定义允许哪些服务进行通信。可以很容易地管理服务细分，目的可以实时更改，而不是使用复杂的网络拓扑和静态防火墙规则。</p></li><li><p>多数据中心：Consul 支持开箱即用的多个数据中心。这意味着 Consul 的用户不必担心构建额外的抽象层以扩展到多个区域。</p></li><li><p>Raft 算法：使用Raft算法完成一致性，Raft将一致性问题分解成了三个独立的部分:leader选举、日志复制、安全性。</p></li><li><p>自带web管理界面：这一点相比于zookeeper注册中心要好一点，zookeeper是没有自带管理界面的。通过管理界面可以清晰的看到注册了多少个服务，以及在管理界面还可以使用服务配置功能。</p></li></ol><h2 id="Consul的基本架构"><a href="#Consul的基本架构" class="headerlink" title="Consul的基本架构"></a>Consul的基本架构</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/08/c6131f77e5c04028cda4cccf00fa3435-c4002d.png" alt="在这里插入图片描述"></p><p>对于consul，集群模式下，一分为二<br>Consul Cluster（集群）有Server 和Client两种角色。不管是Server还是Client,统称为Agent（代理）。</p><ul><li><p>Consul Client 是相对无状态的，只负责转发RPC到Server资源开销很少。</p></li><li><p>Server是一个有一组扩展功能的代理，这些功能包括参与Raft选举、维护集群状态、响应RPC查询、与其他数据中心交互WAN Gossip和转发查询给leader或者远程数据中心。</p></li></ul><p>简单来说，Client就是一个转发的操作，将消费者的服务发送到这里，转发到Server进行处理，而Server之间代理管理消费者的服务。所以对于Consul一般扩展的是Client，简单这个Client可以与每个服务进行挂钩。</p><p>而Server一般是奇数，一般是3-5台机器，因为奇数是服务器安全正常运行的前提是有一半以上的机器正常运行，当3台和4台服务器时，坏掉两台都是不可以用的，所以一般选择3台奇数服务器，方便判断管理。同时不宜选择太多，会造成数据交互同步之间的压力。</p><h1 id="Consul单节点安装与启动"><a href="#Consul单节点安装与启动" class="headerlink" title="Consul单节点安装与启动"></a>Consul单节点安装与启动</h1><p>Consul 官网下载地址：<a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>到对应的目录下，使用cmd启动Consul</span><br><span class="line"></span><br><span class="line"><span class="comment">#-dev表示开发模式运行,另外还有-server表示服务模式运行</span></span><br><span class="line">consul agent -dev -client=0.0.0.0</span><br></pre></td></tr></table></figure><p>为了方便启动,也可以在consul.exe同级目录下创建一个脚本来启动,脚本内容如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">consul agent -dev -client=0.0.0.0 </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><strong>访问管理后台</strong>: <a href="http://localhost:8500/%E7%9C%8B%E5%88%B0%E4%B8%8B%E5%9B%BE%E6%84%8F%E5%91%B3%E7%9D%80%E6%88%91%E4%BB%AC%E7%9A%84Consul%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E4%BA%86%E3%80%82">http://localhost:8500/看到下图意味着我们的Consul服务启动成功了。</a></p><p><strong>通过如下方式可以查看版本号：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consul --version</span><br></pre></td></tr></table></figure><h1 id="Consul启动命令详解"><a href="#Consul启动命令详解" class="headerlink" title="Consul启动命令详解"></a>Consul启动命令详解</h1><ul><li>-dev：开发模式，去掉所有持久化选项，内存服务器模式。</li><li>-server：此标志用于控制代理是处于服务器模式还是客户端模式。提供后，代理将充当 Consul 服务器。每个 Consul 集群必须至少有一台服务器，理想情况下每个数据中心不超过 5 台。</li><li>-bind：内部集群通信应该绑定的地址。这是集群中所有其他节点都应该可以访问的 IP 地址。默认情况下，这是“0.0.0.0”，这意味着 Consul 将绑定到本地机器上的所有地址，并将私有 IPv4 地址通告 给集群的其余部分。如果有多个私有 IPv4 地址可用，Consul 将在启动时退出并出现错误。</li><li>-client：Consul 将绑定客户端接口的地址，包括 HTTP 和 DNS 服务器。默认情况下，这是“127.0.0.1”，只允许环回连接，0.0.0.0表示不限客户端ip。</li><li>-ui-：开启web界面访问</li><li>-bootstrap-expect ：此标志提供数据中心中预期的服务器数量为3。可以不设置，如果要设置该值必须与集群中的其他服务器一致。设置之后，Consul 会等待指定数量的服务器可用，然后引导集群。此标志需要-server模式。-bootstrap-expect&#x3D;3表示server 集群最低节点数为3,低于这个值将工作不正常</li><li>-data-dir：该标志为代理提供了一个数据目录来存储状态。这对所有代理都是必需的(该目录必须存在,需提前创建好)。</li><li>-node：集群中此节点的名称。这在集群中必须是唯一的。默认情况下，这是机器的主机名。</li><li>-log-file-：日志文件所在位置 需要提前创建好目录。例如，设置log-file为&#x2F;var&#x2F;log&#x2F;将导致日志文件路径为&#x2F;var&#x2F;log&#x2F;consul-{timestamp}.log. log-file可以与 -log-rotate-duration结合使用 以获得细粒度的日志轮换体验。</li><li>-log-rotate-duration：指定日志在需要轮换之前应写入的最长持续时间。必须是持续时间值，例如 30 秒。默认为 24 小时。</li><li>-datacenter-：此标志控制运行代理的数据中心。如果未提供，则默认为“dc1”。</li></ul><p>上面命令除了在cmd使用，还可以将配置写到文件当中，然后通过启动命令引入别的配置文件：</p><p>您可以指定许多选项来配置 Consul 在发出consul agent命令时的操作方式。您还可以创建一个或多个配置文件，并在启动时使用-config-file or -config-dir选项将它们提供给 Consul。配置文件必须以 JSON 或 HCL 格式编写。</p><h1 id="Consul启动输出"><a href="#Consul启动输出" class="headerlink" title="Consul启动输出"></a>Consul启动输出</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/08/image-20250908141948761-879bf6.png" alt="image-20250908141948761"></p><ul><li><code>Node name</code>：这是代理的唯一名称。默认情况下，这是机器的主机名，但您可以使用 -node标志自定义它。</li><li><code>Datacenter</code>：这是配置代理运行的数据中心。对于单 DC 配置，代理将默认为dc1，但您可以使用-datacenter标志配置代理向哪个数据中心报告。Consul 对多个数据中心具有一流的支持，但配置每个节点以报告其数据中心可提高代理效率。</li><li><code>Server</code>：这表明代理是在服务器模式还是客户端模式下运行。在服务器模式下运行代理需要额外的开销。这是因为它们参与了共识仲裁、存储集群状态并处理查询。服务器也可能处于 “bootstrap” 模式，这使服务器能够选举自己作为 Raft 领导者。多个服务器不能处于bootstrap模式，因为它会使集群处于不一致的状态。</li><li><code>Client Addr</code>：这是用于代理的客户端接口的地址。这包括 HTTP 和 DNS 接口的端口。默认情况下，这仅绑定到 localhost。如果更改此地址或端口，则必须-http-addr在运行命令时指定 a，例如 consul members指示如何访问代理。其他应用程序也可以使用 HTTP 地址和端口 来控制 Consul。</li><li><code>Cluster Addr</code>: 这是用于集群中 Consul 代理之间通信的地址和端口集。并非集群中的所有 Consul 代理都必须使用相同的端口，但所有其他节点必须可以访问此地址。</li></ul><h1 id="SpringCloud使用Consul作为服务注册发现中心"><a href="#SpringCloud使用Consul作为服务注册发现中心" class="headerlink" title="SpringCloud使用Consul作为服务注册发现中心"></a>SpringCloud使用Consul作为服务注册发现中心</h1><h2 id="构建springCloud项目"><a href="#构建springCloud项目" class="headerlink" title="构建springCloud项目"></a>构建springCloud项目</h2><h3 id="父节点构建"><a href="#父节点构建" class="headerlink" title="父节点构建"></a>父节点构建</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">创建Maven项目，之后修改pom文件</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Consul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 统一管理jar包版本 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 统一管理jar包版本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.30<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-plus.boot.version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">mybatis-plus.boot.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 升级 Spring Boot 到 2.7.x，支持 JDK17 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Spring Cloud Hoxton 不完全支持 Boot 2.7，建议至少升级到 2021.x 版本 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.0.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- spring cloud alibaba 升级版本 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0-M7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式。</span><br><span class="line">通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement 元素。</span><br><span class="line"></span><br><span class="line">作用： pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。 Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用这个dependencyManagement 元素中指定的版本号。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>子工程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>但是注意，父工程只是做一个版本管理，它自己实际上并没有引入这些依赖，同样的，子工程如果没有显示的说明要用这个依赖，那么子工程是不会引入的</p><h3 id="创建子工程"><a href="#创建子工程" class="headerlink" title="创建子工程"></a>创建子工程</h3><p>创建一个maven，继承自父工程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;Consul&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;provider&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">17</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">17</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql-connector-java--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jdbc--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>注意需要配置一下必须的内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/db2022?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line"># mybatis-plus配置打印sql日志</span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h2 id="构建服务提供者"><a href="#构建服务提供者" class="headerlink" title="构建服务提供者"></a>构建服务提供者</h2><h3 id="修改POM文件"><a href="#修改POM文件" class="headerlink" title="修改POM文件"></a>修改POM文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud consul-server --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改Yaml文件"><a href="#修改Yaml文件" class="headerlink" title="修改Yaml文件"></a>修改Yaml文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-provider-payment</span></span><br><span class="line">  <span class="comment">####consul注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 是否注册（默认为true）</span></span><br><span class="line">        <span class="attr">register:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 服务名称</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">        <span class="comment"># 展示实例的ip（默认是false）</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 实例id名称（默认是$&#123;spring.application.name&#125;:comma,separated,profiles:$&#123;server.port&#125;）</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><h3 id="添加主启动类注解"><a href="#添加主启动类注解" class="headerlink" title="添加主启动类注解"></a>添加主启动类注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动服务发现已经注册上来了"><a href="#启动服务发现已经注册上来了" class="headerlink" title="启动服务发现已经注册上来了"></a>启动服务发现已经注册上来了</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/08/image-20250908155109581-76a3dc.png" alt="image-20250908155109581"></p><p>通过这个配置可以修改下图当中展示的服务名称：这个服务名称很重要，消费者在调用提供者的时候也需要根据名称来调用，假如提供者有多个是集群的形式，那么这个服务名称也是一样的。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.consul.discovery.service-name=$&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure><p>图当中的1 instance就是代表这个服务有一个实例</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/08/image-20250908155715832-68d7d1.png" alt="image-20250908155715832"></p><p>点击服务名称进去之后就是展示的实例，一个服务名称可以对应多个实例，所谓的多个实例也就是我们所说的微服务集群。</p><p>默认情况下，consul 实例注册的 ID 等于其 Spring Application Context ID。默认情况下，Spring 应用程序上下文 ID 是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;spring.application.name&#125;:comma,separated,profiles:$&#123;server.port&#125;</span><br></pre></td></tr></table></figure><p>在大多数情况下，这将允许一项服务的多个实例在一台机器上运行。如果需要进一步的唯一性，使用 Spring Cloud，通过这个配置可以修改下图当中展示的实例名称</p><p>从上图可以发现我们是可以看到实例ip的，默认是看不到的，通过下面配置就可以看到了（多个实例的时候，可以根据这个就可以快速找到实例对应的服务器地址）：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.cloud.consul.discovery.prefer-ip-address=true</span><br></pre></td></tr></table></figure><h2 id="构建服务消费者"><a href="#构建服务消费者" class="headerlink" title="构建服务消费者"></a>构建服务消费者</h2><h3 id="修改pom"><a href="#修改pom" class="headerlink" title="修改pom"></a>修改pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud consul-server --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加application-yml文件"><a href="#添加application-yml文件" class="headerlink" title="添加application.yml文件"></a>添加application.yml文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-consumer-order</span><br><span class="line">  # consul注册中心相关配置</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br><span class="line">      discovery:</span><br><span class="line">        # 是否注册（默认为true）</span><br><span class="line">        register: true</span><br><span class="line">        # 服务名称</span><br><span class="line">        service-name: $&#123;spring.application.name&#125;</span><br><span class="line">        # 展示实例的ip（默认是false）</span><br><span class="line">        prefer-ip-address: true</span><br><span class="line">        # 实例id名称（默认是$&#123;spring.application.name&#125;:comma,separated,profiles:$&#123;server.port&#125;）</span><br><span class="line">        instance-id: $&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure><h3 id="添加主启动类"><a href="#添加主启动类" class="headerlink" title="添加主启动类"></a>添加主启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">// 用于负载均衡访问</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加业务类"><a href="#添加业务类" class="headerlink" title="添加业务类"></a>添加业务类</h3><p>这里使用服务名称进行远程调用，正常我们使用ip+端口也是能调用的，之所以用服务名称调用就是为了，假如集群情况下，可以负载均衡访问。这也是注册中心的用途之一，其次使用注册中心可以更直观的来查看集群的每个节点的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INVOKE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://consul-provider&quot;</span>; <span class="comment">//consul-provider-payment</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(value = &quot;/consumer/payment/consul&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(INVOKE_URL + <span class="string">&quot;/test&quot;</span>, String.class);</span><br><span class="line">      System.out.println(<span class="string">&quot;消费者调用支付服务(consule)---&gt;result:&quot;</span> + result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着正常访问这个地址就可以互相交互了</p><h1 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h1><p>当客户端向 Consul 注册时，它会提供有关自身的元数据，例如主机和端口、id、名称和标签。默认情况下会创建一个 HTTP检查，&#x2F;actuator&#x2F;health<code>每 10 秒访问一次端点</code>。如果健康检查失败，服务实例被标记为critical(可能有危险的)</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/08/image-20250908161337304-ffbe61.png" alt="image-20250908161337304"></p><p>这个也可以进行修改，自己定义链接以及响应时间</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">需要更改下面这一点，否则项目可以启动成功，但是注册中心服务注册不成功！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">healthCheckPath:</span> <span class="string">$&#123;server.servlet.context-path&#125;/actuator/health</span></span><br><span class="line">        <span class="attr">healthCheckInterval:</span> <span class="string">15s</span></span><br></pre></td></tr></table></figure><p>并且消费者调用提供者的地址也需要更改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INVOKE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://consul-provider-payment/consul&quot;</span>; </span><br></pre></td></tr></table></figure><p>Consul 用来检查健康端点的时间间隔也可以配置。“10s”和“1m”分别代表10秒和1分钟。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">healthCheckInterval:</span> <span class="string">15s</span></span><br></pre></td></tr></table></figure><p>您可以通过设置完全禁用 HTTP 健康检查（默认是开启的）：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">        <span class="comment"># 禁用 HTTP 健康检查(默认是开启的)</span></span><br><span class="line">        <span class="attr">register-health-check:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="查找服务"><a href="#查找服务" class="headerlink" title="查找服务"></a>查找服务</h1><p>使用负载均衡器<br>Spring Cloud 支持Feign（一个 REST 客户端构建器），还支持SpringRestTemplate 使用逻辑服务名称&#x2F;id 而不是物理 URL 来查找服务。Feign 和发现感知的 RestTemplate 都使用Spring Cloud LoadBalancer进行客户端负载平衡。</p><p>如果您想使用 RestTemplate 访问服务，只需声明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">// 用于负载均衡访问</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且像上面一样使用它</p><h1 id="SpringCloud使用Consul作为配置中心"><a href="#SpringCloud使用Consul作为配置中心" class="headerlink" title="SpringCloud使用Consul作为配置中心"></a>SpringCloud使用Consul作为配置中心</h1><p>感觉用不太到，所以没学<br><a href="https://blog.csdn.net/weixin_43888891/article/details/125511542">https://blog.csdn.net/weixin_43888891/article/details/125511542</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Consul服务中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>back/Linux/Docker复习</title>
      <link href="/posts/47860.html"/>
      <url>/posts/47860.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="docker卸载"><a href="#docker卸载" class="headerlink" title="docker卸载"></a>docker卸载</h2><p>由于centOS一般会自带docker，所以第一步需要卸载其自带的docker</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-selinux </span><br></pre></td></tr></table></figure><h2 id="配置Docker的yum库"><a href="#配置Docker的yum库" class="headerlink" title="配置Docker的yum库"></a>配置Docker的yum库</h2><p>首先要安装一个yum工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>安装成功后，执行命令，配置Docker的yum源（已更新为阿里云源）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新yum，建立缓存</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum makecache fast</span><br></pre></td></tr></table></figure><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>最后，执行命令，安装Docker</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error downloading packages:</span><br><span class="line">  docker-compose-plugin-2.27.1-1.el7.x86_64: [Errno 256] No more mirrors to try.</span><br></pre></td></tr></table></figure><p>修改方式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">清理 yum 的缓存和元数据：</span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum --enablerepo=docker-ce-stable clean metadata</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">绕过缓存，直接下载并安装：</span><br><span class="line"></span><br><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/docker-compose-plugin-2.27.1-1.el7.x86_64.rpm</span><br><span class="line">yum localinstall docker-compose-plugin-2.27.1-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">如果没有wegt 可以先yum install -y wget</span><br></pre></td></tr></table></figure><h2 id="启动和校验"><a href="#启动和校验" class="headerlink" title="启动和校验"></a>启动和校验</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>由于wsl不会自动创建一个服务文件，所以需要手动创建</p><h3 id="创建一个自定义-docker-service-文件（手动启动-dockerd）"><a href="#创建一个自定义-docker-service-文件（手动启动-dockerd）" class="headerlink" title="创建一个自定义 docker.service 文件（手动启动 dockerd）"></a>创建一个自定义 <code>docker.service</code> 文件（手动启动 dockerd）</h3><p>创建 systemd 文件目录（如果不存在）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/</span><br></pre></td></tr></table></figure><p>创建 <code>docker.service</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>内容写入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">Restart=always</span><br><span class="line"># 如果不想用 sudo，请确保 WSL 用户有权限访问 /var/run/docker.sock</span><br><span class="line"># User=root</span><br><span class="line"># Group=docker</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>重新加载 systemd 配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>启动 Docker：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在网上搜可以搜到，配置阿里云的镜像加速，方便搜搜</span><br></pre></td></tr></table></figure><p>最新镜像工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"># 写入配置文件</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://docker-0.unsee.tech&quot;,</span><br><span class="line">        &quot;https://docker-cf.registry.cyou&quot;,</span><br><span class="line">        &quot;https://docker.1panel.live&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 重启docker服务</span><br><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="部署MySQL"><a href="#部署MySQL" class="headerlink" title="部署MySQL"></a>部署MySQL</h3><p>首先，我们利用Docker来安装一个MySQL软件，大家可以对比一下之前传统的安装方式，看看哪个效率更高一些。</p><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用CV大法）：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3307</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><blockquote><p>Docker安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程</p></blockquote><p>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了Docker镜像交流的社区：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902153139572-2e1780.png" alt="image-20250902153139572"></p><h2 id="命令解读"><a href="#命令解读" class="headerlink" title="命令解读"></a>命令解读</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3307</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><ul><li><p><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</p></li><li><p><code>--name  mysql </code> : 给容器起个名字叫<code>mysql</code>，可以叫别的</p></li><li><p><code>-p 3306:3306</code> : 设置端口映射</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902153603727-a601d5.png" alt="image-20250902153603727"></p><ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以*<em>将</em>***宿主机端口访问虚拟机端口，虚拟机和容器进行通信</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><p><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数，这个参数由镜像决定，格式是KEY&#x3D;VALUE。格式<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定，可以在镜像网站中搜索环境变量的说明</p></li><li><p><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像，一般是这样的写：</p></li><li><p><code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号。在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></p></li></ul><h1 id="Docker常见命令"><a href="#Docker常见命令" class="headerlink" title="Docker常见命令"></a>Docker常见命令</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902154412324-ec25ad.png" alt="image-20250902154412324"></p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 bash(以什么进行交互，用命令行，也可以直接跟上你想要执行的命令)</span><br><span class="line">-it 表示添加一个交互客户端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>给常用Docker命令起别名，方便我们访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h1 id="Docker-数据卷（相当于挂载"><a href="#Docker-数据卷（相当于挂载" class="headerlink" title="Docker 数据卷（相当于挂载"></a>Docker 数据卷（相当于挂载</h1><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机****目录</strong>之间映射的桥梁。</p><p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902160014173-d81acf.png" alt="image-20250902160014173"></p><p>上图中：</p><ul><li>创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect [name]</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><h2 id="容器挂载"><a href="#容器挂载" class="headerlink" title="容器挂载"></a>容器挂载</h2><p>注意挂载只能创建的时候一起挂载，当创建完成后就不能挂载了；容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 3080:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line">-v html:/usr/share/nginx/html</span><br><span class="line">前面是宿主机的位置，后面的容器内要挂载的位置</span><br></pre></td></tr></table></figure><h2 id="容器挂载2–宿主机"><a href="#容器挂载2–宿主机" class="headerlink" title="容器挂载2–宿主机"></a>容器挂载2–宿主机</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询容器详情 docker inspect name</span><br></pre></td></tr></table></figure><p>查询mysql，发现自动挂载了<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902161444711-8ad5a9.png" alt="image-20250902161444711"></p><p>保存的mysql数据存储</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于mysql在运行过程中，会保存数据，在后续对mysql进行迁移或者更新，这些匿名卷并不是很友好，所以一般不创建匿名卷，需要创建一个自己的目录，保存到宿柱机目录上</span><br></pre></td></tr></table></figure><h3 id="挂载方式"><a href="#挂载方式" class="headerlink" title="挂载方式"></a>挂载方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 挂载本地目录</span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"># 挂载本地文件</span><br><span class="line">-v 本地文件:容器内文件</span><br><span class="line"></span><br><span class="line">本地目录或文件必须以 / 或 ./开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除并重新创建mysql容器，并完成本地目录挂载：</span><br><span class="line">- 挂载/root/mysql/data到容器内的 /var/lib/mysql目录</span><br><span class="line">- 挂载/root/mysql/init到容器内的 /docker-entrypoint-initdb.d目录（初始化的SQL脚本目录）</span><br><span class="line">- 挂载/root/mysql/conf到容器内的 /etc/mysql/conf.d目录（这个是MySQL配置文件目录）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3.创建并运行新mysql容器，挂载本地目录</span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3307:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p>镜像就是一堆文件的集合，但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><blockquote><p>所以一般都是下面的结构，下载的过程中，一部分一部分下载，分层结构下载</p></blockquote><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902184655095-851508.png" alt="image-20250902184655095"></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>一般JDK都有提供好的镜像，所以我们只要把自己Jar包引入即可</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开始构建</span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<ul><li><pre><code class="Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 网络--容器之间相互访问</span><br><span class="line"></span><br><span class="line">docker在创建的时候，会自己构建一个网桥，自己管理自己容器的网络，</span><br><span class="line"></span><br><span class="line">![image-20250902190824366](https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/image-20250902190824366-c3b089.png)</span><br><span class="line"></span><br><span class="line">&gt; 他们之间可以相互访问，但是IP地址不是固定的，两者交互不能一直通过IP地址访问，所以需要构建自定义网络</span><br><span class="line"></span><br><span class="line">但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</span><br><span class="line"></span><br><span class="line">所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</span><br><span class="line"></span><br><span class="line">https://docs.docker.com/engine/reference/commandline/network/</span><br><span class="line"></span><br><span class="line">常见命令有：</span><br><span class="line"></span><br><span class="line">| **命令**                  | **说明**                 | **文档地址**                                                 |</span><br><span class="line">| :------------------------ | :----------------------- | :----------------------------------------------------------- |</span><br><span class="line">| docker network create     | 创建一个网络             | [docker network create](https://docs.docker.com/engine/reference/commandline/network_create/) |</span><br><span class="line">| docker network ls         | 查看所有网络             | [docs.docker.com](https://docs.docker.com/engine/reference/commandline/network_ls/) |</span><br><span class="line">| docker network rm         | 删除指定网络             | [docs.docker.com](https://docs.docker.com/engine/reference/commandline/network_rm/) |</span><br><span class="line">| docker network prune      | 清除未使用的网络         | [docs.docker.com](https://docs.docker.com/engine/reference/commandline/network_prune/) |</span><br><span class="line">| docker network connect    | 使指定容器连接加入某网络 | [docs.docker.com](https://docs.docker.com/engine/reference/commandline/network_connect/) |</span><br><span class="line">| docker network disconnect | 使指定容器连接离开某网络 | [docker network disconnect](https://docs.docker.com/engine/reference/commandline/network_disconnect/) |</span><br><span class="line">| docker network inspect    | 查看网络详细信息         | [docker network inspect](https://docs.docker.com/engine/reference/commandline/network_inspect/) |</span><br><span class="line"></span><br><span class="line">创建时候可以直接加入网桥</span><br><span class="line"></span><br></pre></td></tr></table></figure>docker run -d --name dd -p 8080:8080 --network heima docker-demo通过--network在开始就指定网桥，那么后续创建的时候就不会加入到默认网桥里面<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 项目部署</span><br><span class="line"></span><br><span class="line">## 部署后端</span><br><span class="line"></span><br><span class="line">`hmall`项目是一个maven聚合项目，使用IDEA打开`hmall`项目，查看项目结构如图：</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/asynccode-1d33d4.png)</span><br><span class="line"></span><br><span class="line">我们要部署的就是其中的`hm-service`，其中的配置文件采用了多环境的方式：</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/asynccode-0fa4db.png)</span><br><span class="line"></span><br><span class="line">其中的`application-dev.yaml`是部署到开发环境的配置，`application-local.yaml`是本地运行时的配置。</span><br><span class="line"></span><br><span class="line">查看application.yaml，你会发现其中的JDBC地址并未写死，而是读取变量：</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/asynccode-c0b322.png)</span><br><span class="line"></span><br><span class="line">这两个变量在`application-dev.yaml`和`application-local.yaml`中并不相同：</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/asynccode-1443cd.png)</span><br><span class="line"></span><br><span class="line">在dev开发环境（也就是Docker部署时）采用了mysql作为地址，刚好是我们的mysql容器名，只要两者在一个网络，就一定能互相访问。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将`hm-service`目录下的`Dockerfile`和`hm-service/target`目录下的`hm-service.jar`一起上传到虚拟机的`root`目录，Dockerfile内容：</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h1 id="基础镜像"><a href="#基础镜像" class="headerlink" title="基础镜像"></a>基础镜像</h1><p>FROM openjdk:11.0-jre-buster</p><h1 id="设定时区"><a href="#设定时区" class="headerlink" title="设定时区"></a>设定时区</h1><p>ENV TZ&#x3D;Asia&#x2F;Shanghai<br>RUN ln -snf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;$TZ &#x2F;etc&#x2F;localtime &amp;&amp; echo $TZ &gt; &#x2F;etc&#x2F;timezone</p><h1 id="拷贝jar包"><a href="#拷贝jar包" class="headerlink" title="拷贝jar包"></a>拷贝jar包</h1><p>COPY hm-service.jar &#x2F;app.jar</p><h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>ENTRYPOINT [“java”, “-jar”, “&#x2F;app.jar”]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接着部署镜像运行即可</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 1.构建项目镜像，不指定tag，则默认为latest</span><br><span class="line">docker build -t hmall .</span><br><span class="line"></span><br><span class="line"># 2.查看镜像</span><br><span class="line">docker images</span><br><span class="line"># 结果</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">hmall         latest    0bb07b2c34b9   43 seconds ago   362MB</span><br><span class="line">docker-demo   1.0       49743484da68   24 hours ago     327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br><span class="line"></span><br><span class="line"># 3.创建并运行容器，并通过--network将其加入hmall网络，这样才能通过容器名访问mysql</span><br><span class="line">docker run -d --name hmall --network hmall -p 8080:8080 hmall</span><br></pre></td></tr></table></figure><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><p><code>hmall-portal</code>和<code>hmall-admin</code>是前端代码，需要基于nginx部署。在课前资料中已经给大家提供了nginx的部署目录：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/09/02/asynccode-d07133.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/json;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       18080;</span><br><span class="line">        # 指定前端项目所在的位置</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html/hmall-portal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        location /api &#123;</span><br><span class="line">            rewrite /api/(.*)  /$1 break;</span><br><span class="line">            proxy_pass http://hmall:8080;</span><br><span class="line">            # 指定访问地址，注意hmall需要修改</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       18081;</span><br><span class="line">        # 指定前端项目所在的位置</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html/hmall-admin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        location /api &#123;</span><br><span class="line">            rewrite /api/(.*)  /$1 break;</span><br><span class="line">            proxy_pass http://hmall:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>html</code>是静态资源目录，我们需要把<code>hmall-portal</code>以及<code>hmall-admin</code>都复制进去</li><li><code>nginx.conf</code>是nginx的配置文件，主要是完成对<code>html</code>下的两个静态资源目录做代理</li></ul><p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口：</p><ul><li>18080：对应hmall-portal</li><li>18081：对应hmall-admin</li></ul><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 18080:18080 \</span><br><span class="line">  -p 18081:18081 \</span><br><span class="line">  -v /root/heima/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/heima/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  --network heima \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><h1 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h1><p>Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p><p>黑马商城部署文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p><p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left"></td><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left"></td><td align="left">down</td><td align="left">停止并移除所有容器、网络</td></tr><tr><td align="left"></td><td align="left">ps</td><td align="left">列出所有启动的容器</td></tr><tr><td align="left"></td><td align="left">logs</td><td align="left">查看指定容器的日志</td></tr><tr><td align="left"></td><td align="left">stop</td><td align="left">停止容器</td></tr><tr><td align="left"></td><td align="left">start</td><td align="left">启动容器</td></tr><tr><td align="left"></td><td align="left">restart</td><td align="left">重启容器</td></tr><tr><td align="left"></td><td align="left">top</td><td align="left">查看运行的进程</td></tr><tr><td align="left"></td><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatisPlus复习</title>
      <link href="/posts/55889.html"/>
      <url>/posts/55889.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先需要将数据库初始化，以及设置对应的配置文件，完成一些基本的设置</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.itheima:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:mapper/*.xml</span></span><br></pre></td></tr></table></figure><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于使用mybatisPlus来讲，和mybatis区别是它集成好了一些已经定义完成的接口，可以方便我们后续的使用，他包含mybatis的所有功能</span><br><span class="line">    一共需要两步操作：</span><br><span class="line">    - 引入MybatisPlus依赖</span><br><span class="line">- 定义Mapper</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">引入依赖，mybatis依赖是下面的：</span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">替换成mybatisPlus的依赖</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定义简单的Mapper层"><a href="#定义简单的Mapper层" class="headerlink" title="定义简单的Mapper层"></a>定义简单的Mapper层</h2><p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/14/image-20250714175242142-0adc00.png" alt="image-20250714175242142"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因此我们自定义的Mapper只要实现了这个BaseMapper，就无需自己实现单表CRUD了。</span><br><span class="line">修改UserMapper接口，让其继承BaseMapper：</span><br><span class="line">  <span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    注意基础的时候要指定一个泛型，这个泛型是实体类类型，说明要操作指挥哪个实体类</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">要让springBoot扫描到mapper在哪里，有两种方案，一种在开始扫描，另一种加入Mapper注解</span><br><span class="line">  -启动类上加入：<span class="meta">@MapperScan(&quot;com.itheima.mp.mapper&quot;)</span></span><br><span class="line">  -或者实现的接口类上加入  <span class="meta">@Mapper</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyBatisPlus通过扫描实体类，并基于反射获取实体类信息作为数据库表信息。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MybatisPlus如何知道我们要查询的是哪张表？表中有哪些字段呢？</span><br><span class="line">泛型中的User就是与数据库对应的PO.</span><br><span class="line">MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</span><br><span class="line">- MybatisPlus会把PO实体的类名驼峰转下划线作为表名 eg:userInfo&gt;user_info</span><br><span class="line">- MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型 createTime&gt;create_time</span><br><span class="line">- MybatisPlus会把名为id的字段作为主键</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果不符合约定，那么就需要自己进行定义</span><br><span class="line">MybatisPlus中比较常用的几个注解如下：</span><br><span class="line"><span class="meta">@TableName</span>：用来指定表名</span><br><span class="line"><span class="meta">@TableId</span>：用来指定表中的主键字段信息</span><br><span class="line"><span class="meta">@TableField</span>：用来指定表中的普通字段信息</span><br></pre></td></tr></table></figure><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 描述：表名注解，标识实体类对应的表</span><br><span class="line">- 使用位置：实体类</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>schema</td><td>String</td><td>否</td><td>“”</td><td>schema</td></tr><tr><td>keepGlobalPrefix</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td>String</td><td>否</td><td>“”</td><td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>autoResultMap</td><td>boolean</td><td>否</td><td>false</td><td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td>String[]</td><td>否</td><td>{}</td><td>需要排除的属性名 @since 3.3.1</td></tr></tbody></table><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a><strong>@TableId</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">说明：</span><br><span class="line"></span><br><span class="line">- 描述：主键注解，标识实体类中的主键字段</span><br><span class="line">- 使用位置：实体类的主键字段</span><br></pre></td></tr></table></figure><p><code>TableId</code>注解支持两个属性：</p><table><thead><tr><th align="left"><strong>属性</strong></th><th align="left"><strong>类型</strong></th><th align="left"><strong>必须指定</strong></th><th align="left"><strong>默认值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">value</td><td align="left">String</td><td align="left">否</td><td align="left">“”</td><td align="left">表名</td></tr><tr><td align="left">type</td><td align="left">Enum</td><td align="left">否</td><td align="left">IdType.NONE</td><td align="left">指定主键类型</td></tr></tbody></table><p><code>IdType</code>支持的类型有：</p><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">AUTO</td><td align="left">数据库 ID 自增</td></tr><tr><td align="left">NONE</td><td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td align="left">INPUT</td><td align="left">insert 前自行 set 主键值</td></tr><tr><td align="left">ASSIGN_ID</td><td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td align="left">ASSIGN_UUID</td><td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td align="left">ID_WORKER</td><td align="left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td align="left">UUID</td><td align="left">32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td align="left">ID_WORKER_STR</td><td align="left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a><strong>@TableField</strong></h3><p>说明：</p><blockquote><p>描述：普通字段注解</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一般情况下我们并不需要给字段添加<span class="meta">@TableField</span>注解，一些特殊情况除外：</span><br><span class="line">- 成员变量名与数据库字段名不一致</span><br><span class="line">- 成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。</span><br><span class="line">- 成员变量名与数据库一致，但是与数据库的关键字冲突。使用<span class="meta">@TableField</span>注解给字段名添加转义字符：``</span><br></pre></td></tr></table></figure><p>支持的其它属性如下</p><table><thead><tr><th align="center"><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必填</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">value</td><td>String</td><td>否</td><td>“”</td><td>数据库字段名</td></tr><tr><td align="center">exist</td><td>boolean</td><td>否</td><td>true</td><td>是否为数据库表字段</td></tr><tr><td align="center">condition</td><td>String</td><td>否</td><td>“”</td><td>字段 where 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的 <code>%s=#&#123;%s&#125;</code>，<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlCondition.java">参考(opens new window)</a></td></tr><tr><td align="center">update</td><td>String</td><td>否</td><td>“”</td><td>字段 update set 部分注入，例如：当在version字段上注解update&#x3D;”%s+1” 表示更新时会 set version&#x3D;version+1 （该属性优先级高于 el 属性）</td></tr><tr><td align="center">insertStrategy(设置插入要求，后面例子即插入新元素的时候这个不能为空)</td><td>Enum</td><td>否</td><td>FieldStrategy.DEFAULT</td><td>举例：NOT_NULL insert into table_a(<if test="columnProperty != null">column</if>) values (<if test="columnProperty != null">#{columnProperty}</if>)</td></tr><tr><td align="center">updateStrategy(定义在更新记录时，如何处理字段的值。这个属性允许你控制字段是否应该包含在 UPDATE 语句的 SET 子句中，以及在什么条件下包含。)</td><td>Enum</td><td>否</td><td>FieldStrategy.DEFAULT</td><td>举例：IGNORED update table_a set column&#x3D;#{columnProperty}</td></tr><tr><td align="center">whereStrategy</td><td>Enum</td><td>否</td><td>FieldStrategy.DEFAULT</td><td>举例：NOT_EMPTY where <if test="columnProperty != null and columnProperty!=''">column&#x3D;#{columnProperty}</if></td></tr><tr><td align="center">fill</td><td>Enum</td><td>否</td><td>FieldFill.DEFAULT</td><td>字段自动填充策略</td></tr><tr><td align="center">select</td><td>boolean</td><td>否</td><td>true</td><td>是否进行 select 查询</td></tr><tr><td align="center">keepGlobalFormat</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 format 进行处理</td></tr><tr><td align="center">jdbcType</td><td>JdbcType</td><td>否</td><td>JdbcType.UNDEFINED</td><td>JDBC 类型 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">typeHandler</td><td>TypeHander</td><td>否</td><td></td><td>类型处理器 (该默认值不代表会按照该值生效)</td></tr><tr><td align="center">numericScale</td><td>String</td><td>否</td><td>“”</td><td>指定小数点后保留的位数</td></tr></tbody></table><h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.dqmain.po</span> <span class="comment">#别名扫描包 在mapper中指定resultType时，可以不用全类路径了，直接resultType=“User”</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span>  <span class="comment"># Mapper.xml文件地址,默认值</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#是否开启下划线和驼峰的映射</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span> <span class="comment">#是否开启二级缓存</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">assign_id</span> <span class="comment">#id为雪花算法生成,id类型，没有注解的等级高</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span> <span class="comment">#更新策略:只更新非空字段</span></span><br></pre></td></tr></table></figure><p>官网地址：<a href="https://baomidou.com/reference/">https://baomidou.com/reference/</a></p><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/23/image-20250723161643884-82a42d.png" alt="image-20250723161643884"></p><p>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/23/image-20250723161715911-d90713.png" alt="image-20250723161715911"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Wrapper的子类AbstractWrapper提供了where中包含的所有条件构造方法</span><br><span class="line">而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：</span><br><span class="line">而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：</span><br></pre></td></tr></table></figure><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a><strong>QueryWrapper</strong></h3><p>无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//构建查询对象</span></span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">               .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">               .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">               .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">       List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">       users.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testUpdateByQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//1.准备更新的数据</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setBalance(<span class="number">2000</span>);</span><br><span class="line">       <span class="comment">//2 更新的条件</span></span><br><span class="line">       QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       <span class="comment">//3. 执行更新</span></span><br><span class="line">       userMapper.update(user, userQueryWrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a><strong>UpdateWrapper</strong></h3><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line">        <span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper——利用反射机制获取内容"><a href="#LambdaQueryWrapper——利用反射机制获取内容" class="headerlink" title="LambdaQueryWrapper——利用反射机制获取内容"></a><strong>LambdaQueryWrapper</strong>——利用反射机制获取内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。</span><br><span class="line"></span><br><span class="line">简单来说，就是把一些字段写死了，例如查询某些字段的时候，写死成属性值了，但是属性值发生变化的时候，查询也得发生变化，非常麻烦</span><br><span class="line"></span><br><span class="line">其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。</span><br><span class="line">因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</span><br><span class="line">- LambdaQueryWrapper</span><br><span class="line">- LambdaUpdateWrapper</span><br><span class="line">分别对应QueryWrapper和UpdateWrapper</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h2><p>对于SQL代码来讲，最好都都维护在持久层，而不是业务层。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Mapper里面自定义代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br><span class="line">下面两种写法都可以</span><br><span class="line"> <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper或者<span class="meta">@Param(Constants.WRAPPER)</span></span><br><span class="line">&#123;ew.customSqlSegment&#125; 是一个动态拼接的 SQL 片段，它通常是通过 QueryWrapper 生成的条件语句</span><br></pre></td></tr></table></figure><h3 id="多表关联"><a href="#多表关联" class="headerlink" title="多表关联"></a>多表关联</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。</span><br><span class="line">例如下面的连表查询，查询条件可以用mybatisPlus实现</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">      SELECT *</span><br><span class="line">      FROM user u</span><br><span class="line">      INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">      WHERE u.id</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      AND a.city = #&#123;city&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">例如下面的修改和上面一样</span><br><span class="line">@Test</span><br><span class="line">void testCustomJoinWrapper() &#123;</span><br><span class="line">    // 1.准备自定义查询条件</span><br><span class="line">    QueryWrapper<span class="tag">&lt;<span class="name">User</span>&gt;</span> wrapper = new QueryWrapper<span class="tag">&lt;<span class="name">User</span>&gt;</span>()</span><br><span class="line">            .in(&quot;u.id&quot;, List.of(1L, 2L, 4L))</span><br><span class="line">            .eq(&quot;a.city&quot;, &quot;北京&quot;);</span><br><span class="line">    // 2.调用mapper的自定义方法</span><br><span class="line">    List<span class="tag">&lt;<span class="name">User</span>&gt;</span> users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">mapper里面的写法</span><br><span class="line">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span><br><span class="line">List<span class="tag">&lt;<span class="name">User</span>&gt;</span> queryUserByWrapper(@Param(&quot;ew&quot;)QueryWrapper<span class="tag">&lt;<span class="name">User</span>&gt;</span> wrapper); </span><br></pre></td></tr></table></figure><h2 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h2><h3 id="service接口继承"><a href="#service接口继承" class="headerlink" title="service接口继承"></a>service接口继承</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。</span><br><span class="line">通用接口为IService，默认实现为ServiceImpl，其中封装的方法可以分为以下几类：</span><br><span class="line">- save：新增</span><br><span class="line">- remove：删除</span><br><span class="line">- update：更新</span><br><span class="line">- get：查询单个结果</span><br><span class="line">- list：查询集合结果</span><br><span class="line">- count：计数</span><br><span class="line">- page：分页查询</span><br></pre></td></tr></table></figure><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724152143841-54bc2c.png" alt="image-20250724152143841"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- save是新增单个元素</span><br><span class="line">- saveBatch是批量新增</span><br><span class="line">- saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增</span><br><span class="line">- saveOrUpdateBatch是批量的新增或修改</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724152250076-63fb92.png" alt="image-20250724152250076"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- removeById：根据id删除</span><br><span class="line">- removeByIds：根据id批量删除</span><br><span class="line">- removeByMap：根据Map中的键值对为条件删除</span><br><span class="line">- remove(Wrapper&lt;T&gt;)：根据Wrapper条件删除</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724152314666-97341f.png" alt="image-20250724152314666"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- updateById：根据id修改</span><br><span class="line">- update(Wrapper&lt;T&gt;)：根据UpdateWrapper修改，Wrapper中包含set和where部分</span><br><span class="line">- update(T，Wrapper&lt;T&gt;)：按照T内的数据修改与Wrapper匹配到的数据</span><br><span class="line">- updateBatchById：根据id批量修改</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724152353213-093e64.png" alt="image-20250724152353213"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- getById：根据id查询<span class="number">1</span>条数据</span><br><span class="line">- getOne(Wrapper&lt;T&gt;)：根据Wrapper查询<span class="number">1</span>条数据</span><br><span class="line">- getBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724152409694-f7394d.png" alt="image-20250724152409694"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- listByIds：根据id批量查询</span><br><span class="line">- list(Wrapper&lt;T&gt;)：根据Wrapper条件查询多条数据</span><br><span class="line">- list()：查询所有</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724152430648-e6dc52.png" alt="image-20250724152430648"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- count()：统计所有数量</span><br><span class="line">- count(Wrapper&lt;T&gt;)：统计符合Wrapper条件的数据数量</span><br></pre></td></tr></table></figure><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了</span><br></pre></td></tr></table></figure><h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定实体类T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个泛型为这个Service要用到的Mapper（因为将来在Service中要调用Mapper层的方法，不可能自己再实现一遍），第二个泛型为操作的实体类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口示意</span><br><span class="line"><span class="meta">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增用户接口&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> UserFormDTO userFormDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// DTO转化成PO</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.copyProperties(userFormDTO, User.class);</span><br><span class="line">        userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda查询——快速定义where方法"><a href="#Lambda查询——快速定义where方法" class="headerlink" title="Lambda查询——快速定义where方法"></a>Lambda查询——快速定义where方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/24/image-20250724163902989-f40948.png" alt="image-20250724163902989"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service里面就可以直接这样写</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery userQuery)</span> &#123;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; list = lambdaQuery()</span><br><span class="line">       .like(userQuery.getName() != <span class="literal">null</span>, User::getUsername, userQuery.getName())</span><br><span class="line">       .eq(userQuery.getStatus() != <span class="literal">null</span>, User::getStatus, userQuery.getStatus())</span><br><span class="line">       .lt(userQuery.getMaxBalance() != <span class="literal">null</span>, User::getBalance, userQuery.getMaxBalance())</span><br><span class="line">       .gt(userQuery.getMinBalance() != <span class="literal">null</span>, User::getBalance, userQuery.getMinBalance()).list();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="批量新增"><a href="#批量新增" class="headerlink" title="批量新增"></a>批量新增</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">maybatisPlus自带了批量新增，但是需要给数据库加入一个字段才能真正的实现批量新增的功能</span></span><br><span class="line"><span class="string">新增参数rewriteBatchedStatements=true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件</p><p>配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/25/image-20250725165131920-a3e5bd.png" alt="image-20250725165131920"></p><p>在弹出的窗口里面，写入要确定的表的名称位置</p><p>再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/25/image-20250725165213146-fe4a7e.png" alt="image-20250725165213146"></p><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能</p><p>解决循环依赖的问题</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/25/image-20250725170554968-258b52.png" alt="image-20250725170554968"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用方案,使用方法和正常的用法一致，只是需要转递一个字节码</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Db.lambdaUpdate(User.class)</span><br><span class="line">            .set(User::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>).update();;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果找不到Db类的话，要注意升级mybatisplus版本</p></blockquote><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>逻辑删除就是基于代码逻辑模拟删除效果，但并不会真正删除数据。思路如下：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为1</li><li>查询时只查询标记为0的数据*</li></ul><p>第一步：给实体添加<code>deleted</code>字段：注意deleted只是一个字段名可以修改，保证和配置一致即可</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">数据库实际做的操作是：Preparing: UPDATE address SET deleted=<span class="number">1</span> WHERE id=? AND deleted=<span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p></blockquote><h2 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h2><p>首先顶一个枚举的状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FROZEN(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//标记枚举的值是哪个,标记枚举属性完成与数据库的映射,标记了数据库映射后存储的值</span></span><br><span class="line">    <span class="meta">@JsonValue</span>  <span class="comment">//标记返回的值为哪个,@JsonValue注解标记JSON序列化时展示的字段,即返回给前端的值是哪个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置里面配置枚举类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    <span class="keyword">default</span>-<span class="keyword">enum</span>-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br></pre></td></tr></table></figure><h2 id="JSON类型处理器"><a href="#JSON类型处理器" class="headerlink" title="JSON类型处理器"></a>JSON类型处理器</h2><p>数据库的user表中有一个<code>info</code>字段，是JSON类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。</span><br></pre></td></tr></table></figure><p>一共三步骤</p><p>第一步定义要接受的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步骤，加入注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">详细信息</span><br><span class="line"><span class="meta">@TableField(typeHandler =JacksonTypeHandler.class)</span></span><br><span class="line"><span class="keyword">private</span> UserInfo info;</span><br></pre></td></tr></table></figure><p>第三步，类上面加个注解，声明自动映射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(value = &quot;user&quot;,autoResultMap = true)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，要修改到所有使用UserInfo的地方，包括VO地方，</p></blockquote><p>返回结果如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/25/image-20250725180131114-f0120b.png" alt="image-20250725180131114"></p><h1 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h1><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenantLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li></ul><p><strong>注意：</strong> 使用多个插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除</li></ul><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。</p><h3 id="构建配置类"><a href="#构建配置类" class="headerlink" title="构建配置类"></a>构建配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建分页插件</span></span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL);</span><br><span class="line">        paginationInnerInterceptor.setMaxLimit(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//2.添加分页插件</span></span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，于 v3.5.9 起，PaginationInnerInterceptor 已分离出来。如需使用，则需单独引入 mybatis-plus-jsqlparser 依赖</p><!-- jdk 11+ 引入可选模块 --><dependency><p>​    <groupId>com.baomidou</groupId></p><p>​    <artifactId>mybatis-plus-jsqlparser</artifactId></p><p>​    <version>3.5.9</version></p></dependency><!-- jdk 8+ 引入可选模块 --><dependency><p>​    <groupId>com.baomidou</groupId></p><p>​    <artifactId>mybatis-plus-jsqlparser-4.9</artifactId></p></dependency></blockquote><h3 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 准备分页条件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//分页条件</span></span><br><span class="line">        Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">//排序条件,第一个参数对哪个字段，第二个参数升序还是降序</span></span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        Page&lt;User&gt; page1 = userService.page(page);</span><br><span class="line">        <span class="comment">//解析</span></span><br><span class="line">        System.out.println(page1.getTotal());</span><br><span class="line">        System.out.println(page1.getPages());</span><br><span class="line">        System.out.println(page1.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">或者升序或者降序可以写成这样：page.addOrder(OrderItem.desc(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>().setColumn(<span class="string">&quot;balance&quot;</span>).setAsc(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure><h2 id="通用分页实体"><a href="#通用分页实体" class="headerlink" title="通用分页实体"></a>通用分页实体</h2><h3 id="定义一个查询参数"><a href="#定义一个查询参数" class="headerlink" title="定义一个查询参数"></a>定义一个查询参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">让别的查询参数来继承这个父类</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义返回参数"><a href="#定义返回参数" class="headerlink" title="定义返回参数"></a>定义返回参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页结果&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总条数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总页数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;集合&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询接口进行转化填入即可"><a href="#查询接口进行转化填入即可" class="headerlink" title="查询接口进行转化填入即可"></a>查询接口进行转化填入即可</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    <span class="comment">// 1.1.分页条件</span></span><br><span class="line">    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());</span><br><span class="line">    <span class="comment">// 1.2.排序条件</span></span><br><span class="line">    <span class="keyword">if</span> (query.getSortBy() != <span class="literal">null</span>) &#123;</span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 默认按照更新时间排序</span></span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.数据非空校验</span></span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.有数据，转换</span></span><br><span class="line">    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);</span><br><span class="line">    <span class="comment">// 5.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改造PageQuery实体"><a href="#改造PageQuery实体" class="headerlink" title="改造PageQuery实体"></a>改造PageQuery实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(defaultSortBy, isAsc));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改造PageDTO实体"><a href="#改造PageDTO实体" class="headerlink" title="改造PageDTO实体"></a>改造PageDTO实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">convertor这个参数是一个转化函数，即自己可以自己定义转化方式，如果类型字段不一致</span><br><span class="line">例如：</span><br><span class="line">PageDTO.of(page, user -&gt; &#123;</span><br><span class="line">        <span class="comment">// 拷贝属性到VO</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">vo</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">        <span class="comment">// 用户名脱敏</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">        vo.setUsername(username.substring(<span class="number">0</span>, username.length() - <span class="number">2</span>) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vo;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h1><h2 id="实体三个区分"><a href="#实体三个区分" class="headerlink" title="实体三个区分"></a>实体三个区分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实体类有三个，pojo（对应数据库），vo（客户端，后端返回给前端的数据），dto（服务器，前端传递给后端的数据）</span><br></pre></td></tr></table></figure><h2 id="lombook包注解"><a href="#lombook包注解" class="headerlink" title="lombook包注解"></a>lombook包注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserService userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> 关键字用于声明不可变的变量：注入的依赖不可变：一旦初始化，userService 不能被重新赋值，避免意外修改。</span><br><span class="line">    就必须在初始化的时候对常量进行赋值，</span><br><span class="line">    <span class="meta">@RequiredArgsConstructor</span> -&gt; 只对需要在初始化时候构造的变量进行构造</span><br></pre></td></tr></table></figure><h2 id="hutool工具包使用"><a href="#hutool工具包使用" class="headerlink" title="hutool工具包使用"></a>hutool工具包使用</h2><p>hutool是java的一个工具库，提供了大量的工具类和方法。</p><p><a href="https://blog.csdn.net/qq_46668017/article/details/142024288?fromshare=blogdetail&sharetype=blogdetail&sharerId=142024288&sharerefer=PC&sharesource=KillTheGood&sharefrom=from_link">https://blog.csdn.net/qq_46668017/article/details/142024288?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=142024288&amp;sharerefer=PC&amp;sharesource=KillTheGood&amp;sharefrom=from_link</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanUtil.copyProperties(user, UserVO.class);  复制属性</span><br><span class="line">BeanUtil.copyToList(users, UserVO.class);   复制集合</span><br></pre></td></tr></table></figure><h2 id="Swagger注解"><a href="#Swagger注解" class="headerlink" title="Swagger注解"></a>Swagger注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span> → <span class="meta">@Tag</span></span><br><span class="line"><span class="meta">@ApiIgnore</span> → <span class="meta">@Parameter(hidden = true)</span> 或 <span class="meta">@Operation(hidden = true)</span> 或 <span class="meta">@Hidden</span></span><br><span class="line"><span class="meta">@ApiImplicitParam</span> → <span class="meta">@Parameter</span></span><br><span class="line"><span class="meta">@ApiImplicitParams</span> → <span class="meta">@Parameters</span></span><br><span class="line"><span class="meta">@ApiModel</span> → <span class="meta">@Schema</span></span><br><span class="line"><span class="meta">@ApiModelProperty(hidden = true)</span> → <span class="meta">@Schema(accessMode = READ_ONLY)</span></span><br><span class="line"><span class="meta">@ApiModelProperty</span> → <span class="meta">@Schema</span></span><br><span class="line"><span class="meta">@ApiOperation(value = “foo”, notes = “bar”)</span> → <span class="meta">@Operation(summary = “foo”, description = “bar”)</span></span><br><span class="line"><span class="meta">@ApiParam</span> → <span class="meta">@Parameter</span></span><br><span class="line"><span class="meta">@ApiResponse(code = 404, message = “foo”)</span> → <span class="meta">@ApiResponse(responseCode = “404”, description = “foo”)</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">依赖引入</span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">配置</span></span><br><span class="line"><span class="comment">#swagger接口配置文件</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">用户管理接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;用户管理接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.itheima.mp.controller</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口示意</span><br><span class="line"><span class="meta">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增用户接口&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> UserFormDTO userFormDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// DTO转化成PO</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.copyProperties(userFormDTO, User.class);</span><br><span class="line">        userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EqualsAndHashCode-callSuper-true"><a href="#EqualsAndHashCode-callSuper-true" class="headerlink" title="@EqualsAndHashCode(callSuper &#x3D; true)"></a>@EqualsAndHashCode(callSuper &#x3D; true)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">callSuper = true，根据子类自身的字段值和从父类继承的字段值 来生成hashcode，当两个子类对象比较时，只有子类对象的本身的字段值和继承父类的字段值都相同，equals方法的返回值是true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis原理和实战</title>
      <link href="/posts/58965.html"/>
      <url>/posts/58965.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p><code>Redis</code>是一种键值型的<code>NoSql</code>数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p><code>NoSql</code></p></li></ul><p>其中<strong>键值型</strong>，是指<code>Redis</code>中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至<code>json</code>：</p><h2 id="NoSQL与SQL的对比"><a href="#NoSQL与SQL的对比" class="headerlink" title="NoSQL与SQL的对比"></a><code>NoSQL</code>与<code>SQL</code>的对比</h2><h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><p><code>NoSQL</code></p><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317145611174-bebf61.png" alt="image-20250317145611174"></p><p><code>SQL</code></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。可以是键值型、文档类型甚至是图格式。：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161352186-189da3.png" alt="image-20250317161352186"></p><h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161424361-0a4762.png" alt="image-20250317161424361"></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161521208-33e421.png" alt="image-20250317161521208"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/J1MqOJM-69959f.png"></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161544032-454729.png" alt="image-20250317161544032"></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li><p>扩展性</p><ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识<code>Redis</code></h2><p>  <strong>特征：</strong></p><ul><li><strong>键值（key-value）型，value支持多种不同数据结构，功能丰富</strong></li><li><strong>单线程，每个命令具备原子性</strong></li><li><strong>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</strong></li><li><strong>支持数据持久化(定期将内存搬运到磁盘)</strong></li><li><strong>支持主从集群、分片集群（数据拆分）</strong></li><li><strong>支持多语言客户端</strong></li></ul><h2 id="wsl使用"><a href="#wsl使用" class="headerlink" title="wsl使用"></a>wsl使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切换环境</span><br><span class="line">wsl --set-default CentOS7</span><br><span class="line"></span><br><span class="line">老式启动</span><br><span class="line">wsl -d name</span><br></pre></td></tr></table></figure><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h3 id="上传安装包并解压"><a href="#上传安装包并解压" class="headerlink" title="上传安装包并解压"></a>上传安装包并解压</h3><p>然后将 提供的Redis安装包上传到CentOS7的指定位置，在这里我使用的是WSL来创建一个Windows版本下的Linux子系统，来进行使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">解压缩：</span><br><span class="line">tar -xzf redis-<span class="number">6.2</span><span class="number">.6</span>.tar.gz</span><br><span class="line">进入解压缩目录</span><br><span class="line">    cd redis-<span class="number">6.2</span><span class="number">.6</span></span><br><span class="line">运行编译命令</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">默认的安装路径是在</span><br><span class="line">    /usr/local/bin 的目录下面</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317231710237-024fa8.png" alt="image-20250317231710237"></p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/home/Redis/redis-6.2.6</code>），名字叫redis.conf</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317232150256-22eb1b.png" alt="image-20250317232150256"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br><span class="line"><span class="comment"># 关闭保护模式：</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /home/Redis/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /home/Redis/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br><span class="line"><span class="comment"># linux下查询redis运行程序</span></span><br><span class="line">ps -ef | grep <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><code>Redis</code>常见命令</h2><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317232906001-289359.png" alt="image-20250317232906001"></p><p><code>Redis</code>为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（<a href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p><p>同时<code>Redis</code>是通过分组来进行学习的，即每一种数据类型是一个组的类型，可以通过分别学习一个数据类型来进行学习。还可以通过<code>Redis</code>运行命令进行查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用  &quot;help @&lt;group&gt;&quot; to get a list of commands in &lt;group&gt;</span><br><span class="line">eg: help @generic</span><br></pre></td></tr></table></figure><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><code>Redis</code>通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key，不建议在生产环境设备上使用，因为<code>Redis</code>是单线程的，如果数据量很大的话，可能导致<code>Redis</code>进行阻塞</li><li>DEL：删除一个指定的key，也可以删除多个</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期，-1代表永久有效，-2代表被删除</li></ul><blockquote><p>可以通过help [command] 可以查看一个命令的具体用法</p></blockquote><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型，也就是字符串类型，是<code>Redis</code>中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</p><h4 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h4><p>String的常见命令有：</p><ul><li><code>SET</code>：添加或者修改已经存在的一个String类型的键值对</li><li><code>GET</code>：根据key获取String类型的value</li><li><code>MSET</code>：批量添加多个String类型的键值对：MSET  key value</li><li><code>MGET</code>：根据多个key获取多个String类型的value : MGET key1 key2</li><li><code>INCR</code>：让一个整型的key自增1 : INCR KEY</li><li><code>INCRBY</code>:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 :INCRBY key increment</li><li><code>INCRBYFLOAT</code>：让一个浮点类型的数字自增并指定步长 :INCRBYFLOAT key increment</li><li><code>SETNX</code>：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li><code>SETEX</code>：添加一个String类型的键值对，并且指定有效期</li></ul><h4 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h4><p>对于<code>Redis</code>，完全靠key来区分不同的数据，我们可以添加不同的前缀来进行区分，即在对应的项目前面加上对应的区分关系，<code>Redis</code>的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>格式并非固定，也可以根据自己的需求来删除或添加词条。就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user相关的key：Curry:user:1</span><br><span class="line">product相关的key：Curry:product:1</span><br></pre></td></tr></table></figure><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为<code>JSON</code>字符串后存储：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET Curry:user:1 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span><br></pre></td></tr></table></figure><p>在<code>Redis</code>的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/18/image-20250318231607701-22d095.png" alt="image-20250318231607701"></p><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/24/x2zDBjf-741019.png"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/24/VF2EPt0-8c79ee.png"></p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HSET Curry:user:3 name neu</span><br><span class="line">HSET Curry:user:3 age  101</span><br><span class="line">存储出来的格式如下图所示</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/25/image-20250325173135825-4cb900.png" alt="image-20250325173135825"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取出来操作：HGET Curry:user:3 name</span><br><span class="line">一次性拿出来所有 HGETAll Curry:user:3，把KEY Value 依次返回 </span><br></pre></td></tr></table></figure><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">怎么通过它实现一个栈效果呢</span><br><span class="line">入口和出口一致即可</span><br><span class="line">怎么通过它实现一个队列效果呢</span><br><span class="line">入口和出口不一致即可</span><br><span class="line">怎么通过它实现一个阻塞队列呢？</span><br><span class="line">使用BLPOP 和 BRPOP</span><br></pre></td></tr></table></figure><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><p>注意要是顺序，升序，从小到大，那你如果要取出前三个最大的，那就要REV</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg：ZREVrange stus 0 2   取出值最大的前三个</span><br></pre></td></tr></table></figure><h2 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * jedis 设置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisConfig</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//1. 建立连接</span></span><br><span class="line">      jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;172.19.77.55&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">      <span class="comment">//2. 设置连接密码</span></span><br><span class="line">      jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      <span class="comment">//3. 选择库</span></span><br><span class="line">      jedis.select(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//加入内容</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">set</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;jedis&quot;</span>, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;加入内容结果：&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取内容</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">jedisResult</span> <span class="operator">=</span> <span class="built_in">this</span>.jedis.get(<span class="string">&quot;jedis&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;获取响应内容：&quot;</span> + jedisResult);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterEach</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisClose</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//关闭连接</span></span><br><span class="line">      jedis.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//jedis配置</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//设置总的连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//设置空闲时候保存的最大连接数，如果空闲，会保存一段时间连接，然后才清除掉</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//设置空闲时候保存的最小连接数，会清除为0</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置连接时间，如果连接池满了，那么就会进行等待，默认-1一直等待</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;172.19.77.55&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">当有连接池的时候，那么就不需要进行close,而是进行归还</span><br></pre></td></tr></table></figure><h3 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，<a href="https://spring.io/projects/spring-data-redis">官网地址</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/22/UFlNIV0-a8f7c5.png"></p><h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><p>引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--redis依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--common-pool--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Jackson依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><p>spring默认使用lettuce实现连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: redis-demo</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: <span class="number">172.19</span><span class="number">.77</span><span class="number">.55</span></span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      password: <span class="number">123456</span></span><br><span class="line">      lettuce:</span><br><span class="line">        pool:</span><br><span class="line">          max-active: <span class="number">8</span> #最大连接</span><br><span class="line">          max-idle: <span class="number">8</span> #最大空闲连接</span><br><span class="line">          min-idle: <span class="number">0</span> #最小空闲连接</span><br><span class="line">          max-wait: 100ms #连接等待时间</span><br></pre></td></tr></table></figure><h4 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate edisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RedisTemplate可以接收任意Object作为值写入Redis，但是写入前会把Object序列化为字节新式，默认是采用JDK序列化，导致可读性很差，所以我们可以自定义序列化，如下图所示</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425134837192-e305e8.png" alt="image-20250425134837192"></p><p>可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">redisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 redisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置Key的序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置Value的序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存到数据库中如下图所示：如果存储的是对象，会自动存储对象的地址，到时候从Redis取出，可以直接进行强制转换，转换成想要的内容。</span><br><span class="line">目的是为了查询时实现自动反序列化</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425134822602-c7faee.png" alt="image-20250425134822602"></p><h4 id="手动序列化"><a href="#手动序列化" class="headerlink" title="手动序列化"></a>手动序列化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于上面自动序列化，一直会加入上面这个属性，对于大型系统来讲，很占用内存空间，可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425142026125-906c54.png" alt="image-20250425142026125"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意这里使用的mapper是spring自带的一个序列化工具，也可以使用fastjson等自定义json工具进行转换</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">//设置手动序列化内容，要使用他进行序列化以及反序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">//写入一条数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new一个对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;刀哥&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> mapper.writeValueAsString(user1);</span><br><span class="line">        <span class="comment">//写入一条数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, string);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(s, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><p>一共要学习的内容</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425154856912-e7823e.png" alt="image-20250425154856912"></p><p>数据库记录</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425152409811-aafd97.png" alt="image-20250425152409811"></p><p>项目记录</p><p>由于这是一个Redis项目，所以后端没有采用微服务，而是简单采用tomcat，可以使用集群的方法，进行部署，减少服务器压力</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425154923397-a12d97.png" alt="image-20250425154923397"></p><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="基于Session实现登录登录流程"><a href="#基于Session实现登录登录流程" class="headerlink" title="基于Session实现登录登录流程"></a>基于Session实现登录登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带着sessionID到后台，后台通过sessionID从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal(线程域对象)中，并且放行</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/27/image-20250427163347883-3cd5f7.png" alt="image-20250427163347883"></p><h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">功能比较简单，就首先查验手机号是否正确，之后生成验证码，调用第三方服务发送验证码，返回即可</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 校验手机号是否合格</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//3. 生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//4. 保存验证码到session里面</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        <span class="comment">//5. 发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送短信验证码成功，验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 登录功能的实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">      <span class="comment">//1. 校验手机号</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">      <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">          <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">      <span class="keyword">if</span> (cacheCode != <span class="literal">null</span> &amp;&amp; !cacheCode.toString().equals(code)) &#123;</span><br><span class="line">          <span class="comment">//3. 验证码不一致报错</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. 一致的话，根据手机号查询数据库，看这个手机号是否存在，从而决定   登录/注册</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">      <span class="comment">//5. 判断用户是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//6. 不存在，创建新用户并且进行保存</span></span><br><span class="line">          user = creatUserWithPhone(phone);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//7. 保存用户信息到session里面即可</span></span><br><span class="line">      session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">      <span class="keyword">return</span> Result.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="登录验证功能"><a href="#登录验证功能" class="headerlink" title="登录验证功能"></a>登录验证功能</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总体的流程来讲，当要进行访问的时候，首先进入拦截器，拦截器会查看是否携带Cookie，携带获取到用户，然后进行查询是否存在，保存到threadlocal，供验证函数使用</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/05/image-20250505161410663-361c37.png" alt="image-20250505161410663"></p><h4 id="拦截器制作"><a href="#拦截器制作" class="headerlink" title="拦截器制作"></a>拦截器制作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、从请求当中获取到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 2、获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 4、不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5、存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line">        <span class="comment">// 6、放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是返回controller后调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是渲染后调用的函数方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册到拦截器上"><a href="#注册到拦截器上" class="headerlink" title="注册到拦截器上"></a>注册到拦截器上</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将刚才写的拦截器加入到拦截器当中，同时设置哪些可以进行放行，不需要进行登录</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));</span><br></pre></td></tr></table></figure><p><strong>在拦截器处：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507143439962-f10795.png" alt="image-20250507143439962"></p><h3 id="Redis代替session的业务流程"><a href="#Redis代替session的业务流程" class="headerlink" title="Redis代替session的业务流程"></a>Redis代替session的业务流程</h3><p>登录功能的实现<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507144556627-febda9.png" alt="image-20250507144556627"></p><p>登录校验实现<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507144616643-c43482.png" alt="image-20250507144616643"></p><h4 id="登录和注册功能"><a href="#登录和注册功能" class="headerlink" title="登录和注册功能"></a>登录和注册功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 校验码的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 校验手机号是否合格</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//3. 生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//4. 保存验证码到Redis当中里面</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5. 发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送短信验证码成功，验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 登录功能的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 校验手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span> (cacheCode != <span class="literal">null</span> &amp;&amp; !cacheCode.equals(code)) &#123;</span><br><span class="line">            <span class="comment">//3. 验证码不一致报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 一致的话，根据手机号查询数据库，看这个手机号是否存在，从而决定   登录/注册</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">        <span class="comment">//5. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//6. 不存在，创建新用户并且进行保存</span></span><br><span class="line">            user = creatUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 保存用户信息到redis里面即可</span></span><br><span class="line">        <span class="comment">//7.1 随机生成一个Token，作为登录令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);<span class="comment">//设置带不带下划线，这里true设置为不带下划线</span></span><br><span class="line">        <span class="comment">//7.2 将user对象转化为HashMap进行存储</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        <span class="comment">//7.3 存储</span></span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(tokenKey, map);</span><br><span class="line">        <span class="comment">//设置token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="登录验证功能-1"><a href="#登录验证功能-1" class="headerlink" title="登录验证功能"></a>登录验证功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 4、不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、基于token获取Redis中的用户</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">// 3、判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 4、不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将查询到的Hash数据转化为UserDTO对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);<span class="comment">//第三个错误是忽略不忽略</span></span><br><span class="line">        <span class="comment">// 5、存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 刷新Token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 6、放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是返回controller后调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是渲染后调用的函数方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO);</span><br><span class="line">  当往redis存储的时候，选择的是StringRedisTemplate,那么redis只能保存string的数据，这样转化完成有其他属性要进行转化，最好写成这样</span><br><span class="line">        Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">下面这个设置的是对字段进行修改，第一个参数是字段名称，第二个参数是字段值，我们直接把字段值都修改成string即可</span><br><span class="line">setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br></pre></td></tr></table></figure><h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><p>现在的实现，可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，优化方案如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507170108087-6a3377.png" alt="image-20250507170108087"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、基于token获取Redis中的用户</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">// 3、判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将查询到的Hash数据转化为UserDTO对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);<span class="comment">//第三个错误是忽略不忽略</span></span><br><span class="line">        <span class="comment">// 5、存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 刷新Token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 6、放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是返回controller后调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是渲染后调用的函数方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将刚才写的拦截器加入到拦截器当中，同时设置哪些可以进行放行，不需要进行登录</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        ).order(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).excludePathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">纯JWT：无状态，所有信息都包含在 Token 中，服务端不保存任何状态，适合完全无状态的分布式系统，但无法灵活控制 Token 的失效和注销。</span><br><span class="line"></span><br><span class="line">Token + Redis：有状态，Token 存在客户端，状态保存在 Redis 中，服务端通过 Redis 管理 Token 的有效性，方便实现 Token 的失效、注销和续期，适合有状态管理需求的分布式系统。</span><br><span class="line"></span><br><span class="line">Session：有状态，用户信息存储在服务端（内存或 Redis 等），通过 Session ID 维护用户状态，适合中小型系统或传统 Web 应用，需在分布式系统中借助 Redis 共享 Session。</span><br></pre></td></tr></table></figure><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><p>缓存(Cache),就是数据交换的<strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码</p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507174003337-7e31a6.png" alt="image-20250507174003337"></p><h3 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h3><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20220523212915666-4f7937.png"></p><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/1653322097736-6ca8f2.png" alt="1653322097736"></p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">     <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">     <span class="comment">//2.判断是否存在</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">         <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">         <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">     <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">     <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">     <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//6.保存到redis当中</span></span><br><span class="line">     stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line">     <span class="comment">//7.返回</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/12/image-20250512155705078-3501f1.png" alt="image-20250512155705078"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</span><br><span class="line"></span><br><span class="line">内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</span><br><span class="line">超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</span><br><span class="line">主动更新：我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/12/image-20250512171757706-90e3e3.png" alt="image-20250512171757706"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于我们的缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:</span><br><span class="line">用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务</span><br><span class="line"></span><br><span class="line">有如下几种方案</span><br><span class="line">Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</span><br><span class="line">Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</span><br><span class="line">Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</span><br></pre></td></tr></table></figure><p>由于没有剩下两种方案实现，所以我们选择方案一，但是如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存——————选择</li></ul></li><li>如何保证缓存与数据库的操作的同时成功或失败？<ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>那么对于双写还存在一些问题——先操作缓存还是先操作数据库？</p><ul><li>先删除缓存，再操作数据库——存在问题两个线程，删除缓存更新过程中有人查询会出错</li><li>先操作数据库，再删除缓存——存在问题，两个线程查询缓存未命中进行更新缓存过程中对数据库进行修改，由于这种方案概率较低，所以选择这种方案进行实现</li></ul><h3 id="实现商铺和缓存与数据库双写一致"><a href="#实现商铺和缓存与数据库双写一致" class="headerlink" title="实现商铺和缓存与数据库双写一致"></a>实现商铺和缓存与数据库双写一致</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心思路如下：</span><br><span class="line">修改ShopController中的业务逻辑，满足下面的需求：</span><br><span class="line"></span><br><span class="line">根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</span><br><span class="line">根据id修改店铺时，先修改数据库，再删除缓存</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改ShopServiceImpl的queryById方法设置：redis缓存时添加过期时间</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.保存到redis当中</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先修改数据库，再删除缓存</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺ID不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新数据库</span></span><br><span class="line">        updateById(shop);</span><br><span class="line">        <span class="comment">//删除缓存</span></span><br><span class="line">        stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**缓存空对象思路分析：**当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**布隆过滤：**布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</span><br><span class="line">假设布隆过滤器判断这个数据不存在，则直接返回</span><br><span class="line">这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</span><br><span class="line">   </span><br><span class="line">布隆过滤，不存在是真的不存在，存在是可能存在</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/15/image-20250515205437935-3da640.png" alt="image-20250515205437935"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/15/image-20250515210723478-ff5653.png" alt="image-20250515210723478"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">      <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">      <span class="comment">//2.判断是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">          <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">          <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存储空值，那么就保证缓存穿透</span></span><br><span class="line">      <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">      <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">      <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">      <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">          <span class="comment">//保存空值</span></span><br><span class="line">          stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.保存到redis当中</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">      <span class="comment">//7.返回</span></span><br><span class="line">      <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line">* 给不同的Key的TTL添加随机值</span><br><span class="line">* 利用Redis集群提高服务的可用性——哨兵机制，有多个Redis服务器集群，一个挂了可以用其他的</span><br><span class="line">* 给缓存业务添加降级限流策略</span><br><span class="line">* 给业务添加多级缓存——有其他地方也可以进行缓存，eg:浏览器缓存、</span><br></pre></td></tr></table></figure><h3 id="缓存击穿问题及解决思路-热点Key"><a href="#缓存击穿问题及解决思路-热点Key" class="headerlink" title="缓存击穿问题及解决思路(热点Key)"></a>缓存击穿问题及解决思路(热点Key)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</span><br><span class="line"></span><br><span class="line">常见的解决方案有两种：</span><br><span class="line">* 互斥锁</span><br><span class="line">* 逻辑过期</span><br></pre></td></tr></table></figure><h4 id="缓存击穿问题出现"><a href="#缓存击穿问题出现" class="headerlink" title="缓存击穿问题出现"></a>缓存击穿问题出现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设线程<span class="number">1</span>在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程<span class="number">1</span>走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程<span class="number">1</span>没有走完的时候，后续的线程<span class="number">2</span>，线程<span class="number">3</span>，线程<span class="number">4</span>同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519213942557-77f02a.png" alt="image-20250519213942557"></p><h4 id="互斥锁解决"><a href="#互斥锁解决" class="headerlink" title="互斥锁解决"></a>互斥锁解决</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + <span class="type">double</span> check来解决这样的问题。</span><br><span class="line"></span><br><span class="line">假设现在线程<span class="number">1</span>过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程<span class="number">1</span>就会一个人去执行逻辑，假设现在线程<span class="number">2</span>过来，线程<span class="number">2</span>在执行过程中，并没有获得到锁，那么线程<span class="number">2</span>就可以进行到休眠，直到线程<span class="number">1</span>把锁释放后，线程<span class="number">2</span>获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519214026638-3ffe0a.png" alt="image-20250519214026638"></p><h4 id="逻辑过期方案"><a href="#逻辑过期方案" class="headerlink" title="逻辑过期方案"></a>逻辑过期方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程<span class="number">1</span>去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程<span class="number">1</span>去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程<span class="number">1</span>直接进行返回，假设现在线程<span class="number">3</span>过来访问，由于线程线程<span class="number">2</span>持有着锁，所以线程<span class="number">3</span>无法获得锁，线程<span class="number">3</span>也直接返回数据，只有等到新开的线程<span class="number">2</span>把重建数据构建完后，其他线程才能走返回正确的数据。</span><br><span class="line"></span><br><span class="line">这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519214126507-33f794.png" alt="image-20250519214126507"></p><h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519214153508-280bcc.png" alt="image-20250519214153508"></p><h4 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询。如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/02/image-20250602171525287-1b3807.png" alt="image-20250602171525287"></p><h5 id="操作锁的内容"><a href="#操作锁的内容" class="headerlink" title="操作锁的内容"></a>操作锁的内容</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">本质上利用了redis当中的setnx，当设置的KEY存在的时候，不能进行设置</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取互斥锁的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解决缓存击穿问题</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//2.判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           <span class="keyword">return</span> shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//存储空值，那么就保证缓存穿透</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//实现缓存重建</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//获取互斥锁</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">           <span class="comment">//查看是否获取成功</span></span><br><span class="line">           <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">               <span class="comment">//失败,休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//成功根据ID查询数据库</span></span><br><span class="line">           <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">           shop = getById(id);</span><br><span class="line">           <span class="comment">//模拟重建的延时</span></span><br><span class="line">           Thread.sleep(<span class="number">200</span>);</span><br><span class="line">           <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">           <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//5.查询数据库不存在，返回错误，解决缓存穿透问题</span></span><br><span class="line">               <span class="comment">//保存空值</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.保存到redis当中</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放互斥锁</span></span><br><span class="line">           unLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//7.返回</span></span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="利用逻辑过期时间解决缓存击穿问题"><a href="#利用逻辑过期时间解决缓存击穿问题" class="headerlink" title="利用逻辑过期时间解决缓存击穿问题"></a>利用逻辑过期时间解决缓存击穿问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</span><br><span class="line">    </span><br><span class="line">为什么在一开始未命中的情况下直接返回呢，因为这种热点KEY一般都会进行预热，即把这部分内容存入到缓存当中，不会存在过期，所以没命中就可以直接返回</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/03/image-20250603140452809-6039e2.png" alt="image-20250603140452809"></p><h5 id="预热函数"><a href="#预热函数" class="headerlink" title="预热函数"></a>预热函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 预热函数，相当于把数据先存入到Redis当中</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expireSeconds</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shop2Redis</span><span class="params">(<span class="type">long</span> id, Long expireSeconds)</span> &#123;</span><br><span class="line">       <span class="comment">//1.查询商铺数据</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">       <span class="comment">//3.写入Redis当中</span></span><br><span class="line">       stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="利用逻辑时间解决问题"><a href="#利用逻辑时间解决问题" class="headerlink" title="利用逻辑时间解决问题"></a>利用逻辑时间解决问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用逻辑过期解决缓存击穿问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">//2.1未命中直接返回空值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 命中</span></span><br><span class="line">        <span class="comment">//3.判断缓存是否过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//3.1 未过期，返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 过期</span></span><br><span class="line">        <span class="comment">//4.1 尝试获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(key);</span><br><span class="line">        <span class="comment">//4.3获取成功开启独立线程</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//二次确认，我这里没写，实际上存在当你获取到锁后，可能前一个刚好释放，但是redis已经更新的情况</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.shop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unLock(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2获取锁失败，返回原本商铺信息</span></span><br><span class="line">        <span class="comment">//6.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="秒杀优惠券"><a href="#秒杀优惠券" class="headerlink" title="秒杀优惠券"></a>秒杀优惠券</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</span><br><span class="line"></span><br><span class="line">* id的规律性太明显</span><br><span class="line">* 受单表数据量的限制——因为优惠卷一般是多个表，分布式存储表格，每个表自增长是一样的，会出现ID重复的问题</span><br></pre></td></tr></table></figure><h3 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h3><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：唯一性、高可用、高性能、递增性、安全性。</p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/07/image-20250607172446289-cde1bf.png" alt="image-20250607172446289"></p><p>ID的组成部分：符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始时间戳</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1749340800L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移动单位</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">      <span class="comment">//1.生成时间戳</span></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">      <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line">      <span class="comment">//2.生成序列号</span></span><br><span class="line">      <span class="comment">//2.1 获取当前的日期</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> <span class="variable">increment</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">      <span class="comment">//3.拼接并且进行返回</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | increment ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> RedisWorkId redisWorkId;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//new 一个500个线程的线程池</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">               <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line">           &#125;</span><br><span class="line">           countDownLatch.countDown();</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">           es.submit(task);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;begin-end = &quot;</span> + (end - begin));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局唯一ID生成策略：</span><br><span class="line">    UUID</span><br><span class="line">    Redis自增</span><br><span class="line">    snowflake算法</span><br><span class="line">    数据库自增</span><br></pre></td></tr></table></figure><h4 id="注意——异步线程知识"><a href="#注意——异步线程知识" class="headerlink" title="注意——异步线程知识"></a>注意——异步线程知识</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于countdownlatch</span><br><span class="line"></span><br><span class="line">countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</span><br><span class="line"></span><br><span class="line">我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</span><br><span class="line"></span><br><span class="line">CountDownLatch 中有两个最重要的方法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、countDown</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、await</span><br><span class="line"></span><br><span class="line">await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为<span class="number">0</span>时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为<span class="number">0</span> 呢，我们只需要调用一次countDown ，内部变量就减少<span class="number">1</span>，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是<span class="number">0</span>，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</span><br></pre></td></tr></table></figure><h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><p>增普通卷代码：  **VoucherController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VoucherServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现优惠卷秒杀下单"><a href="#实现优惠卷秒杀下单" class="headerlink" title="实现优惠卷秒杀下单"></a>实现优惠卷秒杀下单</h3><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/08/1653366238564-221177.png" alt="1653366238564"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">//1.查询优惠卷</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">//2.查询秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">//判断尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3.查询秒杀是否结束</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">//判断已经结束</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.查询库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//库存不够</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5. 扣减库存</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          <span class="comment">//库存不够</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.创建订单</span></span><br><span class="line">      <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">      <span class="comment">//6.1 订单ID</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">      voucherOrder.setId(orderID);</span><br><span class="line">      <span class="comment">//6.2 用户ID</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">      voucherOrder.setVoucherId(voucherId);</span><br><span class="line">      <span class="comment">//7.返回订单ID</span></span><br><span class="line">      save(voucherOrder);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/image-20250609154457808-45099c.png" alt="image-20250609154457808"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653368562591-34b462.png" alt="1653368562591"></p><h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a><strong>悲观锁：</strong></h4><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p>简单理解就是单线程串行执行</p><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a><strong>乐观锁：</strong></h4><p>  乐观锁——版本号控制：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过</p><p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">var5 是操作前读取的内存值，<span class="keyword">while</span>中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</span><br><span class="line">其中<span class="keyword">do</span> <span class="keyword">while</span> 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><h4 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在进行库存修改的时候，进行双重判断即可</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure><h3 id="优惠券秒杀-一人一单"><a href="#优惠券秒杀-一人一单" class="headerlink" title="优惠券秒杀-一人一单"></a>优惠券秒杀-一人一单</h3><p>修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/image-20250609164850992-bf453a.png" alt="image-20250609164850992"></p><h4 id="修改方案——判断是否存在"><a href="#修改方案——判断是否存在" class="headerlink" title="修改方案——判断是否存在"></a>修改方案——判断是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询优惠卷</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.查询秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//判断尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.查询秒杀是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//判断已经结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.查询库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//库存不够</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 一人一单逻辑</span></span><br><span class="line">        <span class="comment">//5.1 获取用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//5.2 判断是否已经购买过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.3.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">//库存不够</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//7.1 订单ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderID);</span><br><span class="line">        <span class="comment">//7.2 用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">//8.返回订单ID</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</span><br></pre></td></tr></table></figure><h4 id="优化——悲观锁"><a href="#优化——悲观锁" class="headerlink" title="优化——悲观锁"></a>优化——悲观锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将数据库操作判断函数，提取出来，使用悲观锁来进行控制</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//5. 一人一单逻辑</span></span><br><span class="line">        <span class="comment">//5.1 获取用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//5.2 判断是否已经购买过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.3.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">//库存不够</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//7.1 订单ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderID);</span><br><span class="line">        <span class="comment">//7.2 用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">//8.返回订单ID</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这样添加锁，锁的粒度太粗了，在使用锁过程中，控制锁粒度是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</span><br><span class="line"></span><br><span class="line">intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</span><br></pre></td></tr></table></figure><h4 id="继续优化，精确锁控制"><a href="#继续优化，精确锁控制" class="headerlink" title="继续优化，精确锁控制"></a>继续优化，精确锁控制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上述实现把锁放在函数上，即这个函数只能运行一次，所以我们需要锁的是用户ID，每一个用户只能操作一次</span><br><span class="line"> <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//5. 一人一单逻辑</span></span><br><span class="line">        <span class="comment">//5.1 获取用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.2 判断是否已经购买过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="comment">// 5.3.判断是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已经购买过了</span></span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">//库存不够</span></span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7.创建订单</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            <span class="comment">//7.1 订单ID</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            voucherOrder.setId(orderID);</span><br><span class="line">            <span class="comment">//7.2 用户ID</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">            voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            <span class="comment">//8.返回订单ID</span></span><br><span class="line">            save(voucherOrder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：</span><br></pre></td></tr></table></figure><h4 id="继续优化——事务处理放置位置"><a href="#继续优化——事务处理放置位置" class="headerlink" title="继续优化——事务处理放置位置"></a>继续优化——事务处理放置位置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">   <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">       <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">但是以上做法依然有问题，因为你调用的方法，其实是<span class="built_in">this</span>.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意要导入依赖和注册扫描</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        </span><br><span class="line">        启动类加入</span><br><span class="line">@EnableAspectJAutoProxy(exposeProxy = true)</span><br></pre></td></tr></table></figure><h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653373887844-8d08bf.png" alt="1653373887844"></p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653373908620-bdc646.png" alt="1653373908620"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653374044740-98c68d.png" alt="1653374044740"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/03/image-20250703155848615-ad8cae.png" alt="image-20250703155848615"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</span><br><span class="line">互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</span><br><span class="line">高可用：程序不易崩溃，时时刻刻都保证较高的可用性</span><br><span class="line">高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</span><br><span class="line">安全性：安全也是程序中必不可少的一环</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/03/image-20250703160006909-6ae8e2.png" alt="image-20250703160006909"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常见的分布式锁有三种</span><br><span class="line"></span><br><span class="line">Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</span><br><span class="line">Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</span><br><span class="line">Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/03/image-20250703160457899-a25718.png" alt="image-20250703160457899"></p><h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li><p>互斥：确保只能有一个线程获取锁</p></li><li><p>非阻塞：尝试一次，成功返回true，失败返回false</p></li><li><pre><code>SET lock thread1 NX EX 10NX是设置互斥，EX是设置超时时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">* 释放锁：</span><br><span class="line"></span><br><span class="line">  * 手动释放</span><br><span class="line">  * 超时释放：获取锁时添加一个超时时间、</span><br><span class="line"></span><br><span class="line">### 实现分布式锁版本一</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Ilock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description:</span><br><span class="line">     * @author: curry</span><br><span class="line">     * @date: 2025/7/3 16:13</span><br><span class="line">     * @param: timeoutSec 锁持有的超时时间，过期后自动释放</span><br><span class="line">     * @return: true表示获取锁成功，false表示获取锁失败</span><br><span class="line">     **/</span><br><span class="line">    boolean tryLock(long timeoutSec);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description:</span><br><span class="line">     * @author: curry</span><br><span class="line">     * @date: 2025/7/3 16:14</span><br><span class="line">     * @param:</span><br><span class="line">     * @return: 释放锁</span><br><span class="line">     **/</span><br><span class="line">    void unLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Ilock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程标识</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(bool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程标识</span></span><br><span class="line"><span class="comment">         * 因为存在一种情况，当这个线程运行完成要释放，但是过期了，现在锁是另一个线程的，就有可能把别的线程的锁误删，所以最好进行对比</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="keyword">if</span> (s.equals(id + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/04/image-20250704180325152-ffbc48.png" alt="image-20250704180325152"></p><h3 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）</span><br><span class="line">在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</span><br><span class="line"></span><br><span class="line">* 如果一致则释放锁</span><br><span class="line">* 如果不一致则不释放锁</span><br><span class="line"></span><br><span class="line">核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 获取线程标识</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ID_PREFIX+ Thread.currentThread().getId();</span><br><span class="line">     <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id , timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">     <span class="keyword">return</span> BooleanUtil.isTrue(bool);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程标识</span></span><br><span class="line"><span class="comment">       * 因为存在一种情况，当这个线程运行完成要释放，但是过期了，现在锁是另一个线程的，就有可能把别的线程的锁误删，所以最好进行对比</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程标识</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ID_PREFIX+ Thread.currentThread().getId();</span><br><span class="line">      <span class="comment">// 获取锁中的标示</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">      <span class="keyword">if</span> (Objects.equals(s, id )) &#123;</span><br><span class="line">          stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程<span class="number">2</span>进来，但是线程<span class="number">1</span>他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程<span class="number">1</span>的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705160737136-84befd.png" alt="image-20250705160737136"></p><h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法可以参考网站：https://www.runoob.com/lua/lua-tutorial.html</span><br></pre></td></tr></table></figure><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...) number(Key参数个数) key参数  其他参数</span><br><span class="line"></span><br><span class="line">基本写法</span><br><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>], ...) <span class="number">1</span> key  value</span><br><span class="line">key类型参数会存放再KEYS数组当中，其他参数存在ARGV数组里面，后面数字表示有几个key类型参数，然后后面跟几个key类型参数，之后跟着ARGV类型参数</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705161124070-48d7c2.png" alt="image-20250705161124070"></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">所以我们释放锁的操作可以简化为下面的Lua语言</span><br><span class="line">释放锁的业务流程是这样的</span><br><span class="line"><span class="number">1</span>、获取锁中的线程标示</span><br><span class="line"><span class="number">2</span>、判断是否与指定的标示（当前线程标示）一致</span><br><span class="line"><span class="number">3</span>、如果一致则释放锁（删除）</span><br><span class="line"><span class="number">4</span>、如果不一致则什么都不做</span><br><span class="line"></span><br><span class="line"><span class="comment">--锁的Key</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--当前线程表示</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>] </span><br><span class="line"><span class="comment">--获取锁中的线程表示</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&quot;get&quot;</span>, key)</span><br><span class="line"><span class="comment">--比较线程表示和锁标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> id == threadId <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--如果一致，删除锁</span></span><br><span class="line">    redis.call(<span class="string">&quot;del&quot;</span>, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">--如果不一致，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化脚本,这里&lt;long&gt;表示返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; unlock_script;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unlock_script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        unlock_script.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        unlock_script.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用lua脚本</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stringRedisTemplate.execute(unlock_script, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="改善问题"><a href="#改善问题" class="headerlink" title="改善问题"></a>改善问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</span><br></pre></td></tr></table></figure><h2 id="分布式锁-redission"><a href="#分布式锁-redission" class="headerlink" title="分布式锁-redission"></a>分布式锁-redission</h2><h3 id="上述实现存在的问题"><a href="#上述实现存在的问题" class="headerlink" title="上述实现存在的问题"></a>上述实现存在的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于setnx实现的分布式锁存在下面的问题：</span><br><span class="line">**重入问题**：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用<span class="keyword">synchronized</span>修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的<span class="keyword">synchronized</span>和Lock锁都是可重入的。</span><br><span class="line">**不可重试**：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</span><br><span class="line">**超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</span><br><span class="line">**主从一致性：** 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705164401547-9ee04b.png" alt="image-20250705164401547"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">Redission提供了分布式锁的多种多样的功能</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705164421596-3894de.png" alt="image-20250705164421596"></p><h3 id="分布式锁-Redission快速入门"><a href="#分布式锁-Redission快速入门" class="headerlink" title="分布式锁-Redission快速入门"></a>分布式锁-Redission快速入门</h3><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式锁-redission可重入锁原理"><a href="#分布式锁-redission可重入锁原理" class="headerlink" title="分布式锁-redission可重入锁原理"></a>分布式锁-redission可重入锁原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redission可重入锁的机制就如下面流程图所示，将数据存储为Hset格式的，当不存在锁，对锁进行创建，并且设置时间以及次数，当锁存在后，就对锁进入次数进行修改</span><br><span class="line">释放的时候，对锁的次数进行减少，直到减少到<span class="number">0</span>即可</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="keyword">private</span> RLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        lock = redissonClient.getLock(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RedissonTest1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁失败-------------1 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁成功-----------------1&quot;</span>);</span><br><span class="line">            RedissonTest2();</span><br><span class="line">            System.out.println(<span class="string">&quot; 执行业务1-----------------1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 释放业务1----------------1&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RedissonTest2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁失败-------------2 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁成功-----------------2&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 执行业务2-----------------2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 释放业务2-----------------2&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706162007786-99cd97.png" alt="image-20250706162007786"></p><h3 id="分布式锁-redission锁重试和WatchDog机制"><a href="#分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-redission锁重试和WatchDog机制"></a>分布式锁-redission锁重试和WatchDog机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大致流程如下图所示，看门狗机制实现</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706165500487-13f333.png" alt="image-20250706165500487"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redisson分布式锁原理：</span><br><span class="line">可重入：利用hash结构记录线程id和重入次数</span><br><span class="line">可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</span><br><span class="line">超时续约：利用watchDog，每隔一段时间（releaseTime/<span class="number">3</span>），重置超时时间</span><br></pre></td></tr></table></figure><h3 id="分布式锁-redission锁的MutiLock原理"><a href="#分布式锁-redission锁的MutiLock原理" class="headerlink" title="分布式锁-redission锁的MutiLock原理"></a>分布式锁-redission锁的MutiLock原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主节点处理所有的写操作，从节点进行读操作，需要进行主从同步</span><br><span class="line"></span><br><span class="line">独立的锁联合起来成一个联合的锁，多个独立的锁，</span><br></pre></td></tr></table></figure><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706171902694-35c751.png" alt="image-20250706171902694"></p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706171916933-a51602.png" alt="image-20250706171916933"></p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706171950552-0924f6.png" alt="image-20250706171950552"></p><h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><p>没有优化前进行测试，放入1000个线程进行强200的库存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">具体操作，写入一个脚本，让其获取<span class="number">1000</span>个用户token,进行假登录，完事后用jmeter进行测试，测试结果如下：</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">TestMultiLogin</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;User&gt; userList = userService.lambdaQuery().last(<span class="string">&quot;limit 1000&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);<span class="comment">//设置带不带下划线，这里true设置为不带下划线</span></span><br><span class="line">            <span class="comment">//7.2 将user对象转化为HashMap进行存储</span></span><br><span class="line">            <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">            Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                    CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">            <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">            <span class="comment">//7.3 存储</span></span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(tokenKey, map);</span><br><span class="line">            <span class="comment">//设置token有效期</span></span><br><span class="line">            stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.keys(LOGIN_USER_KEY + <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Cleanup</span> <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;VVtokens.txt&quot;</span>);</span><br><span class="line">        <span class="meta">@Cleanup</span> <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fileWriter);</span><br><span class="line">        <span class="keyword">assert</span> keys != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> key.substring(LOGIN_USER_KEY.length());</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> token + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            bufferedWriter.write(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707001304010-f8083e.png" alt="image-20250707001304010"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以发现有点慢，所以我们希望对这部分内容进行优化，</span><br><span class="line">优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</span><br><span class="line">第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</span><br><span class="line">第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707001523540-15b127.png" alt="image-20250707001523540"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于<span class="number">0</span>即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回<span class="number">0</span>，整个过程需要保证是原子性的，我们可以使用lua来操作</span><br><span class="line"></span><br><span class="line">当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是<span class="number">0</span> ，如果是<span class="number">0</span>，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707001548952-66e8d5.png" alt="image-20250707001548952"></p><h3 id="秒杀优化-Redis完成秒杀资格判断"><a href="#秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="秒杀优化-Redis完成秒杀资格判断"></a>秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li><li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707151729264-36f9ad.png" alt="image-20250707151729264"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新增优惠卷的时候，加入到Redis当中</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存优惠券</span></span><br><span class="line">        save(voucher);</span><br><span class="line">        <span class="comment">// 保存秒杀信息</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">        seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">        seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">        seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">        seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">        seckillVoucherService.save(seckillVoucher);</span><br><span class="line">        <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整lua脚本</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">--- Generated by EmmyLua(https://github.com/EmmyLua)</span></span><br><span class="line"><span class="comment">--- Created by CurryJay.</span></span><br><span class="line"><span class="comment">--- DateTime: 2025/7/7 15:22</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---1.参数列表</span></span><br><span class="line"><span class="comment">---1.1 优惠卷ID</span></span><br><span class="line"><span class="keyword">local</span> voucherID = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">---1.2用户ID</span></span><br><span class="line"><span class="keyword">local</span> userID = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">---1.3 订单ID</span></span><br><span class="line"><span class="keyword">local</span> orderID = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>执行业务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userID.toString(), String.valueOf(orderID)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(flag == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="秒杀优化-基于阻塞队列实现秒杀优化"><a href="#秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="秒杀优化-基于阻塞队列实现秒杀优化"></a>秒杀优化-基于阻塞队列实现秒杀优化</h3><p>实现意义不大，没实现，因为不会使用这种方案，一般会使用消息队列来进行实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//异步处理线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 2.创建锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">            proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userID.toString(), String.valueOf(orderID)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(flag == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userID);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">        proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">秒杀业务的优化思路是什么？</span><br><span class="line"></span><br><span class="line">* 先利用Redis完成库存余量、一人一单判断，完成抢单业务</span><br><span class="line">* 再将下单业务放入阻塞队列，利用独立线程异步下单</span><br><span class="line">* 基于阻塞队列的异步秒杀存在哪些问题？</span><br><span class="line">  * 内存限制问题</span><br><span class="line">  * 数据安全问题</span><br></pre></td></tr></table></figure><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><h3 id="Redis消息队列-基于List实现消息队列"><a href="#Redis消息队列-基于List实现消息队列" class="headerlink" title="Redis消息队列-基于List实现消息队列"></a>Redis消息队列-基于List实现消息队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</span><br><span class="line">队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</span><br><span class="line">不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回<span class="literal">null</span>，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707162156246-503228.png" alt="image-20250707162156246"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于List的消息队列有哪些优缺点？</span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">* 利用Redis存储，不受限于JVM内存上限</span><br><span class="line">* 基于Redis的持久化机制，数据安全性有保证</span><br><span class="line">* 可以满足消息有序性</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">* 无法避免消息丢失</span><br><span class="line">* 只支持单消费者</span><br></pre></td></tr></table></figure><h3 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PubSub（发布订阅）是Redis2<span class="number">.0</span>版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</span><br><span class="line"></span><br><span class="line"> SUBSCRIBE channel [channel] ：订阅一个或多个频道</span><br><span class="line"> PUBLISH channel msg ：向一个频道发送消息</span><br><span class="line"> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707162945884-9c92b1.png" alt="image-20250707162945884"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于PubSub的消息队列有哪些优缺点？</span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">* 采用发布订阅模型，支持多生产、多消费</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">* 不支持数据持久化</span><br><span class="line">* 无法避免消息丢失</span><br><span class="line">* 消息堆积有上限，超出时数据丢失</span><br></pre></td></tr></table></figure><h3 id="Redis消息队列-基于Stream的消息队列"><a href="#Redis消息队列-基于Stream的消息队列" class="headerlink" title="Redis消息队列-基于Stream的消息队列"></a>Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577301737-111b25.png" alt="1653577301737"></p><p>例如：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577349691-ca71cf.png" alt="1653577349691"></p><p>读取消息的方式之一：XREAD</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577445413-b465f4.png" alt="1653577445413"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577643629-10e227.png" alt="1653577643629"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577659166-6ce04d-3f67c2.png" alt="1653577659166"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577689129-82a0ea.png" alt="1653577689129"></p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="Redis消息队列-基于Stream的消息队列-消费者组"><a href="#Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="Redis消息队列-基于Stream的消息队列-消费者组"></a>Redis消息队列-基于Stream的消息队列-消费者组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707181302059-db3605.png" alt="image-20250707181302059"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建消费者组：XGROUP CREATE key groupName ID [MKSTREAM]</span><br><span class="line">    key：队列名称</span><br><span class="line">groupName：消费者组名称</span><br><span class="line">ID：起始ID标示，$代表队列中最后一个消息，<span class="number">0</span>则代表队列中第一个消息</span><br><span class="line">MKSTREAM：队列不存在时自动创建队列</span><br></pre></td></tr></table></figure><p>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br><span class="line">* group：消费组名称</span><br><span class="line">* consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</span><br><span class="line">* count：本次查询的最大数量</span><br><span class="line">* BLOCK milliseconds：当没有消息时最长等待时间</span><br><span class="line">* NOACK：无需手动ACK，获取到消息后自动确认</span><br><span class="line">* STREAMS key：指定队列名称</span><br><span class="line">* ID：获取消息的起始ID：</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&gt;&quot;</span>：从下一个未消费的消息开始</span><br><span class="line">其它：根据指定id从pending-list中获取已消费但未确认的消息，例如<span class="number">0</span>，是从pending-list中的第一个消息开始</span><br></pre></td></tr></table></figure><p>处理的基本思路<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707181502028-20b3f7.png" alt="image-20250707181502028"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STREAM类型消息队列的XREADGROUP命令特点：</span><br><span class="line"></span><br><span class="line">* 消息可回溯</span><br><span class="line">* 可以多消费者争抢消息，加快消费速度</span><br><span class="line">* 可以阻塞读取</span><br><span class="line">* 没有消息漏读的风险</span><br><span class="line">* 有消息确认机制，保证消息至少被消费一次</span><br></pre></td></tr></table></figure><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707181546388-c13535.png" alt="image-20250707181546388"></p><h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：</span><br><span class="line"></span><br><span class="line">* 创建一个Stream类型的消息队列，名为stream.orders</span><br><span class="line">* 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</span><br><span class="line">* 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">首先创建消息队列：XGROUP CREATE stream.orders g1 <span class="number">0</span> MKSTREAM</span><br><span class="line"><span class="comment">-- 3.6 发送给Redis消息队列,XADD stream.order</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>,<span class="string">&#x27;stream.orders&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;userID&#x27;</span>,userID,<span class="string">&#x27;voucherID&#x27;</span>,voucherID,<span class="string">&#x27;orderID&#x27;</span>,id)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现消息队列读取，以及确认重试操作  </span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</span></span><br><span class="line"></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 2.判断消息获取是否成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 2.1 如果获取失败，说明没有消息，继续下一次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.1 解析消息中订单信息String-消息ID,返回的键值对形式 Object -&gt;key, Object -&gt;vlaue</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; map = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 4. 如果获取成功，可以下单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">// 5. ACK 确认 SACK</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(</span><br><span class="line">                            <span class="string">&quot;stream.orders&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId()</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line"><span class="comment">//                    break;</span></span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取Pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 2.判断消息获取是否成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 2.1 如果获取失败，说明pending-list没有消息，结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 3.1 解析消息中订单信息String-消息ID,返回的键值对形式 Object -&gt;key, Object -&gt;vlaue</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; map = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 4. 如果获取成功，可以下单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">// 5. ACK 确认 SACK</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(</span><br><span class="line">                            <span class="string">&quot;stream.orders&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId()</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理pending-list订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="达人探店-发布探店笔记"><a href="#达人探店-发布探店笔记" class="headerlink" title="达人探店-发布探店笔记"></a>达人探店-发布探店笔记</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单来说就调用人写好的接口，没啥好说的</span><br><span class="line"></span><br><span class="line">探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：</span><br><span class="line">tb_blog：探店笔记表，包含笔记中的标题、文字、图片等</span><br><span class="line">tb_blog_comments：其他用户对探店笔记的评价</span><br></pre></td></tr></table></figure><h3 id="达人探店-查看探店笔记"><a href="#达人探店-查看探店笔记" class="headerlink" title="达人探店-查看探店笔记"></a>达人探店-查看探店笔记</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其实这部分内容也没用到Redis，简单提一嘴，就使用Service方法实现对应接口，然后返回数据即可，</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询blog</span></span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">        blog.setName(user.getNickName());</span><br><span class="line">        blog.setIcon(user.getIcon());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="达人探店-点赞功能"><a href="#达人探店-点赞功能" class="headerlink" title="达人探店-点赞功能"></a>达人探店-点赞功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将点赞数据以Set集合的形式保存到Redis当中，点赞的时候去Redis中去进行查询判断即可</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">完善点赞功能</span><br><span class="line">需求：</span><br><span class="line">* 同一个用户只能点赞一次，再次点击则取消点赞</span><br><span class="line">* 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</span><br><span class="line">实现步骤：</span><br><span class="line">* 给Blog类中添加一个isLike字段，标示是否被当前用户点赞</span><br><span class="line">* 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+<span class="number">1</span>，已点赞过则点赞数-<span class="number">1</span></span><br><span class="line">* 修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</span><br><span class="line">* 修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">//1. 获取登录用户</span></span><br><span class="line">       <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">       <span class="comment">//2. 判断当前登录是否已经点赞</span></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">       <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">       <span class="keyword">if</span> (BooleanUtil.isFalse(bool)) &#123;</span><br><span class="line">           <span class="comment">//3.1 数据库点赞+1</span></span><br><span class="line">           <span class="comment">//3.2 保存用户到Redis的Set集合</span></span><br><span class="line">           <span class="comment">// 修改点赞数量</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//4 如果已经点赞</span></span><br><span class="line">           <span class="comment">//4.1 数据库点赞-1</span></span><br><span class="line">           <span class="comment">//4.2 把用户从redis的集合删掉</span></span><br><span class="line">           <span class="comment">// 修改点赞数量</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="达人探店-点赞排行榜"><a href="#达人探店-点赞排行榜" class="headerlink" title="达人探店-点赞排行榜"></a>达人探店-点赞排行榜</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</span><br><span class="line"></span><br><span class="line">之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708162551356-724505.png" alt="image-20250708162551356"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改代码，查询存不存在用score</span><br><span class="line"> <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">        <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.1 数据库点赞+1</span></span><br><span class="line">            <span class="comment">//3.2 保存用户到Redis的Set集合 zadd key value score</span></span><br><span class="line">            <span class="comment">// 修改点赞数量</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(BLOG_LIKED_KEY + id, user.getId().toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4 如果已经点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞-1</span></span><br><span class="line">            <span class="comment">//4.2 把用户从redis的集合删掉</span></span><br><span class="line">            <span class="comment">// 修改点赞数量</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>查询出来进行排序返回用户顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1. 查询top的点赞用户 Zrange key 0 4</span></span><br><span class="line">       Set&lt;String&gt; range = stringRedisTemplate.opsForZSet().range(BLOG_LIKED_KEY + id, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">       <span class="keyword">if</span> (range == <span class="literal">null</span> || range.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2. 解析出来用户ID</span></span><br><span class="line">       List&lt;Long&gt; ids = range.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">       <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       <span class="comment">//3. 根据用户ID查询用户 由于默认查出来是相反的顺序，所以需要这样处理是的顺序成正序</span></span><br><span class="line">       List&lt;User&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;IRDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">       <span class="comment">//4. 返回信息</span></span><br><span class="line">       List&lt;UserDTO&gt; collect = users.stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">       <span class="keyword">return</span> Result.ok(collect);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="好友关注-关注和取消关注"><a href="#好友关注-关注和取消关注" class="headerlink" title="好友关注-关注和取消关注"></a>好友关注-关注和取消关注</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较简单，就是操作一张表，关注的时候新增表，取关的时候删除表，查询是否关注的时候查询是否存在这个数据</span><br><span class="line"></span><br><span class="line">需求：基于该表数据结构，实现两个接口：</span><br><span class="line"></span><br><span class="line">* 关注和取关接口</span><br><span class="line">* 判断是否关注的接口</span><br><span class="line"></span><br><span class="line">关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708164504016-50a278.png" alt="image-20250708164504016"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserID, Boolean isFollow)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">//1. 判断到底是关注还是取关</span></span><br><span class="line">       <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">           <span class="comment">//2. 关注,新增数据</span></span><br><span class="line">           <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">           follow.setUserId(userId);</span><br><span class="line">           follow.setFollowUserId(followUserID);</span><br><span class="line">           save(follow);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//3. 取关，删除</span></span><br><span class="line">           remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserID));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserID)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserID).count();</span><br><span class="line">       <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="好友关注-共同关注"><a href="#好友关注-共同关注" class="headerlink" title="好友关注-共同关注"></a>好友关注-共同关注</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">核心内容就是使用Redis的交集功能，获取到两个集合的交集即可，获取到交集</span><br><span class="line"></span><br><span class="line">首先改造关注的时候需要把关注内容加入到Redis当中</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserID, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//1. 判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">//2. 关注,新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserID);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(follow);</span><br><span class="line">            <span class="keyword">if</span> (save) &#123;</span><br><span class="line">                <span class="comment">//把关注用户的ID，放入Redis的set集合当中，sadd userID foll</span></span><br><span class="line">                stringRedisTemplate.opsForSet().add(FOLLOWS_KEY + userId, followUserID.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//3. 取关，删除</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserID));</span><br><span class="line">            <span class="comment">//移除用户</span></span><br><span class="line">            <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().remove(FOLLOWS_KEY + userId, followUserID.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体计算交集的代码，通过Set提供的交集代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">commonFollow</span><span class="params">(Long followUserID)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//求集合</span></span><br><span class="line">        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(FOLLOWS_KEY + id, FOLLOWS_KEY + followUserID);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析ID集合</span></span><br><span class="line">        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="好友关注-Feed流实现方案"><a href="#好友关注-Feed流实现方案" class="headerlink" title="好友关注-Feed流实现方案"></a>好友关注-Feed流实现方案</h3><p> 当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708181944697-092ab0.png" alt="image-20250708181944697"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708181955069-297f57.png" alt="image-20250708181955069"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feed流产品有两种常见模式：</span><br><span class="line">Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</span><br><span class="line">* 优点：信息全面，不会有缺失。并且实现也相对简单</span><br><span class="line">* 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</span><br><span class="line"></span><br><span class="line">智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</span><br><span class="line">* 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</span><br><span class="line">* 缺点：如果算法不精准，可能起到反作用</span><br></pre></td></tr></table></figure><p>因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><h4 id="拉模式：也叫做读扩散"><a href="#拉模式：也叫做读扩散" class="headerlink" title="拉模式：也叫做读扩散"></a><strong>拉模式</strong>：也叫做读扩散</h4><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182036738-f83aa8.png" alt="image-20250708182036738"></p><h4 id="推模式：也叫做写扩散。"><a href="#推模式：也叫做写扩散。" class="headerlink" title="推模式：也叫做写扩散。"></a><strong>推模式</strong>：也叫做写扩散。</h4><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182050926-e24fb4.png" alt="image-20250708182050926"></p><h4 id="推拉结合模式："><a href="#推拉结合模式：" class="headerlink" title="推拉结合模式："></a><strong>推拉结合模式</strong>：</h4><p>也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182113107-d2cb3e.png" alt="image-20250708182113107"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182129510-7cf4a9.png" alt="image-20250708182129510"></p><h3 id="好友关注-推送到粉丝收件箱"><a href="#好友关注-推送到粉丝收件箱" class="headerlink" title="好友关注-推送到粉丝收件箱"></a>好友关注-推送到粉丝收件箱</h3><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/12/1653813047671-9370f4.png" alt="1653813047671"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/12/1653813462834-906847.png" alt="1653813462834"></p><p>实现方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     blog.setUserId(user.getId());</span><br><span class="line">     <span class="comment">// 保存探店博文</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">     <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//查询笔记作者的所有粉丝 select * from tb_floow</span></span><br><span class="line">     List&lt;Follow&gt; list = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">     <span class="comment">// 博客发送给粉丝</span></span><br><span class="line">     <span class="keyword">for</span> (Follow follow : list) &#123;</span><br><span class="line">         <span class="comment">//获取粉丝ID</span></span><br><span class="line">         <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">         <span class="comment">//推送</span></span><br><span class="line">         stringRedisTemplate.opsForZSet().add(FEED_KEY+userId,blog.getId().toString(),System.currentTimeMillis());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 返回id</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="好友关注-实现分页查询收邮箱"><a href="#好友关注-实现分页查询收邮箱" class="headerlink" title="好友关注-实现分页查询收邮箱"></a>好友关注-实现分页查询收邮箱</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</span><br><span class="line"></span><br><span class="line">具体操作如下：</span><br><span class="line">1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</span><br><span class="line">2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</span><br><span class="line">综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</span><br><span class="line">这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回数据定义</span><br><span class="line">@Data</span><br><span class="line">public class ScrollResult &#123;</span><br><span class="line">    private List&lt;?&gt; list;</span><br><span class="line">    private Long minTime;</span><br><span class="line">    private Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">     <span class="comment">//1.收件箱所有笔记</span></span><br><span class="line">     <span class="comment">//获取当前用户信息</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//滚动分页查询</span></span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(FEED_KEY + userId, <span class="number">0</span>, max, offset, <span class="number">3</span>);</span><br><span class="line">     <span class="comment">// 非空判断</span></span><br><span class="line">     <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.ok();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//查询收件箱</span></span><br><span class="line">     <span class="comment">//2. 解析数据 blogId、minTime、offset</span></span><br><span class="line">     List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">     <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> typedTuple.getValue();</span><br><span class="line">         ids.add(Long.valueOf(id));</span><br><span class="line">         <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">         <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">             os++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 获取分数</span></span><br><span class="line">             minTime = time;</span><br><span class="line">             os = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获取根据ID查询blog</span></span><br><span class="line">     <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">     <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">     List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">     <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">         <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">         <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">         blog.setName(user.getNickName());</span><br><span class="line">         blog.setIcon(user.getIcon());</span><br><span class="line">         <span class="comment">// 3. 查询blog是否被点赞</span></span><br><span class="line">         <span class="comment">// 2. 判断当前登录是否已经点赞</span></span><br><span class="line">         <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">         blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     scrollResult.setList(blogs);</span><br><span class="line">     scrollResult.setOffset(os);</span><br><span class="line">     scrollResult.setMinTime(minTime);</span><br><span class="line">     <span class="comment">//封装返回数据</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</span><br><span class="line"></span><br><span class="line">* GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</span><br><span class="line">* GEODIST：计算指定的两个点之间的距离并返回</span><br><span class="line">* GEOHASH：将指定member的坐标转为hash字符串形式并返回</span><br><span class="line">* GEOPOS：返回指定member的坐标</span><br><span class="line">* GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</span><br><span class="line">* GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</span><br><span class="line">* GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</span><br></pre></td></tr></table></figure><h3 id="附近商户-导入店铺数据到GEO"><a href="#附近商户-导入店铺数据到GEO" class="headerlink" title="附近商户-导入店铺数据到GEO"></a>附近商户-导入店铺数据到GEO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先需要将坐标位置保存到Reids当中，按照店铺类型进行分类，存储到集合当中</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询店铺信息</span></span><br><span class="line">        List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">        <span class="comment">// 2. 把店铺分组，按照typeID分组，id一致的放到一个集合</span></span><br><span class="line">        Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">        <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取类型的id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">//3.2 获取同类型店铺的集合</span></span><br><span class="line">            List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入Redis 与下面写法效果是一样的</span></span><br><span class="line"><span class="comment">//            for (Shop shop : shops) &#123;</span></span><br><span class="line"><span class="comment">//                stringRedisTemplate.opsForGeo().add(SHOP_GEO_KEY+typeId,new Point(shop.getX(),shop.getY()),shop.getId().toString());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(shops.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">                locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 批量写</span></span><br><span class="line">            stringRedisTemplate.opsForGeo().add(SHOP_GEO_KEY + typeId, locations);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="附近商户-实现附近商户功能"><a href="#附近商户-实现附近商户功能" class="headerlink" title="附近商户-实现附近商户功能"></a>附近商户-实现附近商户功能</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</span><br><span class="line"></span><br><span class="line">第一步：导入pom</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 根据类型分页查询</span></span><br><span class="line">           Page&lt;Shop&gt; page = query()</span><br><span class="line">                   .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                   .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">           <span class="comment">// 返回数据</span></span><br><span class="line">           <span class="keyword">return</span> Result.ok(page);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2.计算分页参数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">       <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">       <span class="comment">//3. 查询redis，按照距离排序、分页‘；结果shopID .distance</span></span><br><span class="line"></span><br><span class="line">       GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(</span><br><span class="line">               SHOP_GEO_KEY + typeId,</span><br><span class="line">               GeoReference.fromCoordinate(x, y),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">               RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; content = results.getContent();</span><br><span class="line">       <span class="comment">//跳过没数据了，直接返回空集合就可以了</span></span><br><span class="line">       <span class="keyword">if</span> (content.size() &lt;= from) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(content.size());</span><br><span class="line">       Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(content.size());</span><br><span class="line">       <span class="comment">//截取从from到end</span></span><br><span class="line">       content.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">shopID</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">           ids.add(Long.valueOf(shopID));</span><br><span class="line">           <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">           distanceMap.put(shopID, distance);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       <span class="comment">// 解析id</span></span><br><span class="line">       List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">       shops.forEach(shop -&gt; &#123;</span><br><span class="line">           shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitMap 的高位和地位和正常是相反的，左边是低位，右边是高位 </span><br></pre></td></tr></table></figure><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/1653824498278-58340c.png" alt="1653824498278"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h3 id="用户签到-实现签到功能"><a href="#用户签到-实现签到功能" class="headerlink" title="用户签到-实现签到功能"></a>用户签到-实现签到功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 1 .获取当前登录的用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2. 获取日期</span></span><br><span class="line">     <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">     <span class="comment">// 3.拼接key</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userID + format;</span><br><span class="line">     <span class="comment">// 4. 今天是本月的第几天</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">     <span class="comment">// 5. 写入Redis</span></span><br><span class="line">     stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="连续签到"><a href="#连续签到" class="headerlink" title="连续签到"></a>连续签到</h3><p>这里其实有点问题，当天应该会签到上的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//1、 获取本月截至今天位置所有的签到记录</span></span><br><span class="line">      <span class="comment">// 1 .获取当前登录的用户</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">// 2. 获取日期</span></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      <span class="comment">// 3.拼接key</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userID + format;</span><br><span class="line">      <span class="comment">// 4. 今天是本月的第几天</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">      <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">      List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">              key,</span><br><span class="line">              BitFieldSubCommands.create()</span><br><span class="line">                      .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 没有任何签到结果</span></span><br><span class="line">          <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 6.循环遍历</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">          <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">              count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">          num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</span><br><span class="line">* PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</span><br><span class="line"></span><br><span class="line">通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</span><br><span class="line"></span><br><span class="line">UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</span><br><span class="line">Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：https://juejin.cn/post/6844903785744056333#heading-0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">他可以自动进行去重，加入就可以去重了</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/image-20250713205310390-fe7bd4.png" alt="image-20250713205310390"></p><h3 id="UV统计-测试百万数据的统计"><a href="#UV统计-测试百万数据的统计" class="headerlink" title="UV统计-测试百万数据的统计"></a>UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/1653838053608-9b6295.png" alt="1653838053608"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p><h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl alt m   快速给一段代码创建一个函数</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableField(exist = false)</span><br><span class="line">表示不是数据库里面的字段</span><br></pre></td></tr></table></figure><h1 id="高级用法记录一下"><a href="#高级用法记录一下" class="headerlink" title="高级用法记录一下"></a>高级用法记录一下</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用stream流 </span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 解析出来用户ID</span></span><br><span class="line">        List&lt;Long&gt; ids = range.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        <span class="comment">//3. 根据用户ID查询用户 由于默认查出来是相反的顺序，所以需要这样处理是的顺序成正序</span></span><br><span class="line">        List&lt;User&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="comment">//4. 返回信息</span></span><br><span class="line">        List&lt;UserDTO&gt; collect = users.stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.ok(collect);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/posts/43782.html"/>
      <url>/posts/43782.html</url>
      
        <content type="html"><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vue@2.6.13</span><br><span class="line">具体操作可以看nodejs文档</span><br><span class="line"></span><br><span class="line">列表模块：npm ls</span><br><span class="line"></span><br><span class="line">卸载模块：npm uninstall 模块名</span><br><span class="line"></span><br><span class="line">更新模块：npm update 模块名</span><br><span class="line"></span><br><span class="line">运行工程：npm run dev/test</span><br><span class="line"></span><br><span class="line">编译工程：npm run build</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建，构建一个IDEA（javascript项目） 并进入目录  </span><br><span class="line"></span><br><span class="line">vue init webpack </span><br></pre></td></tr></table></figure><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">使用相当于<span class="keyword">new</span>一个<span class="title class_">Vue</span>对象</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="comment">//选择一个组件和它进行绑定,产生一个绑定关系，和组件绑定起来</span></span><br><span class="line">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        <span class="comment">//数据进行绑定</span></span><br><span class="line">        <span class="attr">data</span>: &#123;    <span class="attr">title</span>: <span class="string">&#x27;VUE入门讲解&#x27;</span>,&#125;</span><br><span class="line">        &#125;）</span><br><span class="line">          </span><br><span class="line">之后可以通过胡须表达式就可以获取到数据</span><br><span class="line">   &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">可以用@click 来进行点击事件的绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、插值语法：也叫胡须表达式，</span><br><span class="line">功能：用于解析标签体内容</span><br><span class="line">写法：&#123;&#123;xxx&#125;&#125;. xxx是js表达式，且可以直接取到data中的所有属性，也可以获取到方法</span><br><span class="line"></span><br><span class="line">2、指令语法：</span><br><span class="line">功能：用于解析标签(包括：标签属性、标签体内容、绑定事件...)</span><br><span class="line">举例：v-bind:href=&quot;xxx&quot; 或 简写为 :href=&quot;xxx&quot;,xxx同样要写js表达式，且可以直接读取到data中的所有属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">el其实是将vue对象和html的对象进行了一个挂载，</span><br><span class="line">第一种方式：在创建的时候挂载：</span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="comment">//选择一个组件和它进行绑定，也叫挂载</span></span><br><span class="line">         <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,&#125;)</span><br><span class="line">         </span><br><span class="line">第二种方式：在创建完成后单独申明挂载：</span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;&#125;)</span><br><span class="line">v.$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data的两种写法：</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据进行绑定,对象类型进行绑定</span></span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;el和data的两种写法&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式，组件开发必须要用函数,组件中只能使用函数式</span></span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;el和data的两种写法&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="methods的使用"><a href="#methods的使用" class="headerlink" title="methods的使用"></a>methods的使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在data平级，  首先在方法中<span class="variable language_">this</span>指的是vue实例</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>作为事件监听进行回调，事件有很多，例如点击，聚焦，键盘按下</span><br><span class="line">&lt;!--    作为事件监听的回调方法 ，如果没有参数，那么就可以不用带括号--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeTitle()&quot;</span>&gt;</span>点击修改title<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>如果方法是返回值，那么就可以用胡须表达式</span><br><span class="line">    同时如果方法是一个返回值，可以使用胡须表达式</span><br><span class="line">    &lt;!--  胡须表达式中调用，拿到返回值--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;showUser()&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>可以用构建的vue实例进行调用</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;&#125;)</span><br><span class="line">     <span class="comment">//通过vue实例进行调用</span></span><br><span class="line">    v.<span class="title function_">printInfo</span>();</span><br></pre></td></tr></table></figure><h2 id="el对象挂载"><a href="#el对象挂载" class="headerlink" title="el对象挂载"></a>el对象挂载</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">每个<span class="title class_">Vue</span>实例通过el配置挂载的标签，该标签可以通过id或者是<span class="keyword">class</span>挂载。  实例上的属性和方法只能够在当前实例挂载的标签中使用。</span><br><span class="line"></span><br><span class="line">使用构造函数创建一个vue对象：</span><br><span class="line">这个对象作用与哪一个html标签，是通过el属性来挂载的，常用的有id和<span class="keyword">class</span>挂载方式：</span><br><span class="line">id挂载:<span class="attr">el</span>:<span class="string">&quot;#id&quot;</span></span><br><span class="line"><span class="keyword">class</span>挂载：<span class="attr">el</span>:<span class="string">&quot;.class&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//id挂载方式：</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">   <span class="comment">//选择一个组件和它进行绑定，也叫挂载</span></span><br><span class="line">        <span class="comment">//推荐使用id 一般创建一个vue实例</span></span><br><span class="line">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">data : &#123;</span><br><span class="line">message : <span class="string">&quot;我是id挂载方式&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//class挂载方式：</span></span><br><span class="line"><span class="comment">//使用类挂载只能挂载最早的一个类，其他类名重复不能挂载多个，vue只能挂载一个元素</span></span><br><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">el : <span class="string">&quot;.vueClz&quot;</span>,</span><br><span class="line">data : &#123;</span><br><span class="line">message : <span class="string">&quot;我是class挂载方式&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="data数据获取"><a href="#data数据获取" class="headerlink" title="data数据获取"></a>data数据获取</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue实例的数据保存在配置属性data中, data自身也是一个对象.</span></span><br><span class="line"><span class="comment">// 通过Vue实例直接访问data对象中的数据,及时同步的页面上</span></span><br><span class="line"></span><br><span class="line"> &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;user&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;arr&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;arr[0]&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;userList&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;userList[0].id&#125;&#125;--&#123;&#123;userList[0].name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    一般都可以通过胡须表达式获取到</span><br></pre></td></tr></table></figure><h2 id="VUE表达式"><a href="#VUE表达式" class="headerlink" title="VUE表达式"></a>VUE表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">VueJS</span>表达式写在双大括号内：&#123;&#123; expression &#125;&#125;。</span><br><span class="line"></span><br><span class="line"> <span class="title class_">VueJS</span>表达式把数据绑定到 <span class="variable constant_">HTML</span>。</span><br><span class="line"></span><br><span class="line"> <span class="title class_">VueJS</span>将在表达式书写的位置<span class="string">&quot;输出&quot;</span>数据。</span><br><span class="line"></span><br><span class="line"><span class="title class_">VueJS</span>表达式 很像 <span class="title class_">JavaScript</span> 表达式：它们可以包含文字、运算符和变量。</span><br></pre></td></tr></table></figure><h3 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--    胡须表达式其实就是编写js表达式--&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;5 + 5&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;&quot;hello word&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;&quot;5&quot; + &quot;5&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;&quot;5&quot; - &quot;5&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;&quot;5&quot; * &quot;5&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;&quot;5&quot; / &quot;5&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">   除了算术运算符，还可以写逻辑运算符，关系/比较运算符等</span><br></pre></td></tr></table></figure><h3 id="三目操作符"><a href="#三目操作符" class="headerlink" title="三目操作符"></a>三目操作符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;中的表达式可以使用data中数据</span><br><span class="line">在&#123;&#123;&#125;&#125;中的表达式可以使用三元运算符,但是不能够使用其他语句</span><br><span class="line">&lt;!--    三目操作符--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>三目运算<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;user.gender === 0 ? &quot;男&quot; : &quot;女&quot;&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">直接使用字符串字面值作为字符串对象</span><br><span class="line"> 使用data中的字符串对象</span><br><span class="line">    &lt;h2&gt;&#123;&#123;<span class="string">&quot;hello word&quot;</span>&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;&quot;hello word&quot;.length&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;&quot;hello word&quot;.toUpperCase()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;&quot;hello word&quot;.substring(0, 5)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;&quot;hello word&quot;.charAt(1)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;&quot;hello word&quot;.replace(&#x27;o&#x27;, &#x27;m&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在表达式中可以使用data中定义的对象的各种用法.像使用js对象中的方法和属性一样</span><br><span class="line">&lt;!--对象操作--&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123;user&#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user)&#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123;user.<span class="title function_">toString</span>()&#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123;user.<span class="property">name</span>&#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123;user.<span class="property">age</span>&#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123;user.<span class="title function_">getAge</span>()&#125;&#125;&lt;br/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在表达式中可以使用<span class="title class_">JavaScript</span>数组中的任何语法来操作数组</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;数组&lt;/h1&gt;</span><br><span class="line">  &#123;&#123;user.<span class="property">arr</span>.<span class="property">length</span>&#125;&#125;&lt;br/&gt;</span><br><span class="line">  &#123;&#123;user.<span class="property">arr</span>.<span class="title function_">join</span>(<span class="string">&quot;**&quot;</span>)&#125;&#125;&lt;br/&gt;</span><br><span class="line">  &#123;&#123;user.<span class="property">arr</span>.<span class="title function_">toString</span>()&#125;&#125;&lt;br/&gt;</span><br></pre></td></tr></table></figure><h2 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-text=“表达式”  设置标签中的文本</span><br><span class="line">v-html=“表达式”  设置标签中的html</span><br><span class="line">v-bind=“表达式”   绑定值</span><br><span class="line">v-show=<span class="string">&quot;&quot;</span> 是否显示</span><br><span class="line">v-on=“表达式”   注册事件</span><br><span class="line">v-<span class="keyword">if</span>(<span class="keyword">else</span> <span class="keyword">else</span> <span class="keyword">if</span>)=“表达式”   判断条件</span><br><span class="line">v-<span class="keyword">for</span>=“表达式”  循环</span><br><span class="line">v-model=“表达式” 数据双向绑定</span><br></pre></td></tr></table></figure><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">&lt;标签名 v-text=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签名&gt;</span><br><span class="line">通过data中的数据更新标签标签中的textContent属性的值.(标签中的文本内容)</span><br><span class="line"></span><br><span class="line">注意事项:</span><br><span class="line"></span><br><span class="line">如果值是html的值,会作为普通的文本使用。</span><br><span class="line">标签中的属性值必须是data中的一个属性</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">message</span>: <span class="string">&quot;&lt;h1&gt;这是一个Span!&lt;/h1&gt;&quot;</span>,</span><br><span class="line"><span class="attr">user</span>: &#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&quot;lw&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签名 v-html=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签名&gt;</span><br><span class="line">通过data中的数据更新标签标签中的innerHTML属性的值.(标签中的<span class="variable constant_">HTML</span>内容)</span><br><span class="line">如果值是html的值,不会作为普通的文本使用,要识别html标签。</span><br><span class="line">&#123;&#123;表达式&#125;&#125; 可以插入的标签的内容中</span><br><span class="line">v-text和v-html更改标签中的所有内容</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">message</span>: <span class="string">&quot;&lt;h1&gt;这是HTMl代码&lt;/h1&gt;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">为一个标签属性绑定一个值</span><br><span class="line">&lt;标签 v-<span class="attr">bind</span>:标签属性名字=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line">简写形式:</span><br><span class="line">&lt;标签 :标签属性名字=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line">为一个标签绑定一个对象作为该标签的多个属性</span><br><span class="line">&lt;标签 v-bind=<span class="string">&quot;对象&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line">将一个对象键和值作为标签的属性的名字和值时,  在v-bind后不需要指定属性的名字</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgsrc&quot;</span> <span class="attr">v-bind:title</span> = <span class="string">&quot;title&quot;</span>/&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgsrc&quot;</span> <span class="attr">:title</span> = <span class="string">&quot;title&quot;</span>/&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind</span>=<span class="string">&quot;props&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">imgsrc</span>: <span class="string">&quot;./img/1.jpg&quot;</span>,</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;二哈!&quot;</span>,</span><br><span class="line">props :&#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;username&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="v-show指令"><a href="#v-show指令" class="headerlink" title="v-show指令"></a>v-show指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  &lt;标签名 v-show=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签名&gt;</span><br><span class="line">  根据表达式之真假值，切换元素的 display <span class="variable constant_">CSS</span> 属性。当条件变化时该指令触发过渡效果。</span><br><span class="line">  当v-show的值为假时,  会在标签的css中添加 <span class="attr">display</span>: none :</span><br><span class="line"></span><br><span class="line">当表达式（ 可以使用一个变量或者一个判断）中的值是<span class="literal">false</span>时, 该标签仅仅是被隐藏了,而没有被从页面上删除</span><br><span class="line">    &lt;h1 v-show=<span class="string">&quot;false&quot;</span>&gt;到底显示不显示&lt;/h1&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;number %2 === 0&quot;</span>&gt;</span> 偶数<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="v-on指令"><a href="#v-on指令" class="headerlink" title="v-on指令"></a>v-on指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签 v-<span class="attr">on</span>:事件句柄=<span class="string">&quot;表达式或者事件处理函数&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line">简写方式：</span><br><span class="line">&lt;标签 @事件句柄=<span class="string">&quot;表达式或者事件处理函数&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line">&lt;!--  focus 聚焦  blus 失焦  chang 改变事件    --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-if指令"><a href="#v-if指令" class="headerlink" title="v-if指令"></a>v-if指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签名 v-<span class="keyword">if</span>=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签名&gt;</span><br><span class="line"> 根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建</span><br><span class="line">当表达式中的值是<span class="literal">false</span>时, 是从页面上删除.</span><br><span class="line"></span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">&quot;number %  3== 0&quot;</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">&quot;number %  3== 1&quot;</span>&gt;</span>python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">&quot;number %  3== 2&quot;</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签 v-<span class="keyword">for</span>=<span class="string">&quot;元素 in 数据源&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line"> 数据源:  数组,</span><br><span class="line">  元素:  数组中的一个元素,</span><br><span class="line"></span><br><span class="line"> 数据源:  对象</span><br><span class="line">  元素:  对象中的一个属性名</span><br><span class="line"></span><br><span class="line">&lt;标签 v-<span class="keyword">for</span>=<span class="string">&quot;(元素,索引|键) in 数据源&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line">  当数据源是数组时,  ()的第二个参数值索引</span><br><span class="line">  当数据源是对象时,  ()的第二个参数值键</span><br><span class="line"></span><br><span class="line">&lt;标签 v-<span class="keyword">for</span>=<span class="string">&quot;(元素,键,索引) in 对象&quot;</span>&gt;&lt;/标签&gt;</span><br></pre></td></tr></table></figure><h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签 v-model=<span class="string">&quot;表达式&quot;</span>&gt;&lt;/标签&gt;</span><br><span class="line"></span><br><span class="line">在表单控件上创建双向绑定</span><br><span class="line">表单的值被修改时, 基于dom监听机制, 就会自动修改data中的数据中,</span><br><span class="line">当data中的数据被修改时,基于数据绑定机制, 自动会把新的内容自动更新到value属性上. 页面视图也发生了改变. 双向绑定</span><br><span class="line">v-model只作用于以下表单:</span><br><span class="line">input，select，textarea</span><br><span class="line"></span><br><span class="line"> 学生姓名 &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;stuForm.sname&quot;</span>&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure><h2 id="动态样式绑定"><a href="#动态样式绑定" class="headerlink" title="动态样式绑定"></a>动态样式绑定</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">class</span>样式</span><br><span class="line">  写法:<span class="keyword">class</span>=<span class="string">&quot;xxx&quot;</span> xxx可以是字符串、对象、数组。</span><br><span class="line"></span><br><span class="line">   字符串写法适用于：类名不确定，要动态获取。</span><br><span class="line">   对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</span><br><span class="line">   数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> style样式</span><br><span class="line"></span><br><span class="line"> :style=<span class="string">&quot;&#123;fontSize: xxx&#125;&quot;</span>其中xxx是动态值。</span><br><span class="line"> :style=<span class="string">&quot;[a,b]&quot;</span>其中a、b是样式对象。</span><br><span class="line"> </span><br><span class="line"> 个人感觉用处不大，到时候看！！！！！！！！！！！！！！！！！！</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.basic</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.good</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">4px</span> solid red;;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.644</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">30deg</span>, yellow, pink, orange, yellow);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.bad</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">4px</span> dashed <span class="built_in">rgb</span>(<span class="number">2</span>, <span class="number">197</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: gray;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.normal</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.mystyle1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.mystyle2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">10px</span> red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.mystyle3</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;status&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeStatus&quot;</span>&gt;</span>&#123;&#123;status&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    Style组合效果--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;styleArr&quot;</span>&gt;</span> 测试文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    写死数组--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;mystyle1&#x27;,&#x27;mystyle2&#x27;]&quot;</span>&gt;</span> 测试文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--写成对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span> 测试文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    对象写死--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;mystyle1:false,mystyle2:true,mystyle3:true&#125;&quot;</span>&gt;</span>来点文字看看<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    直接给定样式本身，传递参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: fsize +&#x27;px&#x27;&#125;&quot;</span>&gt;</span>看看有么有&#123;&#123;fsize&#125;&#125;px<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span>看看有么有&#123;&#123;styleObj&#125;&#125;px<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;styleArr&quot;</span>&gt;</span>背景黄色啦,字体蓝色啦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">title</span>: <span class="string">&quot;vue指令&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">status</span>: <span class="string">&quot;bad&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">statusArr</span>: [<span class="string">&#x27;bad&#x27;</span>, <span class="string">&#x27;good&#x27;</span>, <span class="string">&#x27;normal&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleArr</span>: [<span class="string">&#x27;mystyle1&#x27;</span>, <span class="string">&#x27;mystyle2&#x27;</span>, <span class="string">&#x27;mystyle3&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleObj</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">mystyle1</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">mystyle2</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">mystyle3</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">fsize</span>: <span class="number">32</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleObj</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">background</span>: <span class="string">&#x27;pink&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">fontSize</span>: <span class="string">&#x27;18px&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleObj2</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">color</span>: <span class="string">&#x27;orange&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">styleArr</span>: [</span></span><br><span class="line"><span class="language-javascript">                    &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">background</span>: <span class="string">&#x27;yellow&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">fontSize</span>: <span class="string">&#x27;35px&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;,</span></span><br><span class="line"><span class="language-javascript">                    &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                ]</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">changeStatus</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> number = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">this</span>.<span class="property">statusArr</span>.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable language_">this</span>.<span class="property">statusArr</span>[number];</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">要用的属性不存在，要通过已有属性计算得来。</span><br><span class="line">.原理：底层借助了<span class="title class_">Objcet</span>.<span class="property">defineproperty</span>方法提供的getter和setter。</span><br><span class="line"></span><br><span class="line">get函数什么时候执行？</span><br><span class="line">(<span class="number">1</span>).初次读取时会执行一次。</span><br><span class="line">(<span class="number">2</span>).当依赖的数据发生改变时会被再次调用。</span><br><span class="line"><span class="number">4.</span>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</span><br><span class="line"><span class="number">5.</span>备注：</span><br><span class="line"><span class="number">1.</span>计算属性最终会出现在vm上，直接读取使用即可。</span><br><span class="line"><span class="number">2.</span>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</span><br><span class="line">    </span><br><span class="line">相当于属性来进行使用</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    姓名：&lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;请输入姓名&quot;</span> v-model=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    专业：&lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;请输入专业&quot;</span> v-model=<span class="string">&quot;major&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;!--插值语法--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125; 学的是 &#123;&#123;major&#125;&#125; 专业<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;!--    通过方法--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;&#123;showMesssage()&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;!--    计算属性,当成属性使用--&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&quot;vue计算属性&quot;</span>,</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">major</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">stuInfor</span>: <span class="string">&quot; &quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="title function_">showMesssage</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;学的是&quot;</span> + <span class="variable language_">this</span>.<span class="property">major</span> + <span class="string">&quot;专业&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">computed</span>: &#123;</span><br><span class="line">            <span class="comment">//计算属性，当成方法写，当成属性用，必须要有返回值，返回值往往是拿其他属性计算出来</span></span><br><span class="line">            <span class="title function_">info</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;学的是&quot;</span> + <span class="variable language_">this</span>.<span class="property">major</span> + <span class="string">&quot;专业&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#125;）</span><br></pre></td></tr></table></figure><h2 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">监视属性watch：</span><br><span class="line"><span class="number">1.</span> 当被监视的属性变化时, 回调函数自动调用, 进行相关操作</span><br><span class="line"><span class="number">2.</span> 监视的属性必须存在，才能进行监视！！</span><br><span class="line"><span class="number">3.</span> 监视的两种写法：</span><br><span class="line">  (<span class="number">1</span>).<span class="property">new</span> <span class="title class_">Vue</span>时传入watch配置</span><br><span class="line">  (<span class="number">2</span>).通过vm.<span class="property">$watch</span>监视</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">            number <span class="comment">//属性名称: &#123;</span></span><br><span class="line">             <span class="comment">//初始化监听,相当于页面渲染的时候也在进行监听</span></span><br><span class="line">                <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">               <span class="comment">//监视对象里面数据的变化，就需要使用深度监视     deep: true,</span></span><br><span class="line">                <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">             <span class="comment">//    变化之后的回调函数</span></span><br><span class="line">                <span class="title function_">handler</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新&quot;</span>, newValue)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;旧的&quot;</span>, oldValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h1 id="VUE进阶"><a href="#VUE进阶" class="headerlink" title="VUE进阶"></a>VUE进阶</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">生命周期：</span><br><span class="line"><span class="number">1.</span>又名：生命周期回调函数、生命周期函数、生命周期钩子。</span><br><span class="line"><span class="number">2.</span>是什么：<span class="title class_">Vue</span>在关键时刻帮我们调用的一些特殊名称的函数。</span><br><span class="line"><span class="number">3.</span>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</span><br><span class="line"><span class="number">4.</span>生命周期函数中的<span class="variable language_">this</span>指向是vm 或 组件实例对象。</span><br></pre></td></tr></table></figure><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230531190708961-c28c8c.png" alt="image-20230531190708961"></p><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>VUE 生命周期<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    引入vue--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; number &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;number++&quot;</span>&gt;</span>number<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;bye&quot;</span>&gt;</span> 销毁按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">title</span>: <span class="string">&quot;vue生命周期钩子函数&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">number</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">bye</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bye&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                v.$destroy()</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(this)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;create&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(this)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeMount&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(this)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//使用频率高，已经完成挂载，很多初始化工作在这里执行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mounted&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(this)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//新数据，旧页面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeUpdate&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(this.number)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;updated&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(this.number)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeDestroy&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;destroyed&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常用的生命周期钩子：</span><br><span class="line"> <span class="number">1.</span>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</span><br><span class="line"> <span class="number">2.</span>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</span><br></pre></td></tr></table></figure><h2 id="VUE组件"><a href="#VUE组件" class="headerlink" title="VUE组件"></a>VUE组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单文件组件(xxx.vue)和非单文件组件(在html中创建)</span><br></pre></td></tr></table></figure><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;自定义标签的名字&quot;</span>,&#123;配置对象&#125;)</span><br><span class="line"></span><br><span class="line">全局组件可以在任何被挂着的标签中使用.</span><br><span class="line">全局组件的配置对象中必须包含template属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;!--    需要复用，可以封装为组件，可以起名为school  使用的时候，直接&lt;school&gt;&lt;/&gt;school&gt;--&gt;</span><br><span class="line">    &lt;!--div必须要和vue挂载才可以使用--&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建全局组件</span></span><br><span class="line">    <span class="comment">//定义第一个全局组件</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;school&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&quot; &lt;div class=\&quot;school\&quot;&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        &lt;h1&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#123;&#123;school.name&#125;&#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        &lt;/h1&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        &lt;h2&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            &#123;&#123;school.address&#125;&#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        &lt;/h2&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &lt;/div&gt;&quot;</span>,</span><br><span class="line">        <span class="comment">//组件中data必须要用函数式</span></span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">school</span>: &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;东北大学&quot;</span>,</span><br><span class="line">                    <span class="attr">address</span>: <span class="string">&quot;沈阳市浑南区&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">分开创建</span><br><span class="line"> <span class="comment">//创建一个学生的组件</span></span><br><span class="line">    <span class="keyword">let</span> stuComponent = &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;    &lt;div class=&quot;student&quot;&gt;\n&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;        &lt;h2&gt;&#123;&#123;student.name&#125;&#125;&lt;/h2&gt;\n&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;        &lt;h2&gt;&#123;&#123;student.major&#125;&#125;&lt;/h2&gt;\n&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;    &lt;/div&gt;&#x27;</span>,</span><br><span class="line">        <span class="comment">//组件中data必须要用函数式</span></span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">student</span>: &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">                    <span class="attr">major</span>: <span class="string">&quot;软件工程&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;student&#x27;</span>, stuComponent);</span><br><span class="line">    </span><br><span class="line">    然后再<span class="variable constant_">VUE</span>挂载的区域内，使用&lt;student&gt;&lt;/student&gt;就可以显示</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于是全局组件，所以在VUE区域挂载的地方，都可以使用</span><br></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">    components : &#123;</span><br><span class="line">        <span class="string">&quot;局部组件的名字1&quot;</span> : &#123;组件的配置对象&#125;,</span><br><span class="line">        <span class="string">&quot;局部组件的名字2&quot;</span> : &#123;组件的配置对象&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">定义完成对象后，挂载到<span class="variable constant_">VUE</span>对象实例身上即可</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"> <span class="comment">//局部组件的注册就是在vue实例上注册</span></span><br><span class="line">    <span class="keyword">let</span> helloComponent = &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;&lt;h1 style=&quot;color: #bd362f&quot;&gt; 这是一个局部hello组件&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行挂载</span></span><br><span class="line">     <span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&quot;vue非单文件组件&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">components</span>: &#123;</span><br><span class="line">            <span class="comment">//如果名字和键一样，就可以只用引入一个，名字是随便起的，键是上面定义的对象</span></span><br><span class="line">            <span class="attr">hello</span>: helloComponent,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="组件使用两种HTML模板"><a href="#组件使用两种HTML模板" class="headerlink" title="组件使用两种HTML模板"></a>组件使用两种HTML模板</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;mytemplate&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>template标签中的html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mytemplate&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>template标签中的html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">相当于就直接写好了两个template模版</span><br></pre></td></tr></table></figure><h2 id="VUE-Router路由"><a href="#VUE-Router路由" class="headerlink" title="VUE-Router路由"></a>VUE-Router路由</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装：</span><br><span class="line"></span><br><span class="line">npm i vue-router@3.0.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">&lt;!--</span><br><span class="line">步骤分析：</span><br><span class="line">   1 下载vue-router npm i vue-router</span><br><span class="line">   2 导入进入  &lt;script src=&quot;node_modules/vue-router/dist/vue-router.js&quot;</span><br><span class="line">   3 定义路由</span><br><span class="line">      3.1 定义路由所需要组件--定义路由组件</span><br><span class="line">      3.2 定义路由规则-哪个地址跳转到哪个组件</span><br><span class="line">      3.3 通过路由规则定义路由 路由对象</span><br><span class="line">   4 把路由挂载到vue实例</span><br><span class="line">   5 显示</span><br><span class="line">     5.1 定义显示区域</span><br><span class="line">     5.2 超链接跳转-通过超链接地址和路由规则可以找到组件，把组件渲染到显示区域</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>VUE 生命周期<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--    引入vue--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--在命令行，通过npm i vue-router@3.0.1  下载并引入--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/vue-router/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--    路由显示 ： 1.路由导航 2.路由组件视图--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--5.2 超链接跳转--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/stu&quot;</span>&gt;</span>学生管理中心<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/course&quot;</span>&gt;</span>课程管理中心<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--5.1 定义显示区域--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//创建路由中需要的组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> index = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">template</span>: <span class="string">&#x27;&lt;h1 style=&quot;color: #bd362f&quot;&gt;&lt;marquee&gt;欢迎来到学生管理系统首页！&lt;/marquee&gt;&lt;/h1&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> course = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">template</span>: <span class="string">&#x27;&lt;h1 style=&quot;color: aqua&quot;&gt;这里是课程管理页面 &lt;/h1&gt;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//定义路由规则</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> routes = [</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123;<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: index&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#123;<span class="attr">path</span>: <span class="string">&#x27;/course&#x27;</span>, <span class="attr">component</span>: course&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//创建路由对象，根据路由规则进行创建</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> vueRouter = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//指定路由规则对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果键值相同的情况下可以简写</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">routes</span>: routes,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">title</span>: <span class="string">&quot;vue 路由&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//把router路由对象挂载到vue实例的身上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">router</span>: vueRouter</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Vue-cli必须搞定"><a href="#Vue-cli必须搞定" class="headerlink" title="Vue-cli必须搞定"></a>Vue-cli必须搞定</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230613103255377-17d8b2.png" alt="image-20230613103255377"></p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要进行异步请求：</span><br><span class="line">  使用axios</span><br><span class="line">  1、安装 npm i axios</span><br><span class="line">  2、引入  import axios from &#x27;axios&#x27;</span><br><span class="line">  3、使用</span><br><span class="line">    axios.请求方式(请求url,请求参数)</span><br><span class="line">      .then((res)=&gt;&#123;  //成功   res中data属性才是我们返回的ResultBean</span><br><span class="line">        console.log(res);</span><br><span class="line">      &#125;).catch((ex)=&gt;&#123;   //异常处理</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h3 id="在main-js引入"><a href="#在main-js引入" class="headerlink" title="在main.js引入"></a>在main.js引入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios挂载到全局，引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置基本路由，axios发射的基础路径</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:8080&#x27;</span></span><br><span class="line"><span class="comment">// 挂载到原型对象身上，  $http 是自己起的名字</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$http</span> = axios</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//发起一个网络请求,在axios里面传递参数不需要转化</span><br></pre></td></tr></table></figure><h2 id="处理跨域"><a href="#处理跨域" class="headerlink" title="处理跨域"></a>处理跨域</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.添加CORS配置信息</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://127.0.0.1:8081&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://localhost:8081&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://127.0.0.1:80&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://localhost:80&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://127.0.0.1&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2) 是否发送Cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//3) 允许的请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PATCH&quot;</span>);</span><br><span class="line">        <span class="comment">// 4）允许的头信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//2.添加映射路径，我们拦截一切请求</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        configSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="comment">//3.返回新的CorsFilter.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue整合ElementUI"><a href="#Vue整合ElementUI" class="headerlink" title="Vue整合ElementUI"></a>Vue整合ElementUI</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure><h3 id="main-js引入"><a href="#main-js引入" class="headerlink" title="main.js引入"></a>main.js引入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入elementUI</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class="line">//VUE使用ElementUI</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure><h2 id="VUE整合Echarts"><a href="#VUE整合Echarts" class="headerlink" title="VUE整合Echarts"></a>VUE整合Echarts</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import * as echarts from &#x27;echarts&#x27;</span><br><span class="line">// 集成echarts</span><br><span class="line">Vue.prototype.$echarts = echarts</span><br></pre></td></tr></table></figure><h2 id="Vue整合常用文本编辑器"><a href="#Vue整合常用文本编辑器" class="headerlink" title="Vue整合常用文本编辑器"></a>Vue整合常用文本编辑器</h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install wangeditor --save</span><br></pre></td></tr></table></figure><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;editorElem&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import wangEditor from &#x27;wangeditor&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;myEdit&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      editor: null,</span><br><span class="line">      imgUrl:&#x27;&#x27;,</span><br><span class="line">      form:&#123;</span><br><span class="line">        coverUrl:&quot;&quot;,</span><br><span class="line">        context:&#x27;&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //在mounted里创建编辑器</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    const editor = new wangEditor(`#editorElem`)</span><br><span class="line">    // var that = this</span><br><span class="line">    editor.config.height = 400</span><br><span class="line">    editor.config.uploadImgMaxSize = 2 * 1024 * 1024 // 2M</span><br><span class="line">    editor.config.uploadImgMaxLength = 1 // 一次最多上传 1 个图片</span><br><span class="line">    editor.config.customUploadImg = (resultFiles, insertImgFn) =&gt; &#123;</span><br><span class="line">      // resultFiles 是 input 中选中的文件列表</span><br><span class="line">      // insertImgFn 是获取图片 url 后，插入到编辑器的方法</span><br><span class="line">      // 上传图片</span><br><span class="line">      let formData = new FormData();</span><br><span class="line">      formData.append(&quot;upFile&quot;, resultFiles[0]);</span><br><span class="line">      this.$http.post(&quot;/up&quot;,formData)</span><br><span class="line">        .then((response) =&gt; &#123;</span><br><span class="line">          this.imgUrl = response.data.msg;//拿到后台返回的上传路径</span><br><span class="line">          console.log(this.imgUrl)</span><br><span class="line">          // 上传图片，返回结果，将图片插入到编辑器中</span><br><span class="line">          insertImgFn(this.imgUrl)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 配置 onchange 回调函数，将数据同步到 vue 中</span><br><span class="line">    editor.config.onchange = (newHtml) =&gt; &#123;</span><br><span class="line">      this.form.context = newHtml</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 创建编辑器</span><br><span class="line">    editor.create()</span><br><span class="line">    this.editor = editor</span><br><span class="line">    //如果是编辑需要回显</span><br><span class="line">    //this.editor.txt.html(this.form.context)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    // 调用销毁 API 对当前编辑器实例进行销毁</span><br><span class="line">    this.editor.destroy()</span><br><span class="line">    this.editor = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">/deep/ .w-e-toolbar&#123;</span><br><span class="line">  z-index: 3 !important;</span><br><span class="line">&#125;</span><br><span class="line">/deep/ .w-e-text-container &#123;</span><br><span class="line">  z-index: 2 !important;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在需要的组件使用"><a href="#在需要的组件使用" class="headerlink" title="在需要的组件使用"></a>在需要的组件使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div style=&quot;width: 500px;margin: 0 auto&quot;&gt;</span><br><span class="line">      &lt;h1&gt;添加文章&lt;/h1&gt;</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        标题：&lt;input type=&quot;text&quot; v-model=&quot;form.title&quot;&gt;&lt;br&gt;</span><br><span class="line">        内容：&lt;Wang ref=&quot;wang&quot;&gt;&lt;/Wang&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;提交&quot; @click=&quot;add&quot;&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Wang from &#x27;./Wang&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  components: &#123;Wang&#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Hello Kitty!!!&#x27;,</span><br><span class="line">      components: &#123;Wang&#125;,</span><br><span class="line">      form: &#123;</span><br><span class="line">        title: &#x27;&#x27;,</span><br><span class="line">        content: &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.form.content = this.$refs.wang.form.context</span><br><span class="line">      console.log(this.form);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="Vuex流程图"><a href="#Vuex流程图" class="headerlink" title="Vuex流程图"></a>Vuex流程图</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604102238408-5364b7.png" alt="image-20230604102238408"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举个简单的例子，去餐馆吃饭，vuex相当于餐馆，components相当于客人，那么actions就相当于服务员，将需求提交给后厨Mutations,后厨做完成为饭菜State</span><br><span class="line"></span><br><span class="line">当然Actions是可以省略的，但是其他两步不可</span><br><span class="line"></span><br><span class="line">其实Mutations里面是写方法的，State是写变量的</span><br></pre></td></tr></table></figure><h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装：vuex：npm i vuex@3</span><br><span class="line">创建文件：src/store/index.js</span><br></pre></td></tr></table></figure><h3 id="index-vue"><a href="#index-vue" class="headerlink" title="index.vue"></a>index.vue</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//使用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions——用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations——用于操作(state)</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state——用于操作数据(state)</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">//挂载</span></span><br><span class="line">    store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>初始化数据、配置actions、配置mutations，操作文件store.js</p><p>组件中读取vuex中的数据：$store.state.sum</p><p>组件中修改vuex中的数据：$store.dispatch(‘action中的方法名’,数据) 或 $store.commit(‘mutations中的方法名’,数据)</p><p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//使用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions——用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jia-----&#x27;</span>)</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">jian</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jian-----&#x27;</span>)</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;JIAN&#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">jiaOdd</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jiaOdd-----&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(context.<span class="property">state</span>.<span class="property">sum</span>%<span class="number">2</span>)&#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">jiaWait</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jiaWait-----&#x27;</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备mutations——用于操作(state)</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;JIA------&#x27;</span>)</span><br><span class="line">        state.<span class="property">sum</span> += value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">sum</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">JIAN</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;JIAN------&#x27;</span>)</span><br><span class="line">        state.<span class="property">sum</span> -= value</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">sum</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备state——用于操作数据(state)</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">sum</span>: <span class="number">0</span> <span class="comment">//当前的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#x27;jiaWait&#x27;,this.n)</span><br><span class="line">actions 中的方法名称</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将实例中template属性值进行编译，并将编译后的dom替换掉vue实例绑定的元素，如果该vue实例绑定的元素中存在内容，这些内容会直接被覆盖。</span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">1）如果vue实例中有template属性，会将该属性值进行编译，将编译后的虚拟dom直接替换掉vue实例绑定的元素（即el绑定的那个元素）；</span><br><span class="line">2）template属性中的dom结构只能有一个根元素，如果有多个根元素需要使用v-if、v-else、v-else-if设置成只显示其中一个根元素；</span><br><span class="line">3）在该属性对应的属性值中可以使用vue实例data、methods中定义的数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-for中循环"><a href="#v-for中循环" class="headerlink" title="v-for中循环"></a>v-for中循环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-for=&quot;page of totalPage  循环数字，相当于 如果totalPage == 5  page = 1,2,3,4,5</span><br><span class="line">  &lt;tr v-for=&quot;(stu, index) in stuList&quot;&gt;   循环集合，</span><br></pre></td></tr></table></figure><h3 id="复制list内容"><a href="#复制list内容" class="headerlink" title="复制list内容"></a>复制list内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//由于传递过去是个引用，修改会同时修改，所以需要传递值过去，用下面的方法，可以将row集合里面的内容复制给form</span><br><span class="line">    this.form = Object.assign(&#123;&#125;, row);</span><br></pre></td></tr></table></figure><h3 id="父组件拿子组件数据"><a href="#父组件拿子组件数据" class="headerlink" title="父组件拿子组件数据"></a>父组件拿子组件数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先在父组件进行注册</span><br><span class="line">  components: &#123;myEdit&#125;,</span><br><span class="line">  </span><br><span class="line"> 父组件 进行引入</span><br><span class="line">  &lt;myEdit ref=&quot;myEdit&quot;&gt;&lt;/myEdit&gt;</span><br><span class="line">  </span><br><span class="line">  获得数据</span><br><span class="line">this.$refs.name这样就可以获取到子组件</span><br></pre></td></tr></table></figure><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.yuque.com/cessstudy/kak11d/hfeef2">鱼雀笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLaMA-Factory</title>
      <link href="/posts/12365.html"/>
      <url>/posts/12365.html</url>
      
        <content type="html"><![CDATA[<h1 id="LLaMA-Factory-QuickStart"><a href="#LLaMA-Factory-QuickStart" class="headerlink" title="LLaMA-Factory QuickStart"></a>LLaMA-Factory QuickStart</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/695287607">https://zhuanlan.zhihu.com/p/695287607</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hiyouga/LLaMA-Factory.git</span><br><span class="line">conda create -n llama_factory python=<span class="number">3.10</span></span><br><span class="line">conda activate llama_factory</span><br><span class="line">cd LLaMA-Factory</span><br><span class="line">pip install -e <span class="string">&#x27;.[torch,metrics]&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上述的安装命令完成了如下几件事</span><br><span class="line"></span><br><span class="line">新建一个LLaMA-Factory 使用的python环境（可选）</span><br><span class="line">安装LLaMA-Factory 所需要的第三方基础库（requirements.txt包含的库）</span><br><span class="line">安装评估指标所需要的库，包含nltk, jieba, rouge-chinese</span><br><span class="line">安装LLaMA-Factory本身，然后在系统中生成一个命令 llamafactory-cli（具体用法见下方教程）</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.current_device()</span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>)</span><br><span class="line">torch.__version__</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用 llamafactory-cli version 来快速校验安装是否成功</span><br></pre></td></tr></table></figure><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p>项目支持通过模型名称直接从huggingface 和modelscope下载模型，但这样不容易对模型文件进行统一管理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Meta-Llama-3-8B-Instruct为例</span><br><span class="line"></span><br><span class="line">modelscope 下载（适合中国大陆网络环境）</span><br><span class="line">git clone https://www.modelscope.cn/LLM-Research/Meta-Llama-3-8B-Instruct.git</span><br><span class="line">这种方法下载失败了</span><br><span class="line"></span><br><span class="line">使用的方法是在linux里面下载安装</span><br><span class="line">pip install modelscope</span><br><span class="line"></span><br><span class="line">然后进行下载</span><br><span class="line">modelscope download --model LLM-Research/Meta-Llama-3-8B-Instruct --local_dir ./ </span><br><span class="line"></span><br><span class="line">/pk-data-4T/yingchaohe/Model/Meta-Llama-3-8B-Instruct/</span><br></pre></td></tr></table></figure><h3 id="测试下载是否完整"><a href="#测试下载是否完整" class="headerlink" title="测试下载是否完整"></a>测试下载是否完整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> transformers</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换为你下载的模型文件目录, 这里的demo是Llama-3-8B-Instruct</span></span><br><span class="line"><span class="comment"># 如果是其他模型，比如qwen，chatglm，请使用其对应的官方demo</span></span><br><span class="line">model_id = <span class="string">&quot;/home/ubuntu/model/Meta-Llama-3-8B-Instruct/&quot;</span></span><br><span class="line"></span><br><span class="line">pipeline = transformers.pipeline(</span><br><span class="line">    <span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">    model=model_id,</span><br><span class="line">    model_kwargs=&#123;<span class="string">&quot;torch_dtype&quot;</span>: torch.float16&#125;,</span><br><span class="line">    device_map=&#123;<span class="string">&quot;&quot;</span>: <span class="string">&quot;cuda:0&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a pirate chatbot who always responds in pirate speak!&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Who are you?&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">prompt = pipeline.tokenizer.apply_chat_template(</span><br><span class="line">        messages,</span><br><span class="line">        tokenize=<span class="literal">False</span>,</span><br><span class="line">        add_generation_prompt=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">terminators = [</span><br><span class="line">    pipeline.tokenizer.eos_token_id,</span><br><span class="line">    pipeline.tokenizer.convert_tokens_to_ids(<span class="string">&quot;&lt;|eot_id|&gt;&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">outputs = pipeline(</span><br><span class="line">    prompt,</span><br><span class="line">    max_new_tokens=<span class="number">256</span>,</span><br><span class="line">    eos_token_id=terminators,</span><br><span class="line">    do_sample=<span class="literal">True</span>,</span><br><span class="line">    temperature=<span class="number">0.6</span>,</span><br><span class="line">    top_p=<span class="number">0.9</span>,</span><br><span class="line">    batch_size=<span class="number">1</span>  <span class="comment"># 设置较小的批量大小</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(outputs[<span class="number">0</span>][<span class="string">&quot;generated_text&quot;</span>][<span class="built_in">len</span>(prompt):])</span><br></pre></td></tr></table></figure><h3 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改数据注册文件</span><br><span class="line">修改文件：LLaMA-Factory/data/dataset_info.json，目的是为了让LLaMA-Factory识别到我们的数据集文件。</span><br><span class="line"></span><br><span class="line">注：其中columns指定了数据集的列。</span><br><span class="line"></span><br><span class="line">&quot;fintech&quot;: &#123;</span><br><span class="line">  &quot;file_name&quot;: &quot;fintech.json&quot;,</span><br><span class="line">  &quot;columns&quot;: &#123;</span><br><span class="line">    &quot;prompt&quot;: &quot;instruction&quot;,</span><br><span class="line">    &quot;query&quot;: &quot;input&quot;,</span><br><span class="line">    &quot;response&quot;: &quot;output&quot;,</span><br><span class="line">    &quot;history&quot;: &quot;history&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行web界面"><a href="#运行web界面" class="headerlink" title="运行web界面"></a>运行web界面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export DEFAULT_CACHE_DIR=/home/ubuntu/model/cache 设置缓存文件位置</span><br><span class="line">CUDA_VISIBLE_DEVICES=0,1 llamafactory-cli webui</span><br><span class="line"></span><br><span class="line">这样启动了</span><br><span class="line">sudo CUDA_VISIBLE_DEVICES=0,1  GRADIO_SERVER_PORT=60620  GRADIO_SHARE=1 -E /home/ubuntu/anaconda3/envs/llama_factory/bin/llamafactory-cli webui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo CUDA_VISIBLE_DEVICES=0,1  GRADIO_SERVER_PORT=60620  GRADIO_SERVER_NAME=202.117.43.30 -E /home/ubuntu/anaconda3/envs/llama_factory/bin/llamafactory-cli webui</span><br></pre></td></tr></table></figure><h2 id="基于LoRA的sft指令微调"><a href="#基于LoRA的sft指令微调" class="headerlink" title="基于LoRA的sft指令微调"></a>基于LoRA的sft指令微调</h2><p>注意路径</p><p>Chinese版本的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1 llamafactory-cli train \</span><br><span class="line">    --stage sft \</span><br><span class="line">    --do_train \</span><br><span class="line">    --model_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct \</span><br><span class="line">    --dataset alpaca_zh_demo,identity,adgen_local \</span><br><span class="line">    --dataset_dir /home/ubuntu/model/LLaMA-Factory/data/ \</span><br><span class="line">    --template llama3 \</span><br><span class="line">    --finetuning_type lora \</span><br><span class="line">    --output_dir /home/ubuntu/model/Meta-Llama-3-8B-Instruct-savaModel/ \</span><br><span class="line">    --overwrite_cache \</span><br><span class="line">    --overwrite_output_dir \</span><br><span class="line">    --cutoff_len 1024 \</span><br><span class="line">    --preprocessing_num_workers 16 \</span><br><span class="line">    --per_device_train_batch_size 2 \</span><br><span class="line">    --per_device_eval_batch_size 1 \</span><br><span class="line">    --gradient_accumulation_steps 8 \</span><br><span class="line">    --lr_scheduler_type cosine \</span><br><span class="line">    --logging_steps 50 \</span><br><span class="line">    --warmup_steps 20 \</span><br><span class="line">    --save_steps 100 \</span><br><span class="line">    --eval_steps 50 \</span><br><span class="line">    --evaluation_strategy steps \</span><br><span class="line">    --load_best_model_at_end \</span><br><span class="line">    --learning_rate 5e-5 \</span><br><span class="line">    --num_train_epochs 5.0 \</span><br><span class="line">    --max_samples 1000 \</span><br><span class="line">    --val_size 0.1 \</span><br><span class="line">    --plot_loss \</span><br><span class="line">    --fp16</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>stage</td><td>当前训练的阶段，枚举值，有“sft”,”pt”,”rm”,”ppo”等，代表了训练的不同阶段，这里我们是有监督指令微调，所以是sft</td></tr><tr><td>do_train</td><td>是否是训练模式</td></tr><tr><td>dataset</td><td>使用的数据集列表，所有字段都需要按上文在data_info.json里注册，多个数据集用”,”分隔</td></tr><tr><td>dataset_dir</td><td>数据集所在目录，这里是 data，也就是项目自带的data目录</td></tr><tr><td>finetuning_type</td><td>微调训练的类型，枚举值，有”lora”,”full”,”freeze”等，这里使用lora</td></tr><tr><td>output_dir</td><td>训练结果保存的位置</td></tr><tr><td>cutoff_len</td><td>训练数据集的长度截断</td></tr><tr><td>per_device_train_batch_size</td><td>每个设备上的batch size，最小是1，如果GPU 显存够大，可以适当增加</td></tr><tr><td>fp16</td><td>使用半精度混合精度训练</td></tr><tr><td>max_samples</td><td>每个数据集采样多少数据</td></tr><tr><td>val_size</td><td>随机从数据集中抽取多少比例的数据作为验证集</td></tr></tbody></table><p>另外两个关键参数解释如下，后续的基本所有环节都会继续使用这两个参数</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>model_name_or_path</td><td>参数的名称（huggingface或者modelscope上的标准定义，如“meta-llama&#x2F;Meta-Llama-3-8B-Instruct”）， 或者是本地下载的绝对路径，如&#x2F;media&#x2F;codingma&#x2F;LLM&#x2F;llama3&#x2F;Meta-Llama-3-8B-Instruct</td></tr><tr><td>template</td><td>模型问答时所使用的prompt模板，不同模型不同，请参考 <a href="https://link.zhihu.com/?target=https://github.com/hiyouga/LLaMA-Factory?tab=readme-ov-file%23supported-models">https://github.com/hiyouga/LLaMA-Factory?tab=readme-ov-file#supported-models</a> 获取不同模型的模板定义，否则会回答结果会很奇怪或导致重复生成等现象的出现。chat 版本的模型基本都需要指定，比如Meta-Llama-3-8B-Instruct的template 就是 llama3</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1:</span><br><span class="line">指定使用哪些GPU进行训练。0,1表示使用GPU 0和GPU 1。你可以根据可用的GPU资源来调整。如果你只有一个GPU，可以设置为CUDA_VISIBLE_DEVICES=0。</span><br><span class="line"></span><br><span class="line">--stage sft:</span><br><span class="line">指定训练的阶段。在这里是SFT（Supervised Fine-tuning），即监督微调。如果进行不同阶段的训练（如预训练或推理），需要更改这个值。</span><br><span class="line"></span><br><span class="line">--do_train:</span><br><span class="line">表示进行训练。如果只需要进行推理或评估，可以去掉这个参数。</span><br><span class="line"></span><br><span class="line">--model_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct:</span><br><span class="line">指定预训练模型的路径或名称。这个路径需要指向你已经下载或训练好的模型。如果你想换用其他模型，可以调整这个参数。</span><br><span class="line"></span><br><span class="line">--dataset dianwang01:</span><br><span class="line">指定数据集的名称。你可以根据需要使用不同的数据集名称。</span><br><span class="line"></span><br><span class="line">--dataset_dir /home/ubuntu/model/LLaMA-Factory/data/:</span><br><span class="line">指定数据集的目录。根据数据存储位置来调整这个路径。</span><br><span class="line"></span><br><span class="line">--template llama3:</span><br><span class="line">指定使用的模板。模板通常定义了输入数据的格式。可以根据不同的数据类型和任务选择不同的模板。</span><br><span class="line"></span><br><span class="line">--finetuning_type lora:</span><br><span class="line">指定微调类型，lora是低秩适应（LoRA）技术，可以减少显存使用。如果你有更多显存，可以选择其他微调方法，如全模型微调。</span><br><span class="line"></span><br><span class="line">--output_dir /home/ubuntu/model/Model/Meta-Llama-3-8B-Instruct-dianwang001/Meta-Llama-3-8B-Instruct-savaModel/:</span><br><span class="line">模型保存的输出路径。确保输出路径正确且有足够存储空间。</span><br><span class="line"></span><br><span class="line">--overwrite_cache:</span><br><span class="line">重新生成数据缓存。如果数据有变化或缓存出现问题，可以使用这个选项。</span><br><span class="line"></span><br><span class="line">--overwrite_output_dir:</span><br><span class="line">覆盖输出目录。如果之前已有训练结果并且你想重新训练，启用这个选项。</span><br><span class="line"></span><br><span class="line">--cutoff_len 2048:</span><br><span class="line">最大序列长度。根据模型大小和数据情况可以调高或调低。例如，显存不足时可以调低此值。</span><br><span class="line"></span><br><span class="line">--preprocessing_num_workers 16:</span><br><span class="line">数据预处理的工作线程数。可以根据CPU核数和数据预处理复杂度来调整。更多的线程可以加速预处理，但可能增加系统负载。</span><br><span class="line"></span><br><span class="line">--per_device_train_batch_size 1:</span><br><span class="line">每个设备（GPU）的训练批次大小。显存不足时可以调小此值，显存充足时可以调大以提高训练效率。</span><br><span class="line"></span><br><span class="line">--per_device_eval_batch_size 1:</span><br><span class="line">每个设备的评估批次大小。同样地，显存不足时调小，显存充足时调大。</span><br><span class="line"></span><br><span class="line">--gradient_accumulation_steps 8:</span><br><span class="line">梯度累计步数。显存不足时可以增加此值，以模拟更大的批次大小而不占用过多显存。</span><br><span class="line"></span><br><span class="line">--lr_scheduler_type cosine:</span><br><span class="line">学习率调度器类型，cosine表示余弦退火学习率。如果你需要更稳定的学习率调整，可以选择其他调度器类型。</span><br><span class="line"></span><br><span class="line">--logging_steps 500:</span><br><span class="line">日志记录的步数间隔。根据你希望记录日志的频率可以调整这个值。</span><br><span class="line"></span><br><span class="line">--warmup_steps 200:</span><br><span class="line">学习率预热的步数。在训练初期，模型通常学习率较低，然后逐渐提高。可以根据需要调整预热步数，数据量大时可以增加。</span><br><span class="line"></span><br><span class="line">--save_steps 1000:</span><br><span class="line">保存模型的步数间隔。可以根据训练时长和硬盘空间调整保存频率。</span><br><span class="line"></span><br><span class="line">--eval_steps 500:</span><br><span class="line">评估模型的步数间隔。可以根据训练情况和时间开销来调整评估频率。</span><br><span class="line"></span><br><span class="line">--evaluation_strategy steps:</span><br><span class="line">评估策略。steps表示按步数评估，也可以选择epoch按训练轮次评估。</span><br><span class="line"></span><br><span class="line">--load_best_model_at_end:</span><br><span class="line">在训练结束后加载表现最好的模型。一般启用此选项可以确保最终得到最优模型。</span><br><span class="line"></span><br><span class="line">--learning_rate 5e-5:</span><br><span class="line">初始学习率。可以根据模型和数据的复杂性调整，较大的学习率适合简单任务，较小的学习率适合复杂任务。</span><br><span class="line"></span><br><span class="line">--num_train_epochs 5.0:</span><br><span class="line">训练的总轮数。较大的数据集和复杂的任务可以增加训练轮数，小数据集可以减少。</span><br><span class="line"></span><br><span class="line">--max_samples 10000:</span><br><span class="line">最大样本数量。可以根据任务的数据量和训练目标调整，设定上限可以节省时间和资源。</span><br><span class="line"></span><br><span class="line">--val_size 0.1:</span><br><span class="line">验证集比例，0.1表示10%的数据作为验证集。可以根据数据量调整此比例。</span><br><span class="line"></span><br><span class="line">--plot_loss:</span><br><span class="line">绘制损失曲线，启用此选项可以直观查看训练过程中的损失变化。</span><br><span class="line"></span><br><span class="line">--fp16:</span><br><span class="line">使用半精度浮点数训练，减小显存占用并加快训练。如果硬件支持，可以启用。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. --per_device_train_batch_size</span><br><span class="line">作用：每个设备（如 GPU）上训练时的批次大小。该参数会影响模型训练的稳定性和速度。更大的批次可以提高训练效率，但需要更多显存。</span><br><span class="line">调节：增加批次大小可以加速训练，但如果显存不够，可能导致 OOM（Out of Memory）。通常建议在你的 GPU 显存允许范围内调整。</span><br><span class="line">3. --per_device_eval_batch_size</span><br><span class="line">作用：每个设备上评估时的批次大小。评估时可以使用较小的批次大小，因为不需要进行反向传播。</span><br><span class="line">调节：评估时通常不需要过大的批次，1 或 2 就足够。这个值主要受显存影响。</span><br><span class="line">4. --gradient_accumulation_steps</span><br><span class="line">作用：梯度累积步数。在显存有限的情况下，使用较小的批次进行训练，然后累积梯度并更新权重。它可以让你在不增加显存消耗的情况下使用较大的“有效”批次大小。</span><br><span class="line">调节：增加 gradient_accumulation_steps 可以减少显存的消耗，但会增加训练时间。通常，如果显存较紧张，可以将其调高。</span><br><span class="line">--warmup_steps</span><br><span class="line">作用：预热步数，训练开始时，学习率从 0 慢慢增加到设定值，以避免模型在训练初期由于学习率过大而不稳定。</span><br><span class="line">调节：通常设定为训练总步数的 10%-20%。如果训练开始不稳定，可以适当增加 warmup_steps。</span><br><span class="line">7. --num_train_epochs</span><br><span class="line">作用：训练的总轮数。每一轮是整个数据集被训练一次。</span><br><span class="line">调节：较多的轮数通常能使模型学到更多，但也会增加训练时间。你可以根据模型收敛情况调整轮数。如果训练数据较小，可以适当增加；如果数据很大，可能需要减少轮数。</span><br></pre></td></tr></table></figure><h2 id="功能控制"><a href="#功能控制" class="headerlink" title="功能控制"></a>功能控制</h2><p>通过不同的参数控制现在是实现什么功能，比如现在是想使用网页版本直接推理，所以第一个参数设置为webchat, 所有的可选项包括</p><table><thead><tr><th>动作参数枚举</th><th>参数说明</th></tr></thead><tbody><tr><td>version</td><td>显示版本信息</td></tr><tr><td>train</td><td>命令行版本训练</td></tr><tr><td>chat</td><td>命令行版本推理chat</td></tr><tr><td>export</td><td>模型合并和导出</td></tr><tr><td>api</td><td>启动API server，供接口调用</td></tr><tr><td>eval</td><td>使用mmlu等标准数据集做评测</td></tr><tr><td>webchat</td><td>前端版本纯推理的chat页面</td></tr><tr><td>webui</td><td>启动LlamaBoard前端页面，包含可视化训练，预测，chat，模型合并多个子页面</td></tr></tbody></table><h2 id="运行完成后尝试进行推理"><a href="#运行完成后尝试进行推理" class="headerlink" title="运行完成后尝试进行推理"></a>运行完成后尝试进行推理</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250227132033017-a58804-9b523e.png" alt="image-20250227132033017"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO|trainer.py:4263] 2025-02-26 16:46:40,376 &gt;&gt;   Batch size = 1</span><br><span class="line">100%|█████████████████████████████████████████████████████████████████████████████████████| 105/105 [00:10&lt;00:00,  9.67it/s]</span><br><span class="line">***** eval metrics *****</span><br><span class="line">  epoch                   =     4.9851</span><br><span class="line">  eval_loss               =     1.8326</span><br><span class="line">  eval_runtime            = 0:00:10.94</span><br><span class="line">  eval_samples_per_second =     19.188</span><br><span class="line">  eval_steps_per_second   =      9.594</span><br><span class="line">[INFO|modelcard.py:449] 2025-02-26 16:46:51,323 &gt;&gt; Dropping the following result as it does not have all the necessary fields:</span><br><span class="line">&#123;&#x27;task&#x27;: &#123;&#x27;name&#x27;: &#x27;Causal Language Modeling&#x27;, &#x27;type&#x27;: &#x27;text-generation&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1 llamafactory-cli chat \</span><br><span class="line">    --model_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct  \</span><br><span class="line">    --adapter_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct-savaModel/   \</span><br><span class="line">    --template llama3 \</span><br><span class="line">    --finetuning_type lora \</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250227141543068-f3979a.png" alt="image-20250227141543068"></p><h2 id="批量预测和训练效果评估"><a href="#批量预测和训练效果评估" class="headerlink" title="批量预测和训练效果评估"></a>批量预测和训练效果评估</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当然上文中的人工交互测试，会偏感性，那有没有办法批量地预测一批数据，然后使用自动化的bleu和 rouge等常用的文本生成指标来做评估。指标计算会使用如下3个库，请先做一下pip安装</span><br><span class="line"></span><br><span class="line">pip install jieba</span><br><span class="line">pip install rouge-chinese</span><br><span class="line">pip install nltk</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=0,1 llamafactory-cli train \</span><br><span class="line">    --stage sft \</span><br><span class="line">    --do_predict \</span><br><span class="line">    --model_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct  \</span><br><span class="line">    --adapter_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct-savaModel/  \</span><br><span class="line">    --eval_dataset alpaca_zh_demo,identity,adgen_local \</span><br><span class="line">    --dataset_dir /home/ubuntu/model/LLaMA-Factory/data/ \</span><br><span class="line">    --template llama3 \</span><br><span class="line">    --finetuning_type lora \</span><br><span class="line">    --output_dir /home/ubuntu/model/Meta-Llama-3-8B-Instruct-predict/ \</span><br><span class="line">    --overwrite_cache \</span><br><span class="line">    --overwrite_output_dir \</span><br><span class="line">    --cutoff_len 1024 \</span><br><span class="line">    --preprocessing_num_workers 16 \</span><br><span class="line">    --per_device_eval_batch_size 1 \</span><br><span class="line">    --max_samples 20 \</span><br><span class="line">    --predict_with_generate</span><br></pre></td></tr></table></figure><p>与训练脚本主要的参数区别如下两个</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>do_predict</td><td>现在是预测模式</td></tr><tr><td>predict_with_generate</td><td>现在用于生成文本</td></tr><tr><td>max_samples</td><td>每个数据集采样多少用于预测对比</td></tr></tbody></table><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>其中 generated_predictions.jsonl 文件 输出了要预测的数据集的原始label和模型predict的结果</p><p>predict_results.json给出了原始label和模型predict的结果，用自动计算的指标数据</p><p>这里给相关的指标做一下进一步的解释</p><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>BLEU-4</td><td>BLEU（Bilingual Evaluation Understudy）是一种常用的用于评估机器翻译质量的指标。BLEU-4 表示四元语法 BLEU 分数，它衡量模型生成文本与参考文本之间的 n-gram 匹配程度，其中 n&#x3D;4。值越高表示生成的文本与参考文本越相似，最大值为 100。</td></tr><tr><td>predict_rouge-1 和 predict_rouge-2</td><td>ROUGE（Recall-Oriented Understudy for Gisting Evaluation）是一种用于评估自动摘要和文本生成模型性能的指标。ROUGE-1 表示一元 ROUGE 分数，ROUGE-2 表示二元 ROUGE 分数，分别衡量模型生成文本与参考文本之间的单个词和双词序列的匹配程度。值越高表示生成的文本与参考文本越相似，最大值为 100。</td></tr><tr><td>predict_rouge-l</td><td>ROUGE-L 衡量模型生成文本与参考文本之间最长公共子序列（Longest Common Subsequence）的匹配程度。值越高表示生成的文本与参考文本越相似，最大值为 100。</td></tr><tr><td>predict_runtime</td><td>预测运行时间，表示模型生成一批样本所花费的总时间。单位通常为秒。</td></tr><tr><td>predict_samples_per_second</td><td>每秒生成的样本数量，表示模型每秒钟能够生成的样本数量。通常用于评估模型的推理速度。</td></tr><tr><td>predict_steps_per_second</td><td>每秒执行的步骤数量，表示模型每秒钟能够执行的步骤数量。对于生成模型，一般指的是每秒钟执行生成操作的次数。</td></tr></tbody></table><h2 id="LoRA模型合并导出"><a href="#LoRA模型合并导出" class="headerlink" title="LoRA模型合并导出"></a><strong>LoRA模型合并导出</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把训练的LoRA和原始的大模型进行融合，输出一个完整的模型文件的话，可以使用如下命令。合并后的模型可以自由地像使用原始的模型一样应用到其他下游环节，当然也可以递归地继续用于训练</span><br><span class="line"></span><br><span class="line">CUDA_VISIBLE_DEVICES=0,1 llamafactory-cli export \</span><br><span class="line">     --model_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct  \</span><br><span class="line">    --adapter_name_or_path /home/ubuntu/model/Meta-Llama-3-8B-Instruct-savaModel/  \</span><br><span class="line">    --template llama3 \</span><br><span class="line">    --finetuning_type lora \</span><br><span class="line">    --export_dir /home/ubuntu/model/Meta-Llama-3-8B-Instruct-megred-model/ \</span><br><span class="line">    --export_size 2 \</span><br><span class="line">    --export_device cpu \</span><br><span class="line">    --export_legacy_format False</span><br></pre></td></tr></table></figure><h2 id="出GGUF，部署Ollama"><a href="#出GGUF，部署Ollama" class="headerlink" title="出GGUF，部署Ollama"></a>出GGUF，部署Ollama</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GGUF 是 lllama.cpp 设计的大模型存储格式，可以对模型进行高效的压缩，减少模型的大小与内存占用，从而提升模型的推理速度和效率。Ollama框架可以帮助用户快速使用本地的大型语言模型，那如何将LLaMA-Factory项目的训练结果 导出到Ollama中部署呢？需要经过如下几个步骤</span><br><span class="line"></span><br><span class="line">将lora模型合并</span><br><span class="line">安装gguf库</span><br><span class="line">使用llama.cpp的转换脚本将训练后的完整模型转换为gguf格式</span><br><span class="line">安装Ollama软件</span><br><span class="line">注册要部署的模型文件</span><br><span class="line">启动Ollama</span><br><span class="line">1-3 步是准备好 gguf格式的文件，这也是Ollama所需要的标准格式。</span><br><span class="line"></span><br><span class="line">4-6 步就是如何在Ollama环境中启动训练后的模型。</span><br></pre></td></tr></table></figure><h3 id="安装gguf库"><a href="#安装gguf库" class="headerlink" title="安装gguf库"></a>安装gguf库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装gguf库</span><br><span class="line"></span><br><span class="line">笔者发现直接 pip 安装 gguf，并不是最新的版本，和最新的转换脚本会不兼容，所以还是推荐从源码安装</span><br><span class="line"></span><br><span class="line">git clone https://github.com/ggerganov/llama.cpp.git</span><br><span class="line">cd llama.cpp/gguf-py</span><br><span class="line">pip install --editable </span><br></pre></td></tr></table></figure><h3 id="使用llama-cpp的转换脚本将训练后的完整模型转换为gguf格式"><a href="#使用llama-cpp的转换脚本将训练后的完整模型转换为gguf格式" class="headerlink" title="使用llama.cpp的转换脚本将训练后的完整模型转换为gguf格式"></a>使用llama.cpp的转换脚本将训练后的完整模型转换为gguf格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回 llama.cpp 项目根目录，会有一个官方提供的 convert-hf-to-gguf.py 脚本，用于完成huggingface格式到gguf格式的转换.</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">python convert_hf_to_gguf.py /home/ubuntu/model/Meta-Llama-3-8B-Instruct-megred-model --vocab-type hfft</span><br><span class="line">转换成功可在megred-model-path路径下得到如下的gguf文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/posts/33708.html"/>
      <url>/posts/33708.html</url>
      
        <content type="html"><![CDATA[<h1 id="同步通信和异步通信"><a href="#同步通信和异步通信" class="headerlink" title="同步通信和异步通信"></a>同步通信和异步通信</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同步通讯是指发送方在发送消息后，会等待接收方的回应，直到收到回应后才会继续执行后续操作</span><br><span class="line">异步通讯是指发送方在发送消息后，不需要等待接收方的立即回应，就可以继续执行其他操作。接收方在处理完消息后，可能会在未来的某个时间点给出回应</span><br></pre></td></tr></table></figure><h2 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241212190905564-3671bc.png" alt="image-20241212190905564"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一般来说，使用同步调用的场景都有一个特点：下一步操作依赖于上一步操作的结果</span><br><span class="line">同步调用的缺点：</span><br><span class="line">业务耦合</span><br><span class="line">性能较差</span><br><span class="line">级联失败</span><br></pre></td></tr></table></figure><h2 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">异步调用基于消息通知，一般包含三个角色消息</span><br><span class="line">    发送者：投递消息的人</span><br><span class="line">    消息代理：管理、暂存、转发消息的人</span><br><span class="line">    消息接收者：接收和处理消息的人</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241212193147411-011896.png" alt="image-20241212193147411"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">异步调用的优点</span><br><span class="line"><span class="number">1</span> 解除耦合，拓展性强</span><br><span class="line">即使以后有新业务拓充，支付服务只需要发送一条消息给消息代理，让消息代理通知新业务，拓展性强</span><br><span class="line"><span class="number">2</span> 无需等待，性能好</span><br><span class="line">支付服务完成之后只需要发送消息给消息代理，让消息代理通知其它服务</span><br><span class="line"><span class="number">3</span> 故障隔离</span><br><span class="line">即使交易服务出现了故障，也不会影响到支付服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">异步调用的缺点</span><br><span class="line"><span class="number">1</span> 不能得到调用结果</span><br><span class="line">异步调用一般是通知对方执行某个操作，无法知道对方执行操作后的结果</span><br><span class="line"><span class="number">2</span> 不确定下游业务执行是否成功</span><br><span class="line">异步调用通知下游业务后，无法知道下游业务是否执行成功</span><br><span class="line"><span class="number">3</span> 业务安全依赖于消息代理的可靠性</span><br><span class="line">下游业务的执行依赖于消息代理的可靠性，一旦消息代理出现故障，下游业务将无法执行</span><br></pre></td></tr></table></figure><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">搜索镜像</span><br><span class="line">sudo docker search rabbitmq</span><br><span class="line"></span><br><span class="line">下载镜像</span><br><span class="line">sudo docker pull rabbitmq</span><br><span class="line"></span><br><span class="line">启动</span><br><span class="line">sudo docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=curry \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=<span class="number">123456</span> \</span><br><span class="line"> -v rabbitmq-plugins:/plugins \</span><br><span class="line"> --name rabbitmq \</span><br><span class="line"> --hostname rabbitmq \</span><br><span class="line"> -p <span class="number">15672</span>:<span class="number">15672</span> \</span><br><span class="line"> -p <span class="number">5672</span>:<span class="number">5672</span> \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:latest</span><br><span class="line">     </span><br><span class="line">     docker run -e RABBITMQ_DEFAULT_USER=curry -e RABBITMQ_DEFAULT_PASS=<span class="number">123456</span> -v rabbitmq-plugins:/plugins --name rabbitmq --hostname rabbitmq -p <span class="number">15672</span>:<span class="number">15672</span> -p <span class="number">5672</span>:<span class="number">5672</span> -d rabbitmq:latest</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">指令说明：</span><br><span class="line">sudo docker run: 基本的Docker命令，用于启动一个新的容器实例</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=curry: 设置RabbitMQ服务的默认用户名为curry</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=<span class="number">123456</span>: 设置RabbitMQ服务的默认密码为<span class="number">123456</span></span><br><span class="line">-v rabbitmq-plugins:/plugins: 将一个名为rabbitmq-plugins的卷映射到容器的/plugins目录，用于存放RabbitMQ的插件。这里的rabbitmq-plugins是一个卷的名称，而不是宿主机的路径</span><br><span class="line">--name rabbitmq: 指定容器的名称为rabbitmq</span><br><span class="line">--hostname rabbitmq: 设置容器的主机名为rabbitmq</span><br><span class="line">-p <span class="number">15672</span>:<span class="number">15672</span>: 将宿主机的端口<span class="number">15672</span>映射到容器的端口<span class="number">15672</span>，这是RabbitMQ管理界面的默认端口</span><br><span class="line">-p <span class="number">5672</span>:<span class="number">5672</span>: 将宿主机的端口<span class="number">5672</span>映射到容器的端口<span class="number">5672</span>，这是RabbitMQ用于AMQP协议通信的默认端口</span><br><span class="line">-d: 在后台运行容器（守护进程）</span><br><span class="line">rabbitmq:latest: 使用最新的RabbitMQ官方镜像来创建容器</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">安装完成后就可以客户端访问相关地址页面了，http:<span class="comment">//127.0.0.1:15672/</span></span><br><span class="line"></span><br><span class="line">如果访问失败，可以进行下面尝试：安装 RabbitMQ 没有安装 Web 插件</span><br><span class="line">以下是 RabbitMQ 安装 Web 插件的方法</span><br><span class="line">第一步：进入容器内部</span><br><span class="line">sudo docker exec -it rabbitmq bash</span><br><span class="line">第二步：安装 Web 插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line">第三步：安装插件后退出容器内部</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-的整体架构和核心概念"><a href="#RabbitMQ-的整体架构和核心概念" class="headerlink" title="RabbitMQ 的整体架构和核心概念"></a>RabbitMQ 的整体架构和核心概念</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RabbitMQ 有几个核心概念：</span><br><span class="line">    Publisher：消息发送者</span><br><span class="line">    Consumer：消息的消费者</span><br><span class="line">    Queue：消息队列，存储消息，交换机只能路由和转发消息，不能存储消息</span><br><span class="line">    Exchange：交换机，负责路由消息</span><br><span class="line">    VirtualHost：虚拟主机，用于数据隔离，相当于一个数据库，彼此之间互不影响</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213150037105-b57a0b.png" alt="image-20241213150037105"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以通过web图形化界面进行管理，进行简单的消息转发操作，通常来说进入消息队列的操作是生产者把消息发送到交换机，然后交换机把消息发送给对应队列进行后续处理</span><br><span class="line"></span><br><span class="line">正常来说消息生产者和消费者都是由代码来进行绑定构建的</span><br></pre></td></tr></table></figure><ol><li><h3 id="新建队列"><a href="#新建队列" class="headerlink" title="新建队列"></a>新建队列</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213151714146-d3df32.png" alt="image-20241213151714146"></p><p>新建的两个队列</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213151802029-ff0d78.png" alt="image-20241213151802029"></p></li><li><h3 id="绑定队列和交换机"><a href="#绑定队列和交换机" class="headerlink" title="绑定队列和交换机"></a>绑定队列和交换机</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213151952985-ba42a3.png" alt="image-20241213151952985"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152042823-827bcc.png" alt="image-20241213152042823"></p><p>绑定后的结果<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152101303-c870f6.png" alt="image-20241213152101303"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152146176-f2986a.png" alt="image-20241213152146176"></p></li><li><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>在 amq.fanout 交换机中发送一条消息，消息的内容为 Hello, RabbitMQ!</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152226813-fc4fbc.png" alt="image-20241213152226813"></p></li><li><h3 id="查看消息"><a href="#查看消息" class="headerlink" title="查看消息"></a>查看消息</h3><p>发送消息后，查看交换机的总览信息</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152702548-65e224.png" alt="image-20241213152702548"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152734342-ab59f1.png" alt="image-20241213152734342"></p><p>查看交换的内容<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213152828853-48f69c.png" alt="image-20241213152828853"></p></li></ol><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">遇到的问题</span><br><span class="line">    交换机的 overview 页面没有折线图</span><br><span class="line">    Queues 页面也没有与消息相关的信息</span><br><span class="line">    点击channels后出现Stats in management UI are disabled on <span class="built_in">this</span> node信息</span><br><span class="line">    </span><br><span class="line">第一步：进入容器内部</span><br><span class="line">sudo docker exec -it rabbitmq bash</span><br><span class="line">第二步：修改配置</span><br><span class="line">cd /etc/rabbitmq/conf.d/</span><br><span class="line">echo management_agent.disable_metrics_collector = <span class="literal">false</span> &gt; management_agent.disable_metrics_collector.conf</span><br><span class="line">第三步：重启容器</span><br><span class="line">先退出容器内部</span><br><span class="line">exit</span><br><span class="line">再重启容器</span><br><span class="line">sudo docker restart rabbitmq</span><br></pre></td></tr></table></figure><h2 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq,数据隔离做法是构建不同的VirtualHost，不同的用户对这个区域有不同的权限，从而使得区域可以划分开</span><br></pre></td></tr></table></figure><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160213951-e5126c.png" alt="image-20241213160213951"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160303559-8f671f.png" alt="image-20241213160303559"></p><h3 id="新建VirtualHost"><a href="#新建VirtualHost" class="headerlink" title="新建VirtualHost"></a>新建VirtualHost</h3><p>用新建立的用户登录，新建自己的区域</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160524592-9d1be6.png" alt="image-20241213160524592"></p><h3 id="查看是否数据隔离"><a href="#查看是否数据隔离" class="headerlink" title="查看是否数据隔离"></a>查看是否数据隔离</h3><p>用新建立的用户登录，由于是管理员层次，可以查看其他队列，但是不能查看队列里面的详细信息，因为没有和其他模块里面的队列进行绑定</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160443622-91ef18.png" alt="image-20241213160443622"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160437322-3820ad.png" alt="image-20241213160437322"></p><p>不同的 VirtualHost 之间有不同的交换机</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160635755-44442f.png" alt="image-20241213160635755"></p><h1 id="项目中集成-RabbitMQ"><a href="#项目中集成-RabbitMQ" class="headerlink" title="项目中集成 RabbitMQ"></a>项目中集成 RabbitMQ</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringBoot：<span class="number">3.0</span><span class="number">.2</span></span><br><span class="line">JDK：<span class="number">17.0</span><span class="number">.7</span></span><br></pre></td></tr></table></figure><h2 id="AMQP-和-SpringAMQP"><a href="#AMQP-和-SpringAMQP" class="headerlink" title="AMQP 和 SpringAMQP"></a>AMQP 和 SpringAMQP</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意SpringAMQP是一个API标准，  其中spring-rabbit是具体实现</span><br><span class="line">SpringAMQP提供了三个功能:</span><br><span class="line">    自动声明队列、交换机及其绑定关系</span><br><span class="line">    基于注解的监听器模式，异步接收消息</span><br><span class="line">    封装了RabbitTemplate工具，用于发送消息</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241213160828013-9819fd.png" alt="image-20241213160828013"></p><h2 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>父工程完整依赖如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;consumer&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;publisher&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.0</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rabbitmq-demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;rabbitmq-demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;rabbitmq-demo&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">17</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">17</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h2 id="yml配置文件中设置"><a href="#yml配置文件中设置" class="headerlink" title="yml配置文件中设置"></a>yml配置文件中设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    virtual-host: /Jay</span><br><span class="line">    username: Jay</span><br><span class="line">    password: <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214151553453-9b6426.png" alt="image-20241214151553453"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在 RabbitMQ 的控制台中创建名为 test.queue 的队列（队列归属的 VirtualHost 为 /Jay）</span><br><span class="line">在 publisher 模块中，利用 SpringAMQP 直接向 test.queue 队列发送消息</span><br><span class="line">在 consumer 服务中，利用 SpringAMQP 编写消费者，监听 test.queue 队列</span><br></pre></td></tr></table></figure><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest(classes = PublisherApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testRabbitmq</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queName</span> <span class="operator">=</span> <span class="string">&quot;test.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,rabbitMQ!!!!!!!!!!!!!!!!!!!!!!&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(queName, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqListenerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;test.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者收到了 test.queue 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Work-Queues-模型"><a href="#Work-Queues-模型" class="headerlink" title="Work Queues 模型"></a>Work Queues 模型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Work Queues，简单地来说，就是让多个消费者绑定到一个队列，共同消费队列中的消息</span><br><span class="line">虽然有多个消费者绑定同一个队列，但是队列中的某一条消息只会被一个消费者消费</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214170807767-d3023d.png" alt="image-20241214170807767"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在RabbitMQ的控制台创建一个队列，名为 work.queue</span><br><span class="line">在 publisher 服务中定义测试方法，在 <span class="number">1</span> 秒内产生 <span class="number">50</span> 条消息，发送到work.queue</span><br><span class="line">在 consumer 服务中定义两个消息监听者，都监听 work.queue 队列</span><br><span class="line">消费者 <span class="number">1</span> 每秒处理 <span class="number">50</span> 条消息，消费者 <span class="number">2</span> 每秒处理 <span class="number">5</span> 条消息</span><br></pre></td></tr></table></figure><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>秒内发送产生五十条消息</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;这是一条队列消息，编号_&quot;</span> + i;</span><br><span class="line">            rabbitTemplate.convertAndSend(queName, msg);</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果有两个或两个以上的消费者监听同一个队列，默认情况下 RabbitMQ 会采用轮询的方法将消息分配给每个队列</span><br><span class="line">但每个消费者的消费能力可能是不一样的，我们给两个消费者中的代码设置不同的休眠时间，模拟消费能力的不同   </span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerWork1</span><span class="params">(String str)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1收到了 test.queue 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerWork2</span><span class="params">(String str)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消费者2收到了 test.queue 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="多劳多得原则"><a href="#多劳多得原则" class="headerlink" title="多劳多得原则"></a>多劳多得原则</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">配置信息相当于告诉消费者要一条一条地从队列中取出消息，只有处理完一条消息才能取出下一条。这样一来，就可以充分利用每一台机器的性能，让消费能力强的消费者处理更多的消息，同时还可以避免消息在消费能力较弱的消费者上发生堆积的情况</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span><span class="comment">#每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><h2 id="Fanout-交换机"><a href="#Fanout-交换机" class="headerlink" title="Fanout 交换机"></a>Fanout 交换机</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fanout 交换机会将接收到的消息广播到每一个跟其绑定的 queue ，所以也叫广播模式</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214172749741-6147b7.png" alt="image-20241214172749741"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 RabbitMQ 控制台中，声明队列 fanout.queue1 和 fanout.queue2</span><br><span class="line">在 RabbitMQ 控制台中，声明交换机 jay.fanout，将两个队列与其绑定</span><br><span class="line">在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2 队列</span><br><span class="line">在 publisher 服务中编写测试方法，向 blog.fanout 交换机发送消息</span><br></pre></td></tr></table></figure><h3 id="声明交换机"><a href="#声明交换机" class="headerlink" title="声明交换机"></a>声明交换机</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构建交换机和队列方法不在赘述，注意一点是交换机的类型确定，在下面的图中选择交换机，构建交换机并且绑定队列</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214172951857-0843aa.png" alt="image-20241214172951857"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214173057189-057090.png" alt="image-20241214173057189"></p><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于是广播消息，所以队列定义为NULL,随便定义队列也不会影响结果</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestFanout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;jay.fanout&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;向jay.fanout交换机里面发送广播消息&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="literal">null</span>, msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerFanout1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;消费者1收到了 fanout.queue1 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerFanout2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;消费者2收到了 fanout.queue2 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Direct 交换机会将接收到的消息根据规则路由到指定的队列，被称为定向路由</span><br><span class="line">    每一个 Queue 都与 Exchange 设置一个 bindingKey</span><br><span class="line">    发布者发送消息时，指定消息的 RoutingKey</span><br><span class="line">    Exchange 将消息路由到 bindingKey 与消息 routingKey 一致的队列</span><br><span class="line">    </span><br><span class="line">同一个队列可以绑定多个 bindingKey ，如果有多个队列绑定了同一个 bindingKey ，就可以实现类似于 Fanout 交换机的效果。由此可以看出，Direct 交换机的功能比 Fanout 交换机更强大</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214175902008-54e91f.png" alt="image-20241214175902008"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Direct 交换机的效果，案例要求如下：</span><br><span class="line"></span><br><span class="line">在 RabbitMQ 控制台中，声明队列 direct.queue1 和 direct.queue2</span><br><span class="line">在 RabbitMQ 控制台中，声明交换机 jay.direct ，将上面创建的两个队列与其绑定</span><br><span class="line">在 consumer 服务中，编写两个消费者方法，分别监听 direct.queue1 和 direct.queue2</span><br><span class="line">在 publisher 服务中编写测试方法，利用不同的 RoutingKey 向 blog.direct 交换机发送消息</span><br></pre></td></tr></table></figure><p>在创建交换机时候，需要绑定路由键，绑定结果如下图所示：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214180603006-62fc59.png" alt="image-20241214180603006"></p><h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestDirect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;jay.direct&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;红色警报&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="string">&quot;蓝色警报&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, msg1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="string">&quot;黄色警报&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;yellow&quot;</span>, msg2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirect1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1收到了 direct.queue1 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirect2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消费者2收到了 direct.queue2 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Topic-交换机（推荐使用）"><a href="#Topic-交换机（推荐使用）" class="headerlink" title="Topic 交换机（推荐使用）"></a>Topic 交换机（推荐使用）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Topic Exchange 与 Direct Exchange类似，区别在于 Topic Exchange 的 routingKey 可以是多个单词的列表（多个 routingKey 之间以.分割）</span><br><span class="line"></span><br><span class="line">Queue 与 Exchange 指定 bindingKey 时可以使用通配符</span><br><span class="line">#：代指 <span class="number">0</span> 个或多个单词</span><br><span class="line">*：代指 <span class="number">1</span> 个单词</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214204415059-b51cd4.png" alt="image-20241214204415059"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 RabbitMQ 控制台中，声明队列 topic.queue1 和 topic.queue2</span><br><span class="line">在 RabbitMQ 控制台中，声明交换机 jay.topic ，将两个队列与其绑定</span><br><span class="line">在 consumer 服务中编写两个消费者方法，分别监听 topic.queue1 和 topic.queue2</span><br><span class="line">在 publisher 服务中编写测试方法，利用不同的 routingKey 向 blog.topic 发送消息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>绑定效果如下<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241214204728004-c6d0d9.png" alt="image-20241214204728004"></p><h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestTopic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;jay.topic&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;西交新闻播报&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;xjtu.news&quot;</span>, msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="string">&quot;中国新闻播报&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;China.news&quot;</span>, msg1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="string">&quot;中国天气&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;China.weather&quot;</span>, msg2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerTopic1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;消费者1收到了 topic.queue1 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerTopic2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       System.err.println(<span class="string">&quot;消费者2收到了 topic.queue2 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="在-SpringBoot-项目中声明队列和交换机的方式"><a href="#在-SpringBoot-项目中声明队列和交换机的方式" class="headerlink" title="在 SpringBoot 项目中声明队列和交换机的方式"></a>在 SpringBoot 项目中声明队列和交换机的方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringAMQP 提供了几个类，用来声明队列、交换机及其绑定关系：</span><br><span class="line"></span><br><span class="line">Queue：用于声明队列，可以用工厂类 QueueBuilder 构建</span><br><span class="line">Exchange：用于声明交换机，可以用工厂类 ExchangeBuilder 构建</span><br><span class="line">Binding：用于声明队列和交换机的绑定关系，可以用工厂类 BindingBuilder 构建</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241215154358138-a87254.png" alt="image-20241215154358138"></p><h3 id="配置类声明—编程式声明"><a href="#配置类声明—编程式声明" class="headerlink" title="配置类声明—编程式声明"></a>配置类声明—编程式声明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主要有两种构建方式，一种是直接生成<span class="keyword">new</span>一个队列或者交换机进行返回，另一种使用Builder进行构建</span><br><span class="line">    </span><br><span class="line">创建 Queue 时，如果没有指定 durable 属性，则 durable 属性默认为 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;jay.fanout1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout1.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutQueueExchange1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="string">&quot;jay.fanout2&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;fanout1.queue2&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutQueueExchange2</span><span class="params">(Queue fanoutQueue2,FanoutExchange fanoutExchange2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解式声明（推荐使用）"><a href="#注解式声明（推荐使用）" class="headerlink" title="注解式声明（推荐使用）"></a>注解式声明（推荐使用）</h3><p>直接使用注解方法进行声明构建，分别声明队列名称，交换机以及路由键</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">           value = @Queue(name = &quot;direct3.queue&quot;),</span></span><br><span class="line"><span class="meta">           exchange = @Exchange(name = &quot;jay3.direct&quot;,type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">           key = &#123;&quot;wky&quot;,&quot;hyc&quot;&#125;</span></span><br><span class="line"><span class="meta">   ))</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirect3</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       System.err.println(<span class="string">&quot;消费者1收到了 direct3.queue 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">           value = @Queue(name = &quot;direct4.queue&quot;),</span></span><br><span class="line"><span class="meta">           exchange = @Exchange(name = &quot;jay3.direct&quot;,type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">           key = &#123;&quot;gyh&quot;,&quot;hyc&quot;&#125;</span></span><br><span class="line"><span class="meta">   ))</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirect4</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       System.err.println(<span class="string">&quot;消费者2收到了 direct4.queue 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="消息对象转换器"><a href="#消息对象转换器" class="headerlink" title="消息对象转换器"></a>消息对象转换器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">发送一个对象消息，类似如下所示：</span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Object.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;12131&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>,<span class="number">11111</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发送消息成功后，在控制台查看消息的具体内容，发现查看消息为乱码</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20241223194742722-9c6d06.png" alt="image-20241223194742722"></p><p>Spring 处理对象类型的消息是由org.springframework.amap.support.converter.MessageConverter 接口来处理的，该接口默认实现是 SimpleMessageConverter</p><p>SimpleMessageConverter 类是基于 JDK 提供的 ObjectOutputStream 来类完成序列化的，这种序列化方式存在以下问题:</p><ol><li><p>使用 JDK 序列化有安全风险（如果序列化后的消息被恶意篡改，在反序列化的过程中可能会执行一些高危的代码）</p></li><li><p>经过 JDK 序列化的消息占用空间很大</p></li><li><p>经过 JDK 序列化的消息可读性很差</p></li></ol><h3 id="自定义消息转换器"><a href="#自定义消息转换器" class="headerlink" title="自定义消息转换器"></a>自定义消息转换器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">如果是 Web 项目，无需引入该依赖，因为 spring-boot-starter-web 依赖中已包含该依赖</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者和生产者配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jacksonMessageConvertor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="发送者的可靠性"><a href="#发送者的可靠性" class="headerlink" title="发送者的可靠性"></a>发送者的可靠性</h2><h3 id="生产者的重连–连接失败的处理办法"><a href="#生产者的重连–连接失败的处理办法" class="headerlink" title="生产者的重连–连接失败的处理办法"></a>生产者的重连–连接失败的处理办法</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">发送消息时候进行重试</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/Jay</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">Jay</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="comment">#加上下面的内容</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启连接超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 连接失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 连接失败后的等待时长倍数，下次等待时长 = (initial-interval) * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率，但 SpringAMOP 提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，线程会被阻塞，影响业务性能，后续的操作没办法继续往下执行。</li><li>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长（比如 200 ms）和重试次数，也可以考虑使用异步线程来执行发送消息的代码</li></ol></blockquote><h3 id="生产者的确认"><a href="#生产者的确认" class="headerlink" title="生产者的确认"></a>生产者的确认</h3><p>重点在消息发送失败后怎么办，开启确认机制后，MQ收到消息后会返回确认消息给生产者。</p><ul><li>当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息，同时返回ack的确认信息，代表投<br>递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中ack和nack属于Publisher Confirm机制，ack是投递成功；nack是投递失败。而return则属于<br>Publisher Return机制。</p><h4 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure><p>publisher-confirm-type 有三种模式：</p><ol><li>none：关闭 confirm 机制</li><li>simple：以同步阻塞等待的方式返回 MQ 的回执消息</li><li>correlated：以异步回调方式的方式返回 MQ 的回执消息</li></ol><h4 id="定义ReturnsCallback"><a href="#定义ReturnsCallback" class="headerlink" title="定义ReturnsCallback"></a>定义ReturnsCallback</h4><p>通过实现 ApplicationContextAware 获取到rabbitTemplate 的bean对象，也有其他实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在publisher模块中创建一个配置类，在其中集中设置一个ReturnCallback，确保所有使用该 RabbitTemplate 的地方都能使用同一个回调处理逻辑。这种方式可以让你集中管理RabbitMQ消息投递失败时的处理，而不需要在每个发送消息的地方都单独配置。</span></span><br><span class="line"><span class="comment">        当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setReturnsCallback(returnedMessage -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到消息的return callback, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;exchange = &quot;</span> + returnedMessage.getExchange() + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;routingKey = &quot;</span> + returnedMessage.getRoutingKey() + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;replyCode = &quot;</span> + returnedMessage.getReplyCode() + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;replyText = &quot;</span> + returnedMessage.getReplyText() + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;message = &quot;</span> + returnedMessage.getMessage());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">//它主要用于类,在bean被创建并完成属性注入后，执行一些初始化操作(带有@PostConstruct 注解的方法会被自动调用。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestDirectConfire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;jay.direct&quot;</span>;</span><br><span class="line">       <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">       <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">       correlationData.getFuture().whenCompleteAsync((confirm, throwable) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (confirm.isAck()) &#123;</span><br><span class="line">               <span class="comment">// 消息发送成功</span></span><br><span class="line">               System.out.println(<span class="string">&quot;消息发送成功，收到ack&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 消息发送失败</span></span><br><span class="line">               System.err.println(<span class="string">&quot;消息发送失败，收到nack，原因是&quot;</span> + confirm.getReason());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 消息回调失败</span></span><br><span class="line">               System.err.println(<span class="string">&quot;消息回调失败&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;红色警报&quot;</span>;</span><br><span class="line">       rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, msg,correlationData);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 测试方法执行结束后程序就结束了，所以这里需要阻塞线程，否则程序看不到回调结果</span></span><br><span class="line">       Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当开启确认后，对每条消息都要进行确认，会降低MQ队列的处理效率</span><br></pre></td></tr></table></figure><h2 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h2><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><h4 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h4><p>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/02/image-20250302173603498-b735ee.png" alt="image-20250302173603498"></p><p>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</p><h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/02/image-20250302173634748-aeda02.png" alt="image-20250302173634748"></p><h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/02/image-20250302173708763-dc992e.png" alt="image-20250302173708763"></p><blockquote><p>spring默认进行发消息或者创建队列，创建交换机都是持久化的</p></blockquote><p>持久化因为每次都要写到磁盘里面，所以速度会慢一点，但是由于存储到磁盘当中，不会出现阻塞问题</p><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为PageOut·PageOut会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了LazyQueues的模式，也就是情性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h4 id="控制台设置lazyQueue"><a href="#控制台设置lazyQueue" class="headerlink" title="控制台设置lazyQueue"></a>控制台设置lazyQueue</h4><p>在添加队列的时候，添加x-queue-mod &#x3D; lazy 参数即可以设置队列为lazy模式</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/15/image-20250315153136801-ba0d4a.png" alt="image-20250315153136801"></p><h4 id="代码模式配置lazy"><a href="#代码模式配置lazy" class="headerlink" title="代码模式配置lazy"></a>代码模式配置lazy</h4><p>代码模式配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">Lazy</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;lazy.queue2&quot;</span>).lazy().build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注解模式配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;Lazy1.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;jay3.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">            arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LazyQueue</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;消费者2收到了 Lazy1.queue 的消息：【&quot;</span> + str + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="更新现有队列成lazy模式"><a href="#更新现有队列成lazy模式" class="headerlink" title="更新现有队列成lazy模式"></a>更新现有队列成lazy模式</h4><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/15/asynccode-894ab0.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在RabbitMQ中，消息的持久性是由消息本身和队列的持久性决定的。如果消息没有被标记为持久化，那么即使队列本身是持久化的，在RabbitMQ服务器重启后，这些消息也会丢失。这里的关键点在于：</span><br><span class="line"><span class="number">1.</span>队列的持久性：持久化队列意味着队列的元数据（例如队列的名称、绑定关系等）会被存储到磁盘中，在RabbitMQ服务器重启时可以恢复队列的结构。但是，队列本身的持久性并不自动意味着队列中的消息会被持久化。</span><br><span class="line"><span class="number">2.</span>消息的持久性：如果消息在发送时没有设置为持久化，即没有将delivery_mode设置为<span class="number">2</span>（即持久化)，则这些消息只会保存在内存中。当RabbitMQ服务器重启时，这些未持久化的消息会丢失，尽管队列本身可能被恢复。</span><br><span class="line"><span class="number">3.</span> LazyQueue：LazyQueue是一种优化机制，它使得消息以最少的内存使用保存在磁盘上，即使是普通（非持久化）消息，也可以在磁盘中存储，避免过多占用内存。它并不改变消息持久性的属性。也就是说，即使队列是Lazy类型的，如果消息没有被标记为持久化，消息仍然会在服务器重启时丢失。</span><br><span class="line">总结</span><br><span class="line">-队列持久化：保存队列结构。</span><br><span class="line">-消息持久化：确保消息在RabbitMQ重启后不丢失。</span><br><span class="line">-LazyQueue：优化内存使用，减少对RAM的依赖，但消息如果未持久化，仍会丢失。</span><br><span class="line">所以，即使是LazyQueue，如果消息没有被标记为持久化，那么这些消息在RabbitMQ服务器重启后仍然会丢失。</span><br></pre></td></tr></table></figure><h2 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h2><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code>;</li></ul></li></ul><p>返回Reject的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<Foo> but Message<Bar> is received.</li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理 </span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 手动模式</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动处理机制</span></span><br></pre></td></tr></table></figure><h3 id="失败消息处理策略"><a href="#失败消息处理策略" class="headerlink" title="失败消息处理策略"></a>失败消息处理策略</h3><p>处理机制</p><p>为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><p>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>重启consumer服务，重复之前的测试。可以发现：</p><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/16/image-20250316174949291-8625d5.png" alt="image-20250316174949291"></p><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队 </li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>分别定义交换机和RepublishMessageRecoverer，然后运行，会发现运行失败后保存到error队列当中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener.simple.retry&quot;,name = &quot;enabled&quot;,havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingError</span><span class="params">(Queue errorQueue, DirectExchange errorExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/16/image-20250316175327512-89c89a.png" alt="image-20250316175327512"></p><h2 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h2><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><h3 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h3><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一ID呢？</p><p>其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><h3 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h3><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？</p><p>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>其实思想很简单：既然MQ通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的MQ通知失败，我们依然能通过主动查询来保证订单状态的一致。</p><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>一段时间以后才执行的任务，称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h3 id="死信交换机-不推荐"><a href="#死信交换机-不推荐" class="headerlink" title="死信交换机(不推荐)"></a>死信交换机(不推荐)</h3><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>即就把一个队列消息保存成无人消费，设置消息存在时间，如果真的没人消费，就会保存到死信交换机当中</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/16/image-20250316195146167-700cec.png" alt="image-20250316195146167"></p><h3 id="延迟消息插件（推荐使用"><a href="#延迟消息插件（推荐使用" class="headerlink" title="延迟消息插件（推荐使用"></a>延迟消息插件（推荐使用</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.13.0">插件地址</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在输出信息中找到 Mounts ，再找到 RabbitMQ 的插件的安装目录</span><br><span class="line"></span><br><span class="line">sudo docker inspect rabbitmq</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/16/image-20250316195607538-3ee144.png" alt="image-20250316195607538"></p><p>一般与 docker 相关的目录只有 root 用户才有权限访问，所以我们需要先打开 docker 目录的部分权限（耗时可能较长）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod +rx -R /var/lib/docker</span><br><span class="line">接着打开/var/lib/docker/volumes/rabbitmq-plugins/_data目录的写权限（如果修改权限不生效，请切换到 root 用户执行指令）</span><br><span class="line">sudo chmod 777 /var/lib/docker/volumes/rabbitmq-plugins/_data</span><br><span class="line">将刚才下载的插件上传到/var/lib/docker/volumes/rabbitmq-plugins/_data目录</span><br><span class="line">上传成功后将/var/lib/docker/volumes/rabbitmq-plugins/_data目录的权限复原</span><br><span class="line">sudo chmod 755 /var/lib/docker/volumes/rabbitmq-plugins/_data</span><br><span class="line"></span><br><span class="line">最后进入容器内部，运行指令安装插件，安装完成后退出容器内部</span><br><span class="line">sudo docker exec -it rabbitmq bash</span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line">exit</span><br><span class="line">看到以下信息，说明插件安装成功了</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/16/image-20250316201329586-57dd6e.png" alt="image-20250316201329586"></p><h4 id="在-Java-代码中发送延迟消息"><a href="#在-Java-代码中发送延迟消息" class="headerlink" title="在 Java 代码中发送延迟消息"></a>在 Java 代码中发送延迟消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayQueue</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line">    simpleDateFormat.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者收到了 delay.queue的消息: &quot;</span> + message + <span class="string">&quot;，时间：&quot;</span> + simpleDateFormat.format(System.currentTimeMillis()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, <span class="string">&quot;Hello, DelayQueue!&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">10000</span>); <span class="comment">// 毫秒</span></span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line">    simpleDateFormat.applyPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息成功！发送时间：&quot;</span> + simpleDateFormat.format(System.currentTimeMillis()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring中来配置的一个属性，一个注解，来判断当一个值为多少的时候，这个注解下面的方法或者类才进行注册到spring池子当中</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.rabbitmq.listener.simple.retry&quot;,name = &quot;enabled&quot;,havingValue = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo相册构建</title>
      <link href="/posts/29704.html"/>
      <url>/posts/29704.html</url>
      
        <content type="html"><![CDATA[<h1 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h1><ul><li>为博客添加相册功能</li><li>通过GitHub来实现相册功能</li></ul><p>二、方案<br>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理<br>将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出<br>修改代码（大佬写好的）<br>使用py脚本压缩图片生成略缩图</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github作为Typora图床搭建</title>
      <link href="/posts/25733.html"/>
      <url>/posts/25733.html</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub仓库设置"><a href="#GitHub仓库设置" class="headerlink" title="GitHub仓库设置"></a>GitHub仓库设置</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/e137f289601a9e75868f5a8845b5a638-image-20250110160959878-87c7f0.png" alt="image-20250110160959878"></p><h2 id="创建token"><a href="#创建token" class="headerlink" title="创建token"></a>创建token</h2><p>然后创建Token，点击链接：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p><p>进入Token创建页面：</p><p>然后点击<code>Generate new token</code>进行Token创建：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/cf1701c05abc41f2c53b24e610c6734f-image-20250110161402230-ea0f7d.png" alt="image-20250110161402230"></p><blockquote><h3 id="记得复制这块内容，token-，教程说离开这个页面后就找不到它了"><a href="#记得复制这块内容，token-，教程说离开这个页面后就找不到它了" class="headerlink" title="记得复制这块内容，token,，教程说离开这个页面后就找不到它了"></a><strong>记得复制这块内容，token,，教程说离开这个页面后就找不到它了</strong></h3></blockquote><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/a64c4807f8becfc04b5f538eb3751c67-image-20250110161437748-895a26.png" alt="image-20250110161437748"></p><h1 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载<a href="https://gitcode.com/gh_mirrors/pi/PicGo?utm_source=highlight_word_gitcode&word=picgo&isLogin=1">PicGo</a></h1><p>首先下载PicGo，下载地址：<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></p><p>安装后记住PicGo的安装目录。</p><p>然后进行PicGo的设置，首先打开PicGo，然后选择图床设置–》GitHub图床：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/16/image-20250116145910792-19d7f8.png" alt="image-20250116145910792"></p><h2 id="详细设置项如下："><a href="#详细设置项如下：" class="headerlink" title="详细设置项如下："></a>详细设置项如下：</h2><ul><li><p>设定仓库名，设置规则为your-github-username&#x2F;image-repo，即你的GitHub帐户名&#x2F;图床仓库名；</p></li><li><p>设定分支名，默认为master就好；</p></li><li><p>设定Token：就是刚刚保存的Token，复制粘贴进这里就好；</p></li><li><p>指定存储路径：可以设置图片存储在仓库的哪个目录下，这里就设置为图片存储在仓库的PicGo目录；</p></li><li><p>设定自定义域名：为了使用jsdeliver进行加速，此处设置规则为：<a href="https://cdn.jsdelivr.net/gh/%E5%B8%90%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@main%EF%BC%9B">https://cdn.jsdelivr.net/gh/帐户名/图床仓库名@main；</a></p></li></ul><p>记得确定以及设置为默认仓库</p><h1 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h1><p>首先打开Typora的设置面板（文件 — — 偏好设置），找到图像一栏，设置如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/16/image-20250116150000074-00503d.png" alt="image-20250116150000074"></p><h1 id="安装PicGo插件"><a href="#安装PicGo插件" class="headerlink" title="安装PicGo插件"></a>安装PicGo插件</h1><p>如果我们只是简单地使用PicGo进行图片上传，那么我们无法上传同名的图片，所以我们需要安装插件，对图片进行重命名。在PicGo中选择插件设置，搜索<code>rename-file</code>进行安装</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/24986d95c74e85238a5f29ea0b9f023f-image-20250111150002654-8d1094.png" alt="image-20250111150002654"></p><p>如果面板没有，可以CD到PicGo目录下面，对目录里面进行npm intsall 响应插件</p><h2 id="安装两款插件"><a href="#安装两款插件" class="headerlink" title="安装两款插件"></a>安装两款插件</h2><p>第一款是重命名插件</p><p>第二款是githubPlus插件能支持同步删除。<code>githubPlus</code>可以同步相册,当在PigGo的相册中删除图片后,会同步删除github上的图片.</p><h1 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h1><p>一般在本地保存一份图片，当保存成功后，上传到图床，这样图床即没有冗余内容，也可以在本地保存一份内容</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/a288615fb61c6f3b98e73ed8fd628b23-image-20250111150452176-81a67f.png" alt="image-20250111150452176"></p><p>即还是在本地中保存图片，然后当你的文章写完后，再通过<strong>格式—》图像—》上传所有本地图片</strong>，将文章中的图片一次性上传。这样我们在本地也保存了一份图片，更加保险；而且文章写完后再将所有的图片上传，这样GitHub保存的图片都是有用的，不至于让无用的图片占据图床仓库空间</p><h1 id="我的操作"><a href="#我的操作" class="headerlink" title="我的操作"></a>我的操作</h1><p>上传完成后，如果图片没用，那么就去picgo里面删除掉吧，这样来回转换我记不住啊</p><h1 id="后续使用问题"><a href="#后续使用问题" class="headerlink" title="后续使用问题"></a>后续使用问题</h1><p>发现当加速器满足50M的时候，不让进行免费加速，所以我后续进行了替换，不再使用加速器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Package size exceeded the configured limit of 50 MB. Try https://github.com/Curry-jay/image-store/tree/main/PicGo/2025/04/25/image-20250425154923397-a12d97.png instead.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/Curry-jay/image-store@main</span><br><span class="line">替换成</span><br><span class="line">https://raw.githubusercontent.com/Curry-jay/image-store/main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓开发</title>
      <link href="/posts/65065.html"/>
      <url>/posts/65065.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="查看错误信息"><a href="#查看错误信息" class="headerlink" title="查看错误信息"></a>查看错误信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按等级</span><br><span class="line">1、Log.v 的调试，任何消息都会输出，这里的v代表verbose的意思，平时使用就是Log.v(&quot;&quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">2、Log.d的调试，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过Logcat标签来选择.</span><br><span class="line"></span><br><span class="line">3、Log.i的调试，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息</span><br><span class="line"></span><br><span class="line">4、Log.w的调试，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。</span><br><span class="line"></span><br><span class="line">5、Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231021150236150-151c2b.png" alt="image-20231021150236150"></p><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分为两种类型，一个是项目级别的build.gradle,指定了当前项目的总体编译规则，</span><br><span class="line">模块级别的build,gradle对应与具体模块，每个模块都有自己的build,gradle，它指定了当前模块的详细编译规则</span><br></pre></td></tr></table></figure><h2 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231021204221068-43e437.png" alt="image-20231021204221068"></p><h1 id="AndroidStudio"><a href="#AndroidStudio" class="headerlink" title="AndroidStudio"></a>AndroidStudio</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231018171239397-44643f.png" alt="image-20231018171239397"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231018171246332-09551a.png" alt="image-20231018171246332"></p>]]></content>
      
      
      <categories>
          
          <category> 学校学习 </category>
          
          <category> xjtu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xjtu </tag>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向</title>
      <link href="/posts/36721.html"/>
      <url>/posts/36721.html</url>
      
        <content type="html"><![CDATA[<h1 id="初识APK文件结构、双开、汉化、基础修改"><a href="#初识APK文件结构、双开、汉化、基础修改" class="headerlink" title="初识APK文件结构、双开、汉化、基础修改"></a>初识APK文件结构、双开、汉化、基础修改</h1><h2 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h2><p>apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。</p><table><thead><tr><th align="left">文件</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">assets目录</td><td align="left">存放APK的静态资源文件，比如视频，音频，图片等</td></tr><tr><td align="left">lib 目录</td><td align="left">armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件</td></tr><tr><td align="left">META-INF目录</td><td align="left">保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改)</td></tr><tr><td align="left">res目录</td><td align="left">res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计</td></tr><tr><td align="left">AndroidMainfest.xml文件</td><td align="left">APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息</td></tr><tr><td align="left">classes.dex文件</td><td align="left">classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑</td></tr><tr><td align="left">resources.arsc文件</td><td align="left">resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td></tr></tbody></table><h2 id="双开及原理–当前学习只使用了第一个"><a href="#双开及原理–当前学习只使用了第一个" class="headerlink" title="双开及原理–当前学习只使用了第一个"></a>双开及原理–当前学习只使用了第一个</h2><p>双开：简单来说，就是手机同时运行两个或多个相同的应用，例如同时运行两个微信</p><table><thead><tr><th align="left">原理</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">修改包名</td><td align="left">让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td></tr><tr><td align="left">修改Framework</td><td align="left">对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td></tr><tr><td align="left">通过虚拟化技术实现</td><td align="left">虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td></tr><tr><td align="left">以插件机制运行</td><td align="left">利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td></tr></tbody></table><h2 id="汉化APK"><a href="#汉化APK" class="headerlink" title="汉化APK"></a>汉化APK</h2><p>汉化：使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化</p><p><strong>基本上字符串都是在arsc里，建议一键汉化，然后再润色。<br>少量没汉化到的字符串参考视频中的方法定位去逐个汉化。</strong></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231107140413865-44c174.png" alt="image-20231107140413865"></p><h2 id="初识AndroidManifest-xml"><a href="#初识AndroidManifest-xml" class="headerlink" title="初识AndroidManifest.xml"></a>初识AndroidManifest.xml</h2><p>AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p><table><thead><tr><th align="left">属性</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">versionCode</td><td align="left">版本号，主要用来更新，例如:12</td></tr><tr><td align="left">versionName</td><td align="left">版本名，给用户看的，例如:1.2</td></tr><tr><td align="left">package</td><td align="left">包名，例如：com.zj.52pj.demo</td></tr><tr><td align="left">uses-permission android:name&#x3D;””</td><td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td align="left">android:label&#x3D;”@string&#x2F;app_name”</td><td align="left">应用名称</td></tr><tr><td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td><td align="left">应用图标路径</td></tr><tr><td align="left">android:debuggable&#x3D;”true”</td><td align="left">应用是否开启debug权限</td></tr></tbody></table><h1 id="初识smali，vip终结者"><a href="#初识smali，vip终结者" class="headerlink" title="初识smali，vip终结者"></a>初识smali，vip终结者</h1><h2 id="什么是JVM、Dalvik、ART"><a href="#什么是JVM、Dalvik、ART" class="headerlink" title="什么是JVM、Dalvik、ART"></a>什么是JVM、Dalvik、ART</h2><p>JVM是JAVA虚拟机，运行JAVA字节码程序<br>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)<br>Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异</p><h2 id="smali及其语法"><a href="#smali及其语法" class="headerlink" title="smali及其语法"></a>smali及其语法</h2><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table><thead><tr><th align="left">名称</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">.class</td><td align="left">类名</td></tr><tr><td align="left">.super</td><td align="left">父类名，继承的上级类名名称</td></tr><tr><td align="left">.source</td><td align="left">源名</td></tr><tr><td align="left">.field</td><td align="left">变量</td></tr><tr><td align="left">.method</td><td align="left">方法名</td></tr><tr><td align="left">.register</td><td align="left">寄存器</td></tr><tr><td align="left">.end method</td><td align="left">方法名的结束</td></tr><tr><td align="left">public</td><td align="left">公有</td></tr><tr><td align="left">protected</td><td align="left">半公开，只有同一家人才能用</td></tr><tr><td align="left">private</td><td align="left">私有，只能自己使用</td></tr><tr><td align="left">.parameter</td><td align="left">方法参数</td></tr><tr><td align="left">.prologue</td><td align="left">方法开始</td></tr><tr><td align="left">.line xxx</td><td align="left">位于第xxx行</td></tr></tbody></table><h3 id="数据类型对应"><a href="#数据类型对应" class="headerlink" title="数据类型对应"></a>数据类型对应</h3><table><thead><tr><th align="left">smali类型</th><th align="left">java类型</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">V</td><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">Z</td><td align="left">boolean</td><td align="left">布尔值类型，返回0或1</td></tr><tr><td align="left">B</td><td align="left">byte</td><td align="left">字节类型，返回字节</td></tr><tr><td align="left">S</td><td align="left">short</td><td align="left">短整数类型，返回数字</td></tr><tr><td align="left">C</td><td align="left">char</td><td align="left">字符类型，返回字符</td></tr><tr><td align="left">I</td><td align="left">int</td><td align="left">整数类型，返回数字</td></tr><tr><td align="left">J</td><td align="left">long （64位 需要2个寄存器存储）</td><td align="left">长整数类型，返回数字</td></tr><tr><td align="left">F</td><td align="left">float</td><td align="left">单浮点类型，返回数字</td></tr><tr><td align="left">D</td><td align="left">double （64位 需要2个寄存器存储）</td><td align="left">双浮点类型，返回数字</td></tr><tr><td align="left">string</td><td align="left">String</td><td align="left">文本类型，返回字符串</td></tr><tr><td align="left">Lxxx&#x2F;xxx&#x2F;xxx</td><td align="left">object</td><td align="left">对象类型，返回对象</td></tr></tbody></table><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><table><thead><tr><th align="left">关键字</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">const</td><td align="left">重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td align="left">const-string</td><td align="left">重写字符串内容</td></tr><tr><td align="left">const-wide</td><td align="left">重写长整数类型，多用于修改到期时间。</td></tr><tr><td align="left">return</td><td align="left">返回指令</td></tr><tr><td align="left">if-eq</td><td align="left">全称equal(a&#x3D;b)，比较寄存器ab内容，相同则跳</td></tr><tr><td align="left">if-ne</td><td align="left">全称not equal(a!&#x3D;b)，ab内容不相同则跳</td></tr><tr><td align="left">if-eqz</td><td align="left">全称equal zero(a&#x3D;0)，z即是0的标记，a等于0则跳</td></tr><tr><td align="left">if-nez</td><td align="left">全称not equal zero(a!&#x3D;0)，a不等于0则跳</td></tr><tr><td align="left">if-ge</td><td align="left">全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳</td></tr><tr><td align="left">if-le</td><td align="left">全称little equal(a&lt;&#x3D;b)，a小于或等于则跳</td></tr><tr><td align="left">goto</td><td align="left">强制跳到指定位置</td></tr><tr><td align="left">switch</td><td align="left">分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td align="left">iget</td><td align="left">获取寄存器数据</td></tr></tbody></table><p>其余指令可用语法工具查询</p><p>定位方法：搜索弹窗关键字、抓取按钮id</p><h2 id="逆向修改关键"><a href="#逆向修改关键" class="headerlink" title="逆向修改关键"></a>逆向修改关键</h2><p>修改方法：修改判断、强制跳转、修改寄存器的值</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231107145611048-a59f2f.png" alt="image-20231107145611048"></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>在smali里的所有操作都必须经过寄存器来进行:本地寄存器用v开头数字结尾的符号来表示，如v0、 v1、v2。 参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2。特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个 参数，p2代表函数中的第二个参数。而在static函数中p0才对应第一个参数(因为Java的static方法中没有this方法）</p><h1 id="第四节-恭喜你获得广告-弹窗静默卡"><a href="#第四节-恭喜你获得广告-弹窗静默卡" class="headerlink" title="第四节.恭喜你获得广告&amp;弹窗静默卡"></a>第四节.恭喜你获得广告&amp;弹窗静默卡</h1><h2 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h2><table><thead><tr><th align="left">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Activity(活动)</td><td align="left">在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。</td></tr><tr><td align="left">Service(服务)</td><td align="left">Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。</td></tr><tr><td align="left">Broadcast Receiver(广播接收器)</td><td align="left">一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。</td></tr><tr><td align="left">Content Provider(内容提供者)</td><td align="left">作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等）</td></tr></tbody></table><h3 id="activity的切换"><a href="#activity的切换" class="headerlink" title="activity的切换"></a>activity的切换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 &lt;activity&gt; 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。-----&gt;</span><br><span class="line">      &lt;activity  </span><br><span class="line">          android:label=<span class="string">&quot;@string/app_name&quot;</span>  </span><br><span class="line">          android:name=<span class="string">&quot;com.zj.wuaipojie.ui.MainActivity&quot;</span>  </span><br><span class="line">          android:exported=<span class="string">&quot;true&quot;</span>&gt;  &lt;!--当前Activity是否可以被另一个Application的组件启动：<span class="literal">true</span>允许被启动；<span class="literal">false</span>不允许被启动--&gt;</span><br><span class="line">          &lt;!---指明这个activity可以以什么样的意图(intent)启动---&gt;</span><br><span class="line">          &lt;intent-filter&gt;  </span><br><span class="line">              &lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---&gt;</span><br><span class="line">              &lt;action  </span><br><span class="line">                  android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;  </span><br><span class="line">              &lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--&gt;</span><br><span class="line">              &lt;category  </span><br><span class="line">                  android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;  </span><br><span class="line">          &lt;/intent-filter&gt;  </span><br><span class="line">      &lt;/activity&gt;  </span><br></pre></td></tr></table></figure><h2 id="修改广告方法–处理时间管理类"><a href="#修改广告方法–处理时间管理类" class="headerlink" title="修改广告方法–处理时间管理类"></a>修改广告方法–处理时间管理类</h2><p>修改方法：<br>1.修改加载时间<br>2.Acitivity切换定位，修改Intent的Activity类名</p><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><table><thead><tr><th align="left">函数名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onCreate()</td><td align="left">一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td align="left">onStart()</td><td align="left">当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td align="left">onResume()</td><td align="left">这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td align="left">onPause()</td><td align="left">这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td align="left">onStop()</td><td align="left">这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td align="left">onDestroy()</td><td align="left">这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td align="left">onRestart()</td><td align="left">当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231107170440736-e040da.png" alt="image-20231107170440736"></p><h2 id="弹窗定位-堆栈分析–处理弹窗类"><a href="#弹窗定位-堆栈分析–处理弹窗类" class="headerlink" title="弹窗定位&amp;堆栈分析–处理弹窗类"></a>弹窗定位&amp;堆栈分析–处理弹窗类</h2><p>修改方法：<br>1.修改xml中的versiocode—不好用<br>2.Hook弹窗(推荐算法助手开启弹窗定位)<br>3.修改dex弹窗代码<br>4.抓包修改响应体(也可以路由器拦截)</p><h2 id="布局优化–处理非弹窗类"><a href="#布局优化–处理非弹窗类" class="headerlink" title="布局优化–处理非弹窗类"></a>布局优化–处理非弹窗类</h2><p>1.开发者助手抓布局<br>2.MT管理器xml搜索定位<br>3.修改xml代码，将要显示的大小设置为0dp</p><p>或者直接隐藏</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:visibility=<span class="string">&quot;gone&quot;</span></span><br></pre></td></tr></table></figure><h1 id="动态调试-Log插桩"><a href="#动态调试-Log插桩" class="headerlink" title="动态调试&amp;Log插桩"></a>动态调试&amp;Log插桩</h1><h2 id="什么是动态调试"><a href="#什么是动态调试" class="headerlink" title="什么是动态调试"></a>什么是动态调试</h2><p>动态调试是指自带的调试器跟踪自己软件的运行，可以在调试的过程中知道参数或者局部变量的值以及履清代码运行的先后顺序。多用于爆破注册码(CTF必备技能)</p><h2 id="动态调试步骤–一般用前两个"><a href="#动态调试步骤–一般用前两个" class="headerlink" title="动态调试步骤–一般用前两个"></a>动态调试步骤–一般用前两个</h2><h3 id="1-修改debug权限"><a href="#1-修改debug权限" class="headerlink" title="1.修改debug权限"></a>1.修改debug权限</h3><p>方法一:在AndroidManifest.xml里添加可调试权限</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">android:debuggable=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>方法二：XappDebug模块hook对应的app</p><p>需要打开系统调试以及对应APP权限</p><p>项目地址</p><p><a href="https://github.com/Palatis/XAppDebug">XappDebug</a></p><p>方法三：Magisk命令(重启失效)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码1.  adb shell #adb进入命令行模式</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span>  su #切换至超级用户</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span>  magisk resetprop ro.debuggable 1</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span>  stop;start; #一定要通过该方式重启</span><br></pre></td></tr></table></figure><p>方法四:刷入MagiskHide Props Config模块(永久有效，但我这两台手机都不行，哭死，呜呜呜)</p><p>一般来说，在4选项中如果有ro.debuggable那就直接修改<br>没有的话就选5<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20231108203628346-524db5.png" alt="image-20231108203628346"></p><p>修改ro.debuggable的值为1</p><h3 id="下段点"><a href="#下段点" class="headerlink" title="下段点"></a>下段点</h3><p>将要用的APP拖入到JEB里面，注意如果要按照第一种方式修改，修改完成后要拖入修改完成后的APP</p><p>ctrl+b下断点</p><h3 id="debug模式启动"><a href="#debug模式启动" class="headerlink" title="debug模式启动"></a>debug模式启动</h3><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">adb shell am start -D -n <span class="keyword">com</span>.zj.wuaipojie/.ui.MainActivity</span><br></pre></td></tr></table></figure><p>adb shell am start -D -n<br>adb shell am start -D -n 包名&#x2F;类名<br>am start -n 表示启动一个activity<br>am start -D 表示将应用设置为可调试模式</p><h2 id="Log插桩"><a href="#Log插桩" class="headerlink" title="Log插桩"></a>Log插桩</h2><p>定义：Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p><h3 id="一、引用文件"><a href="#一、引用文件" class="headerlink" title="一、引用文件"></a>一、引用文件</h3><p>将日志插桩2.dex文件引入到APP里面，改成一样类似的名称，例如APP里面的名称是class.dex，那么就可以修改成calss2.dex格式</p><h3 id="二、调用命令"><a href="#二、调用命令" class="headerlink" title="二、调用命令"></a>二、调用命令</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">粘贴到对应位置即可<span class="built_in"></span></span><br><span class="line"><span class="built_in">invoke-static </span>&#123;对应寄存器&#125;, <span class="class">Lcom/mtools/LogUtils;</span>-&gt;v(<span class="class">Ljava/lang/Object;</span>)V</span><br></pre></td></tr></table></figure><h1 id="获取到源码并且抽取语法树的过程"><a href="#获取到源码并且抽取语法树的过程" class="headerlink" title="获取到源码并且抽取语法树的过程"></a>获取到源码并且抽取语法树的过程</h1><h2 id="APK-ZIP"><a href="#APK-ZIP" class="headerlink" title="APK-&gt; ZIP"></a>APK-&gt; ZIP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先将APK文件修改后缀，修改为ZIP文件，然后进行解压，得到里面的dex文件，将其中多个class.dex文件复制到dex2jar的目录下面</span><br></pre></td></tr></table></figure><h2 id="DEX-JAR"><a href="#DEX-JAR" class="headerlink" title="DEX-&gt;JAR"></a>DEX-&gt;JAR</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开  dex2jar-2.0根目录，运行 cmd命令，输入以下：</span><br><span class="line">d2j-dex2jar.bat classes.dex</span><br></pre></td></tr></table></figure><h2 id="jd-gui"><a href="#jd-gui" class="headerlink" title="jd-gui"></a>jd-gui</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -D&#x27;file.encoding=UTF-8&#x27; -jar input.jar</span><br></pre></td></tr></table></figure><p>长时间卡顿。。。</p><h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><h2 id="adb的基本使用"><a href="#adb的基本使用" class="headerlink" title="adb的基本使用"></a>adb的基本使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell 查询手机</span><br><span class="line"></span><br><span class="line">ASUS_I003DD:/ # su   管理员模式</span><br></pre></td></tr></table></figure><p>frida版本选择与安装<br>frida版本和python版本以及Android要对应，python版本过高会导致frida不可用，以下是不严谨的版本对应关系<br>frida12.3.6 –&gt; python3.7 –&gt; Android5-6<br>frida12.8.0 –&gt;Python3.8–&gt;Android7-8<br>frida14–&gt;Python3.8–&gt;Android9</p><h2 id="查看python版本"><a href="#查看python版本" class="headerlink" title="查看python版本"></a>查看python版本</h2><p>python –version</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\lENOVO&gt;python --version</span><br><span class="line">Python 3.8.8</span><br></pre></td></tr></table></figure><h2 id="安装指定版本的frida"><a href="#安装指定版本的frida" class="headerlink" title="安装指定版本的frida"></a>安装指定版本的frida</h2><p>我用的逍遥模拟器安卓9版本，所以安装14版本的firda</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install frida==14.2.18</span><br><span class="line">查询frida对应的frida-tools版本，frida下载连接，14.2.18对应的frida-tools版本如下</span><br><span class="line"></span><br><span class="line">https://gitcode.com/mirrors/frida/frida/overview</span><br></pre></td></tr></table></figure><h2 id="安装对应版本的frida-tools"><a href="#安装对应版本的frida-tools" class="headerlink" title="安装对应版本的frida-tools"></a>安装对应版本的frida-tools</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`pip install frida-tools==9.2.4`</span><br><span class="line">安装完成后输入`frida --version`</span><br></pre></td></tr></table></figure><h2 id="frida-server选择与安装"><a href="#frida-server选择与安装" class="headerlink" title="frida server选择与安装"></a>frida server选择与安装</h2><p>先查看模拟器或者手机的<a href="https://so.csdn.net/so/search?q=cpu%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">cpu架构</a>，选择对应的server</p><p>我这边用的夜神模拟器，先用adb连接模拟器<code>adb connect 127.0.0.1:62001</code><br>然后<code>adb shell</code>，进入模拟器shell</p><p>输入<code>getprop ro.product.cpu.abi</code>查看cpu架构</p><p>下载x86_64版本的frida-server</p><p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载完成后解压，然后用adb push [刚刚下载的frida路径] /data/local/tmp将frida-server推送到模拟器tmp目录。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意不可以使用中文路径</span><br><span class="line"></span><br><span class="line">修改权限</span><br><span class="line">chmod 777  frida-server</span><br><span class="line"></span><br><span class="line">打开使用，当前cmd窗口不能关闭</span><br><span class="line">./frida-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新打开一个cmd窗口，输入frida-ps -U，返回了模拟器的app数据，大功告成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">连wifi的时候若有些时候frida连接不上，则可以试一下端口转发：</span><br><span class="line"> adb forward tcp:27043 tcp:27043</span><br><span class="line">  adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学校学习 </category>
          
          <category> xjtu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xjtu </tag>
            
            <tag> 安卓逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目部署学习</title>
      <link href="/posts/41591.html"/>
      <url>/posts/41591.html</url>
      
        <content type="html"><![CDATA[<h1 id="云端环境部署"><a href="#云端环境部署" class="headerlink" title="云端环境部署"></a>云端环境部署</h1><p>基于<code>Centos7</code>系统环境进行云服务器的部署</p><h2 id="准备好MySQL和JDK-的安装包"><a href="#准备好MySQL和JDK-的安装包" class="headerlink" title="准备好MySQL和JDK 的安装包"></a>准备好<code>MySQL</code>和<code>JDK</code> 的安装包</h2><p>注意安装包必须是<code>linx</code>系统上的安装包</p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装<code>MySQL</code></h2><h4 id="首先卸载Centos7自带的mariadb"><a href="#首先卸载Centos7自带的mariadb" class="headerlink" title="首先卸载Centos7自带的mariadb"></a>首先卸载<code>Centos7</code>自带的<code>mariadb</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查找</span><br><span class="line">rpm -qa|grep mariadb</span><br><span class="line"># 如果显示 mariabdb版本，那么进行删除，如果不显示，那么不需要卸载</span><br><span class="line"># 卸载</span><br><span class="line">rpm -e &#123;mariadb版本&#125; --nodeps</span><br></pre></td></tr></table></figure><h4 id="解压mysql"><a href="#解压mysql" class="headerlink" title="解压mysql"></a>解压<code>mysql</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 创建mysql安装包存放点</span><br><span class="line">mkdir /usr/server/mysql</span><br><span class="line"># 解压</span><br><span class="line">tar xvf &#123;mysql.tar 压缩包&#125;</span><br></pre></td></tr></table></figure><h4 id="执行安装"><a href="#执行安装" class="headerlink" title="执行安装"></a>执行安装</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 切换到安装目录</span><br><span class="line">cd /usr/server/mysql/</span><br><span class="line">    #使用yum安装mysql所必须的一些软件</span><br><span class="line">yum -y install libaio</span><br><span class="line">yum -y install libncurses*</span><br><span class="line">yum -y install perl perl-devel</span><br><span class="line"># 安装</span><br><span class="line">    用ls属性查询mysql解压完成的包里面对应的版本号</span><br><span class="line">rpm -ivh &#123;mysql-community-common-版本号&#125;</span><br><span class="line">rpm -ivh &#123;mysql-community-libs-版本号&#125;</span><br><span class="line">rpm -ivh &#123;mysql-community-client-版本号&#125;</span><br><span class="line">rpm -ivh &#123;mysql-community-server-版本号&#125;</span><br></pre></td></tr></table></figure><h4 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动<code>MySQL</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#启动mysql</span><br><span class="line">systemctl start mysqld.service</span><br><span class="line">#查看生成的临时root密码,mysql-<span class="number">5.7</span>版本的密码会生成在mysqld.log里面，然后用grep指令进行查找</span><br><span class="line">cat /<span class="keyword">var</span>/log/mysqld.log | grep password</span><br></pre></td></tr></table></figure><h4 id="修改初始的随机密码"><a href="#修改初始的随机密码" class="headerlink" title="修改初始的随机密码"></a>修改初始的随机密码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 登录mysql</span><br><span class="line">mysql -u root -p</span><br><span class="line">Enter password: #输入在日志中生成的临时密码——————注意这里直接粘贴，粘贴完成后界面不会和window一样显示**，会什么也不显示</span><br><span class="line"># 更新root密码 设置为密码</span><br><span class="line">    下面两句是将密码设置规则修改简单，具体情况可以不进行修改</span><br><span class="line">set global validate_password_policy=<span class="number">0</span>;</span><br><span class="line">set global validate_password_length=<span class="number">1</span>;</span><br><span class="line">set password=password(<span class="string">&#x27;密码&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="授予远程连接权限"><a href="#授予远程连接权限" class="headerlink" title="授予远程连接权限"></a>授予远程连接权限</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’;</span><br><span class="line"></span><br><span class="line">权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n代表select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file等<span class="number">14</span>个权限。</span><br><span class="line">当权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n被all privileges或者all代替，表示赋予用户全部权限。</span><br><span class="line">当数据库名称.表名称被*.*代替，表示赋予用户操作服务器上所有数据库所有表的权限。</span><br><span class="line">用户地址可以是localhost，也可以是ip地址、机器名字、域名。也可以用’%<span class="string">&#x27;表示从任何地址连接。</span></span><br><span class="line"><span class="string">————————————————————————————————————————————————</span></span><br><span class="line"><span class="string">  允许所有用户远端连接，由于自己玩，所以设置成所有ip可以防止万一网络切换带来问题  </span></span><br><span class="line"><span class="string">grant all privileges on *.* to &#x27;</span>用户名<span class="string">&#x27; @&#x27;</span>%<span class="string">&#x27; identified by &#x27;</span>密码<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"># 刷新权限</span></span><br><span class="line"><span class="string">flush privileges;</span></span><br></pre></td></tr></table></figure><h4 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#mysql的启动和关闭 状态查看</span><br><span class="line">systemctl stop mysqld</span><br><span class="line">systemctl status mysqld</span><br><span class="line">systemctl start mysqld</span><br><span class="line">#建议设置为开机自启动服务</span><br><span class="line">systemctl enable mysqld</span><br><span class="line">#查看是否已经设置自启动成功</span><br><span class="line">systemctl list-unit-files | grep mysqld</span><br></pre></td></tr></table></figure><h4 id="关闭防火墙——阿里云不用"><a href="#关闭防火墙——阿里云不用" class="headerlink" title="关闭防火墙——阿里云不用"></a>关闭防火墙——阿里云不用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用一些虚拟机或者其他云服务器可能有防火墙阻止访问，这里需要防火墙关闭</span><br><span class="line">    </span><br><span class="line">firewall-cmd --state #查看防火墙状态</span><br><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于mysql数据库使用的是<span class="number">3306</span>的端口，所以后端密钥（安全锁）要保证<span class="number">3306</span>的端口开放，不然也会出错</span><br><span class="line">设置完成后就可以用navicat测试连接了</span><br></pre></td></tr></table></figure><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装<code>nginx</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于nginx是用来服务器运行vue前端项目的一个工具，可以采用安装包进行安装，也可以用yum进行安装</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum update</span><br><span class="line">    #对yum进行更新！</span><br><span class="line">yum -y install nginx</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl start nginx #开启nginx服务</span><br><span class="line">systemctl stop nginx #停止nginx服务</span><br><span class="line">systemctl restart nginx #重启nginx服务</span><br></pre></td></tr></table></figure><h2 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置<code>JDK</code></h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tar -zvxf &#123;jdk.gz&#125;</span><br></pre></td></tr></table></figure><h3 id="写入配置路径里面"><a href="#写入配置路径里面" class="headerlink" title="写入配置路径里面"></a>写入配置路径里面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim文件操作小细节</span><br><span class="line">输入I进行插入操作，按入Esc输入：wq进行保存</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"># 文件末尾增加</span><br><span class="line">export JAVA_HOME=&#123;/usr/server/里面输入的是你jdk解压的地址&#125;jdk1<span class="number">.8</span><span class="number">.0_131</span></span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="打包vue项目"><a href="#打包vue项目" class="headerlink" title="打包vue项目"></a>打包<code>vue</code>项目</h2><p>进入到<code>Vue</code>项目目录，执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>将生成的dist目录上传至服务器 {&#x2F;usr&#x2F;vue&#x2F;dist ————保存的文件}</p><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置<code>nginx</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入到/etc/nginx/conf.d目录，创建vue.conf文件，</span><br><span class="line">    vim vue.conf</span><br><span class="line"></span><br><span class="line">名字可以进行修改</span><br><span class="line">    </span><br><span class="line">    内容如下：</span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;#nginx监视端口，一般不改</span><br><span class="line">    server_name localhost;#绑定域名</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/app/dist; #vue文件位置</span><br><span class="line">        index index.html;  #index文件位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包java程序"><a href="#打包java程序" class="headerlink" title="打包java程序"></a>打包<code>java</code>程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">采用maven的自带打包软件,打包成jar包</span><br><span class="line">    </span><br><span class="line">    传输到云端，之后到指定目录，运行</span><br><span class="line">    nohup java -jar &#123;jar包名字&#125; &gt; logName.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">    nohup java -jar TeamQuestionnaire-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar &gt; logName.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">    catlogName.log 可以查看运行日志，查看是否运行成功</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue所有流程（网课学习版本）</title>
      <link href="/posts/21575.html"/>
      <url>/posts/21575.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><p>相当于后端运算javaScript的运行环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v：查看npm安装的版本。</span><br><span class="line">npm init：会引导你建立一个package.json文件，包括名称、版本、作者等信息。</span><br><span class="line">npm list：查看当前目录下已安装的node包。</span><br><span class="line">npm ls：查看当前目录下已安装的node包。</span><br><span class="line">npm install moduleNames：安装Node模块到本地目录node_modules下。</span><br><span class="line">npm install &lt; name &gt; -g：将包安装到全局环境中。</span><br><span class="line">npm install &lt; name &gt; --save：安装的同时，将信息写入package.json中，项目路径中若是有package.json文件时，直接使用npm install方法就能够根据dependencies配置安装全部的依赖包，这样代码提交到git时，就不用提交node_modules这个文件夹了。</span><br><span class="line">npm install &lt; name&gt; --save-dev：安装的同时，将信息写入package.json中项目路径中若是有package.json文件时，直接使用npm install方法就能够根据devDependencies配置安装全部的依赖包，这样代码提交到git时，就不用提交node_modules这个文件夹了。</span><br><span class="line">npm uninstall moudleName：卸载node模块。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">输出版本号</span><br><span class="line"></span><br><span class="line">npm-v  输出版本号</span><br></pre></td></tr></table></figure><h2 id="设置npm的淘宝镜像"><a href="#设置npm的淘宝镜像" class="headerlink" title="设置npm的淘宝镜像"></a>设置npm的淘宝镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry  https://registry.npm.taobao.org/  #设置淘宝镜像地址</span><br><span class="line">npm config get registry  #查看镜像地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">视频说必须maven必须得3.6版本以上</span><br></pre></td></tr></table></figure><h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><p>springboot是maven升级版</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221028151736640-173649373859817-c1a9ee.png" alt="image-20221028151736640"></p><p>选择spring web</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221028151630593-173649373859818-d4e22a.png" alt="image-20221028151630593"></p><h2 id="开发热部署"><a href="#开发热部署" class="headerlink" title="开发热部署"></a>开发热部署</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring -boot -devtools</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    依赖导入</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    之后在应用配置里面设置哪些页面以及文件需要设置热部署application.properties</span><br><span class="line">    </span><br><span class="line">    #热部署生效 ——没用</span><br><span class="line">spring.devtools.restart.enabled=<span class="literal">true</span>  </span><br><span class="line">#设置重启目录</span><br><span class="line">spring.devtools.restart.additional-paths=src/main/java</span><br><span class="line">#设置一些目录下面修改不会热部署</span><br><span class="line">spring.devtools.restart.exclude=<span class="keyword">static</span><span class="comment">/**</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221028160016360-173649373859819-1d783b.png" alt="image-20221028160016360"></p><h2 id="注释解析"><a href="#注释解析" class="headerlink" title="注释解析"></a>注释解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  表示是控制器,如果只请求数据就可以用这个</span><br><span class="line">    默认会把数据转化为json格式</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Controller</span> 请求的是页面和数据 （了解）</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">@RequestMapping</span> 负责URL的路由映射</span><br><span class="line"><span class="meta">@GetMapping</span>   浏览器获取数据,是上面这个方法是get简写形式</span><br><span class="line">    </span><br><span class="line">    对于其接受对象的形式，你需要传递的内容必须和对象的名字一致，springboot会自动打包成为一个对象</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221028160659271-173649373859820-11eca1.png" alt="image-20221028160659271"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221028160749618-173649373859821-1c849e.png" alt="image-20221028160749618"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于参数method 有get post put delete等方法来进行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestParam</span>  参数映射 即前端传递的参数名称和方法名称不一致，可以进行修改</span><br><span class="line">    如果有这个方法就必须得进行传参，不穿就会报错</span><br><span class="line">    eg:<span class="meta">@RequestParam(&quot;str&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestParam(&quot;str&quot;,required=false)</span>  设置为不必须传递</span><br><span class="line"><span class="meta">@RequestBody</span>   接受JSON类型的数据，同时如果转化为对象，那么名称得一致，类型也得一致eg:对象里面一个参数是整数，那么json穿过来得是整数类型</span><br></pre></td></tr></table></figure><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用IDEA创建Spring Boot项目，会默认创建出classpath:/<span class="keyword">static</span>/目录，静态资源一般放在这个目录下即可。</span><br><span class="line">    </span><br><span class="line">如果默认的静态资源过滤策略不能满足开发需求，也可以自定义静态资源过滤策略。在application.properties中直接定义过滤规则和静态资源位置:spring.mvc.<span class="keyword">static</span>-path-pattern=/路径名/  可以通过路径名加图片名访问</span><br><span class="line">    </span><br><span class="line">自己设置路径</span><br><span class="line">spring.web.resources.<span class="keyword">static</span>-locations=classpath: /路径</span><br><span class="line">    过滤规则为/<span class="keyword">static</span><span class="comment">/**，静态资源位置为classpath:/static/</span></span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spring Boot工程嵌入的tomcat限制了请求的文件大小，每个文件的配置最大为1Mb，单次请求的文件的总数不能大于10Mb。</span><br><span class="line">    </span><br><span class="line">    spring.servlet.multipart.max-file-size=10MB  设置文件配置大小最大可以更改</span><br><span class="line">    </span><br><span class="line">    spring.servlet.multipart.max-request-size=10MB 单次请求的文件总数也可以更改</span><br><span class="line">    </span><br><span class="line">    对于表单文件提交，必须成MultipartFile类型进行接受</span><br><span class="line">    MultipartFile file</span><br><span class="line">    file.transerTo(path)  将文件写入地址中</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handlerlnterceptor接口定义了preHandle、postHandle、afterCompletion三种方法，通过重写这三种方法实现请求前、请求后等操作</span><br></pre></td></tr></table></figure><h3 id="拦截器定义"><a href="#拦截器定义" class="headerlink" title="拦截器定义"></a>拦截器定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">            system.out.print1n(<span class="string">&quot;通过&quot;</span>);<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            system.out.print1n(<span class="string">&quot;不通过&quot;</span>);<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure><h3 id="拦截器注册"><a href="#拦截器注册" class="headerlink" title="拦截器注册"></a>拦截器注册</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addPathPatterns方法定义拦截的地址</span><br><span class="line">excludePathPatterns定义排除某些地址不被拦截</span><br><span class="line">添加的一个拦截器没有addPathPattern任何一个url则默认拦截所有请求</span><br><span class="line">如果没有excludePathPatterns任何一个请求，则默认不放过任何一个请求。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">webconfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor( <span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>() ).addPathPatterns(<span class="string">&quot;/hello&quot;</span>);  设置拦截的路径</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RESTful服务"><a href="#RESTful服务" class="headerlink" title="RESTful服务"></a>RESTful服务</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221029162806835-173649373859822-822411.png" alt="image-20221029162806835"></p><h3 id="Springboot实现RESTful服务"><a href="#Springboot实现RESTful服务" class="headerlink" title="Springboot实现RESTful服务"></a>Springboot实现RESTful服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spring Boot提供的spring-boot-starter-web组件完全支持开发RESTful API,提供了与REST操作方式(GET、POST、PUT、DELETE)对应的注解。</span><br><span class="line">    <span class="meta">@GetMapping</span>:处理GET请求，获取资源。</span><br><span class="line">    <span class="meta">@PostMapping</span>:处理POST请求，新增资源。</span><br><span class="line">    <span class="meta">@PutMapping</span>:处理PUT请求，更新资源。</span><br><span class="line">    <span class="meta">@DeleteMapping</span>:处理DELETE请求，删除资源。  </span><br><span class="line">    <span class="meta">@PatchMapping</span>:处理PATCH请求，用于部分更新资源。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同时在进行转换不要动词</span><br><span class="line">    eg:创建用户   post请求  接口地址/user</span><br><span class="line">        删除用户   DELETE请求   接口地址/user/id</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="meta">@RestController</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">            <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;根据ID获取用户&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">            <span class="keyword">public</span> string <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;添加用户&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@PutMapping</span> (<span class="string">&quot; /user&quot;</span>)</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span><span class="string">&quot;更新用户&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">            <span class="keyword">public</span> string <span class="title function_">deleteById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span><span class="string">&quot;根据ID删除用户&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有两个关键点，第一是如果传入的是动态id，那么需要加入&#123;id&#125;  获取的时候需要加上注解<span class="meta">@PathVariable</span></span><br></pre></td></tr></table></figure><h2 id="Swagger工具——自动生成接口API工具"><a href="#Swagger工具——自动生成接口API工具" class="headerlink" title="Swagger工具——自动生成接口API工具"></a>Swagger工具——自动生成接口API工具</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221029164059530-173649373859823-c4f19c.png" alt="image-20221029164059530"></p><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221029164121864-173649373859824-be4fe9.png" alt="image-20221029164121864"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221029164139857-173649373859825-d095f9.png" alt="image-20221029164139857"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221029164252200-173649373859826-5fc257.png" alt="image-20221029164252200"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221029164450309-173649373859827-5f23ef.png" alt="image-20221029164450309"></p><h1 id="MyBatisPlus快速上手"><a href="#MyBatisPlus快速上手" class="headerlink" title="MyBatisPlus快速上手"></a>MyBatisPlus快速上手</h1><h2 id="添加依赖-版本可改"><a href="#添加依赖-版本可改" class="headerlink" title="添加依赖-版本可改"></a>添加依赖-版本可改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--MyBatisPlus依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">5.1</span><span class="number">.39</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--数据连接池druid--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.2</span><span class="number">.14</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">连接池的作用：连接池是将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对数据库进行访问。这样省略了创建连接和销毁连接的过程。这样性能上得到了提高,避免重复多次的打开数据库连接而曹诚性能的下降和系统资源的浪费；连接池是将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对数据库进行访问。这样省略了创建和销毁的过程。这样以提高系统的性能</span><br></pre></td></tr></table></figure><h2 id="配置数据库相关信息"><a href="#配置数据库相关信息" class="headerlink" title="配置数据库相关信息"></a>配置数据库相关信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#定义连接池类型</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">#定义驱动mysql</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#定义数据库地址</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/quesetionnaire?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">#数据库连接账号和密码</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br><span class="line">#指定日志输出格式</span><br><span class="line">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h2 id="添加-MapperScan注解"><a href="#添加-MapperScan注解" class="headerlink" title="添加@MapperScan注解"></a>添加@MapperScan注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在启动类里面添加上面的注解，去使得知道在哪里</span><br><span class="line">    一般对于数据库操作都会放在Mapper里面进行操作</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.demospring.Mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建立Mapper映射"><a href="#建立Mapper映射" class="headerlink" title="建立Mapper映射"></a>建立Mapper映射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于数据库的操作一般都会放在Mapper里面映射，Mapper里面放一个接口信息，同时对于springboot会自动对Mapper对象进行一个内存实例化，当需要使用的时候，只需要申明即可</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">userMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    查询所有用户</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from dept&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;dept&gt; <span class="title function_">GetDept</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意要加上<span class="meta">@Mapper</span>注解</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="控制器引用"><a href="#控制器引用" class="headerlink" title="控制器引用"></a>控制器引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于springboot内部会自动生成一个mapper对象，所以我们只需要引用就可以</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userMapper user;就可以引用你所设计的Mapper</span><br><span class="line">        同时对于前后端分离的项目，后端需要想前端转递一个JSON对象，所以需要传递List会自动打包为JSON传递前去</span><br><span class="line">        eg:</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hellocon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userMapper user;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">GetDept</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;dept&gt; list = user.GetDept();</span><br><span class="line">        <span class="keyword">for</span> (dept d : list</span><br><span class="line">        ) &#123;</span><br><span class="line">            System.out.println(d.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mybaitsPlus优化版本"><a href="#mybaitsPlus优化版本" class="headerlink" title="mybaitsPlus优化版本"></a>mybaitsPlus优化版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以去继承一个父类，里面有定义好的方法  BaseMapper&lt;T&gt;</span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor  <span class="title function_">paginationInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL);</span><br><span class="line">        interceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span>  interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先确保继承了BaseMapper&lt;T&gt;</span><br><span class="line"><span class="comment">//        设置起始值和每页条数    </span></span><br><span class="line">     Page&lt;dept&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        传入页数和一些附带条件</span></span><br><span class="line">        <span class="type">IPage</span> <span class="variable">iPage</span> <span class="operator">=</span> user.selectPage(page,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">return</span> iPage</span><br></pre></td></tr></table></figure><h1 id="VUE上手"><a href="#VUE上手" class="headerlink" title="VUE上手"></a>VUE上手</h1><h2 id="vscode-格式化代码-shift-alt-f"><a href="#vscode-格式化代码-shift-alt-f" class="headerlink" title="vscode 格式化代码  shift+alt+f"></a>vscode 格式化代码  shift+alt+f</h2><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在html区域head内导入vue的脚本文件  注意这里的网址可以进行更换</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>声明要被vue所控制的DOM区域</span><br><span class="line">       &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line"><span class="number">3.</span>创建vue的实例对象</span><br><span class="line">           </span><br><span class="line">    &lt;!-- 创建vue实例对象 --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">// vue.creatapp来创建一个实例化对象</span></span><br><span class="line">        Vue.createApp(&#123;</span><br><span class="line">            <span class="comment">// 指定数据源，MVVM中的model</span></span><br><span class="line">            data() &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">        <span class="comment">// 用mount和div连接起来</span></span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;  默认的</span><br><span class="line"></span><br><span class="line">当花括号遇到html的内容时候，不会进行渲染，会当成字符串</span><br><span class="line">需要用v-html指令</span><br><span class="line">    eg：    &lt;p v-html=<span class="string">&quot;desc&quot;</span>&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">属性绑定指令</span><br><span class="line">    对于传入的数据是给定的属性，那么就需要进行绑定,绑定有两种方式，一种是直接加：，另一种是直接v-bind绑定</span><br><span class="line">    eg: &lt;a :href=<span class="string">&quot;link&quot;</span>&gt;哔哩哔哩&lt;/a&gt;</span><br><span class="line">        &lt;a v-bind:href=<span class="string">&quot;link&quot;</span>&gt;eeg&lt;/a&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> :placeholder=<span class="string">&quot;input&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以使用javascript表达式</span><br><span class="line">number:<span class="number">5</span>,</span><br><span class="line">message:<span class="string">&quot;asd&quot;</span>,</span><br><span class="line">user: &#123;</span><br><span class="line">    name :<span class="string">&quot;28&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">            &#123;&#123;number+<span class="number">1</span>&#125;&#125;</span><br><span class="line">            &#123;&#123;user.name&#125;&#125;</span><br><span class="line">            &#123;&#123;message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)&#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绑定按钮事件  对于vue里面的方法，需要用它所属的方法进行使用，v-on或者@符号</span><br><span class="line">     &lt;button v-on:click=<span class="string">&quot;number-=1&quot;</span>&gt;-<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button <span class="meta">@click</span>=<span class="string">&quot;addNumber&quot;</span>&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">         </span><br><span class="line">         对于一些简单的方法可以直接在后面写，对于一些复杂的方法，可以在对象中定义</span><br><span class="line">            methods:&#123;</span><br><span class="line">                addNumber()&#123;</span><br><span class="line">                    <span class="built_in">this</span>.number+=<span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                jianNumber()&#123;</span><br><span class="line">                    <span class="built_in">this</span>.number-=<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">条件渲染指令，使用v-<span class="keyword">if</span>和v-show来展示，</span><br><span class="line">    有区别，如果传入的是<span class="literal">false</span>，那么v-<span class="keyword">if</span>将不会被创建，v-show标签会被创建，但是没显示出来</span><br><span class="line">    </span><br><span class="line">     &lt;p v-<span class="keyword">if</span>=<span class="string">&quot;true&quot;</span>&gt;标签&lt;/p&gt;</span><br><span class="line">        &lt;p v-show=<span class="string">&quot;true&quot;</span>&gt;标签&lt;/p&gt;</span><br><span class="line">         </span><br><span class="line">         当然存在v-<span class="keyword">else</span>,v-<span class="keyword">else</span>-<span class="keyword">if</span> 来进行多条件判断</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">列表渲染指令,注意数据列表用方括号存储，对于v-<span class="keyword">for</span>可以有两个参数，也可以有一个参数，两个参数会自带索引位置</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">            &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(user,i) in userList&quot;</span>&gt;</span><br><span class="line">                索引:&#123;&#123;i&#125;&#125;</span><br><span class="line">                姓名：&#123;&#123;user.name&#125;&#125;</span><br><span class="line">                id为= &#123;&#123;user.id&#125;&#125;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">                </span><br><span class="line">       userList: [</span><br><span class="line">                        &#123; id: <span class="string">&quot;1&quot;</span>, name: <span class="string">&quot;curry&quot;</span> &#125;,</span><br><span class="line">                        &#123; id: <span class="string">&quot;4&quot;</span>, name: <span class="string">&quot;westbook&quot;</span> &#125;,</span><br><span class="line">                        &#123; id: <span class="string">&quot;3&quot;</span>, name: <span class="string">&quot;Lerbon&quot;</span> &#125;,</span><br><span class="line">                    ],          </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">for</span> 的key值</span><br><span class="line">    </span><br><span class="line">    对于&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">v-model会自动将实例化对象数据，将浏览器和数据双向绑定</span><br><span class="line">    </span><br><span class="line">    对于List数据添加可以用unshift方法</span><br><span class="line">    </span><br><span class="line">v-<span class="keyword">for</span> 的key一般是给li标签来设置唯一值 ，来识别li</span><br><span class="line">    一般用数据id  ：key=<span class="string">&quot;user.id&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Vue组件化开发"><a href="#Vue组件化开发" class="headerlink" title="Vue组件化开发"></a>Vue组件化开发</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用管理员打开cmd</span><br><span class="line">然后输入 vue create 项目名称</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221030142513578-173649373859828-385a5b.png" alt="image-20221030142513578"></p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221030112530996-173649373859830-d1cb65.png" alt="image-20221030112530996"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221030112509946-173649373859829-92441a.png" alt="image-20221030112509946"> </p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221030112751033-173649373859832-67f205.png" alt="image-20221030112751033"> </p><h2 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先 <span class="keyword">package</span>.json  设置一些基本依赖以及文件设置</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">src里面就是以后所写代码的目录，里面的main.js是程序的入口文件</span><br><span class="line">    </span><br><span class="line">运行 点击vscode里面查看  &gt;  终端 输入npm run serve</span><br><span class="line">    </span><br><span class="line">app.vue 是提供的一个组件，可以重复使用，其中&lt;template&gt;是组件的文本或者标签，&lt;script&gt;存放组件一些行为，&lt;style&gt;存放组件一些模式 </span><br><span class="line">    </span><br><span class="line">自己导入模块要早在script模块里面进行，用<span class="keyword">import</span>导入，同时还得注册</span><br><span class="line">    <span class="keyword">import</span> HelloWorld from <span class="string">&#x27;./components/HelloWorld.vue&#x27;</span></span><br><span class="line">    </span><br><span class="line">   注册： components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="vue2和vue3的区别"><a href="#vue2和vue3的区别" class="headerlink" title="vue2和vue3的区别"></a>vue2和vue3的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建渲染上vue2是</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    vue3是create来实现</span><br><span class="line">    </span><br><span class="line">vue2div不可以嵌套，必须放在一块</span><br></pre></td></tr></table></figure><h2 id="自定义vue文件"><a href="#自定义vue文件" class="headerlink" title="自定义vue文件"></a>自定义vue文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; 选择html里面 的</span><br><span class="line">&lt;/script&gt; 选择java里面的</span><br><span class="line"></span><br><span class="line">    对于下面的例子可以看到，和之前学的都一样，可以自己返回值，也可以定义方法进行书写，同时，要对于要更改的变量，可以用props来创建，里面是title名字</span><br><span class="line">    使用    &lt;moive title=<span class="string">&quot;送你&quot;</span>&gt;&lt;/moive&gt;</span><br><span class="line">那么就会动态显示</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">props:[<span class="string">&quot;title&quot;</span>],</span><br><span class="line"></span><br><span class="line">    data:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message:<span class="string">&quot;a&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    method</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="组件间数据传递"><a href="#组件间数据传递" class="headerlink" title="组件间数据传递"></a>组件间数据传递</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父级组件可以用props:[<span class="string">&quot;title&quot;</span>],来进行传递</span><br><span class="line"></span><br><span class="line">兄弟间不可以，有其他方法</span><br></pre></td></tr></table></figure><h1 id="elementui"><a href="#elementui" class="headerlink" title="elementui"></a>elementui</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">网站 https:<span class="comment">//element.eleme.cn/#/zh-CN/</span></span><br><span class="line">安装 npm install element-ui</span><br><span class="line">    </span><br><span class="line">如果前端项目不能运行，检查node-modules是否存在，不存在写npm install</span><br><span class="line">    </span><br><span class="line">main js 导入 </span><br><span class="line">    <span class="keyword">import</span> ElementUI from <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">同时需要在mainjs 进行组件注册Vue.use(ElementUI)</span><br></pre></td></tr></table></figure><h1 id="第三方图标库"><a href="#第三方图标库" class="headerlink" title="第三方图标库"></a>第三方图标库</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">文档地址https:<span class="comment">//fontawesome.dashgame.com/</span></span><br><span class="line"></span><br><span class="line">安装 npm install font-awesome</span><br><span class="line">    </span><br><span class="line">导入 <span class="keyword">import</span> <span class="string">&#x27;font-awesome/css/font-awesome.min.css&#x27;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="Axios路由"><a href="#Axios路由" class="headerlink" title="Axios路由"></a>Axios路由</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">安装 npm install axios</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于同步异步的问题来说，就是当代码执行到这一行后，不会停下来进去运行完后才会执行下一个代码，会给进入的分配一个线程执行，剩下的继续执行，同步就不会出现这样的问题</span><br></pre></td></tr></table></figure><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所谓同源（即指在同一个域)就是两个页面具有相同的协议(protocol)，主机(host)和端口号(port)</span><br><span class="line">不同源就指的这两个有不相同的地方，如果服务器没授权，那么没法发送</span><br></pre></td></tr></table></figure><h2 id="解决——CORS"><a href="#解决——CORS" class="headerlink" title="解决——CORS"></a>解决——CORS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">后端实现CORS接口</span><br></pre></td></tr></table></figure><h2 id="方法一加入类，解决所有控制器"><a href="#方法一加入类，解决所有控制器" class="headerlink" title="方法一加入类，解决所有控制器"></a>方法一加入类，解决所有控制器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">//运行跨域访问的路径</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)  <span class="comment">//运行跨域访问的源，接口</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;OPTIONS&quot;</span>,<span class="string">&quot;DELETE&quot;</span>) <span class="comment">//允许请求的方法</span></span><br><span class="line">                .maxAge(<span class="number">16800</span>)<span class="comment">//允许存在时间</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)<span class="comment">//允许头部检查</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);<span class="comment">//是否发送cookie</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方法二-控制器上加注解"><a href="#解决方法二-控制器上加注解" class="headerlink" title="解决方法二 控制器上加注解"></a>解决方法二 控制器上加注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> axios.get(<span class="string">&quot;http://localhost:8088/user&quot;</span>).then((response) =&gt;&#123;</span><br><span class="line">      <span class="built_in">this</span>.tableData=response.data</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">如果用function函数去创建response会使得<span class="built_in">this</span>作用域出现问题，用箭头函数<span class="built_in">this</span>才是这个对象</span><br></pre></td></tr></table></figure><h2 id="一般设置"><a href="#一般设置" class="headerlink" title="一般设置"></a>一般设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一般会将配置直接卸载mainjs文件中</span><br><span class="line">    <span class="keyword">import</span> axios from <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.defaults.baseURL=<span class="string">&quot;http://localhost:8088&quot;</span></span><br><span class="line">Vue.prototype.$http=axios</span><br><span class="line">    </span><br><span class="line">    之后再后面使用的时候就不需要导入了</span><br><span class="line">    </span><br><span class="line">eg:    </span><br><span class="line">    created: function () &#123;</span><br><span class="line">    <span class="built_in">this</span>.$http.get(<span class="string">&quot;/user&quot;</span>).then((response) =&gt;&#123;</span><br><span class="line">      <span class="built_in">this</span>.tableData=response.data</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="vue周期函数"><a href="#vue周期函数" class="headerlink" title="vue周期函数"></a>vue周期函数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  created:function()&#123;</span><br><span class="line">    console.log(<span class="string">&quot;组件被创建&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  onMounted:function()&#123;</span><br><span class="line">    console.log(<span class="string">&quot;组件被挂载&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">页面被创建时候要执行的内容以及页面被挂载时候要执行的内容</span><br></pre></td></tr></table></figure><h1 id="vueRouter"><a href="#vueRouter" class="headerlink" title="vueRouter"></a>vueRouter</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vue实际上在一个页面上进行操作，但是是显示页面的切换与跳转</span><br><span class="line"> vue2安装<span class="number">3</span>  vue3 安装<span class="number">4</span></span><br><span class="line"> 安装npm install  vue-router@<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新建router文件夹，然后设置js文件</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> Vue from <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter from <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> discouver from <span class="string">&#x27;@/components/vuerounter/Discouver.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> friends from <span class="string">&#x27;@/components/vuerounter/Friends.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> mymusic from <span class="string">&#x27;@/components/vuerounter/Mymusic.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">router</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="comment">// 定义hash属性的对应关系</span></span><br><span class="line">   routes:[</span><br><span class="line">        &#123;path:<span class="string">&#x27;/discouver&#x27;</span> ,component :discouver&#125;,</span><br><span class="line">        &#123;path:<span class="string">&quot;/friends&quot;</span>,component:friends&#125;,</span><br><span class="line">        &#123;path:<span class="string">&quot;/mymusic&quot;</span>,component:mymusic&#125;,</span><br><span class="line"></span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在mainjs文件中导入</span><br><span class="line">    <span class="keyword">import</span> router  from <span class="string">&#x27;./router/index.js&#x27;</span>;</span><br><span class="line">在引用绑定中绑定</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  router:router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">之后在vue中引用这模块</span><br><span class="line">    &lt;router-link to=<span class="string">&quot;/discouver&quot;</span>&gt;发现音乐&lt;/router-link&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">&quot;/friends&quot;</span>&gt;关注&lt;/router-link&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">&quot;/mymusic&quot;</span>&gt;我的音乐&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">之后点击 就可以跳转，跳转会显示这个模块的信息，填充在&lt;router-view&gt;&lt;/router-view&gt;这个标签里面</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同时也可以设置重定向，即如果来到首页，那么会自动跳转到一个界面</span><br><span class="line">    &#123; path: <span class="string">&#x27;/&#x27;</span>, redirect: <span class="string">&#x27;/discouver&#x27;</span> &#125;,</span><br></pre></td></tr></table></figure><h2 id="孩子级链接"><a href="#孩子级链接" class="headerlink" title="孩子级链接"></a>孩子级链接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先也需要在router js文件中导入</span><br><span class="line">    之后</span><br><span class="line">     &#123;</span><br><span class="line">            path: <span class="string">&#x27;/discouver&#x27;</span>, component: discouver,</span><br><span class="line">            children: [</span><br><span class="line">                &#123; path: <span class="string">&#x27;&#x27;</span>, component: demo &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于很多路由的情况，可以采用动态路由，用：来进行绑定动态参数</span><br><span class="line">     children:[</span><br><span class="line">                &#123;path:<span class="string">&#x27;:id&#x27;</span>,component:product&#125;</span><br><span class="line">          ]</span><br><span class="line"></span><br><span class="line">前端页面可以通过&#123;&#123;$route.params.id&#125;&#125;来获取值</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">也可以通过绑定属性的方式来进行获取</span><br><span class="line">    children:[</span><br><span class="line">                &#123;path:<span class="string">&#x27;:id&#x27;</span>,component:product,props:<span class="literal">true</span>&#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">设置参数传递时候设置props为<span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    页面接受设置值</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">    props:[<span class="string">&quot;id&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="用按钮导航"><a href="#用按钮导航" class="headerlink" title="用按钮导航"></a>用按钮导航</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">gotoproduct:function(id)&#123;</span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/movie/$&#123;id&#125;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由守卫——拦截"><a href="#路由守卫——拦截" class="headerlink" title="路由守卫——拦截"></a>路由守卫——拦截</h2><p>图片挂了</p><h1 id="状态管理Vuex——解决兄弟组件数据传递"><a href="#状态管理Vuex——解决兄弟组件数据传递" class="headerlink" title="状态管理Vuex——解决兄弟组件数据传递"></a>状态管理Vuex——解决兄弟组件数据传递</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//v3.vuex.vuejs.org/zh</span></span><br><span class="line"></span><br><span class="line">vuex3对于vue2  vuex4对应vue3</span><br><span class="line">核心是一个store</span><br><span class="line"></span><br><span class="line">store里面的state用来数据的存储</span><br><span class="line">    </span><br><span class="line">用Mutations的方式来进行修改，这个和medthods方法类似，可以用它来进行修改,同步进行，对应的参数是state</span><br><span class="line">    </span><br><span class="line">如果要进行修改，要使用commit的方法来进行</span><br><span class="line">    </span><br><span class="line">Getter是对state属性的派生，可以从属性中选取一部分出来使用</span><br><span class="line">    </span><br><span class="line"> actions类似于Mutations方法，但是Action不能直接修改状态，只能通过提交mutation来进行修改，可以包含异步操作，对应的参数是context</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install vuex@<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">简单写法可以从官方文档查看,可以用Mapper</span><br></pre></td></tr></table></figure><h1 id="MOCKJS"><a href="#MOCKJS" class="headerlink" title="MOCKJS"></a>MOCKJS</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对后端数据的模拟，即前端发送请求，后端响应，当后端还没做完，可以拿这个造假</span><br><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>图片挂了</p><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>图片挂了</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221031202704678-173649373859831-048cc7.png" alt="image-20221031202704678"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql使用</title>
      <link href="/posts/6029.html"/>
      <url>/posts/6029.html</url>
      
        <content type="html"><![CDATA[<p><a href=""><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/%E6%95%B0%E6%8D%AE%E5%BA%93-fe473e.png" alt="数据库"></a></p><h2 id="MySQL-登录"><a href="#MySQL-登录" class="headerlink" title="MySQL 登录"></a>MySQL 登录</h2><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220105150221798-d479da.png" alt="image-20220105150221798"></p><p>密码 ：123456；</p><p>例如要到D盘，就输入D：<br>找D盘下的某个文件夹，cd（空格）文件夹名</p><p> cd D:\developTool\MySQL\mysql-8.0.27-winx64\bin</p><p> .\mysql -u root -p</p><h2 id="MySql-操作："><a href="#MySql-操作：" class="headerlink" title="MySql 操作："></a>MySql 操作：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;//查找后台数据</span><br><span class="line"></span><br><span class="line">mysql //保存用户信息</span><br><span class="line">information_schema//保存元数据信息</span><br><span class="line">performance_schema//搜集一些性能信息</span><br><span class="line"> sys//用于监控</span><br><span class="line"> 前三个不可动</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use +库名//进入一个库里面</span><br><span class="line">show tables //展示表中信息 </span><br><span class="line">show tables from 库名//查看其他所有库</span><br><span class="line">create table 库名（</span><br><span class="line">  列名 列类型，</span><br><span class="line">  列名 列类型，</span><br><span class="line">）；</span><br><span class="line">desc 表名 //查看表结构</span><br><span class="line">describe 表名；</span><br><span class="line"></span><br><span class="line">select *form 表名//查看表中结构</span><br><span class="line"></span><br><span class="line">INSERT INTO 表名 ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br><span class="line"></span><br><span class="line">查看服务器版本</span><br><span class="line"></span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二 没有登录到</span><br><span class="line">mysql--version();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> create database demo;//创建一个数据库</span><br><span class="line">  create database if not exists demo;//创建一个数据库</span><br><span class="line">  </span><br><span class="line">  使用IF NOT EXISTS关键字，则当指定的数据库名存</span><br><span class="line">在时，不创建数据库。如果不使用IF NOT EXISTS关键字，</span><br><span class="line">当创建的数据库名存在时，将产生错误。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create database 数据库名;</span><br><span class="line"> 可以查看mysqldb数据库的相关信息（例如MySQL版本ID号、</span><br><span class="line">默认字符集等信息）。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名</span><br><span class="line">• 可以在MySQL命令行工具中使用下面语句删除数据库MySQLDB：</span><br><span class="line">DROP DATABASE MySQLDB</span><br></pre></td></tr></table></figure><h2 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h2><table><thead><tr><th>约束</th><th>说明</th></tr></thead><tbody><tr><td>Not null</td><td>非空约束，指定某列的所有行数据不能包含空值</td></tr><tr><td>unique</td><td>唯一性约束，指定列或者列的组合 的所有行数据必须唯一</td></tr><tr><td>primary key</td><td>主键约束，表的每行的唯一性标识，指定列或者列 的组合 的所有行数据必须唯一</td></tr><tr><td>foreign key</td><td>外键约束，在列及引用列上建立的一种强制依赖关系</td></tr><tr><td>check</td><td>检查性约束，在列上指定一个必须满足的条件</td></tr></tbody></table><h1 id="mysql的数据类型"><a href="#mysql的数据类型" class="headerlink" title="mysql的数据类型"></a>mysql的数据类型</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220511160913498-8a2496.png" alt="image-20220511160913498"></p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>bit</td><td>位字段类型，取值范围是1~64， 默认为1</td></tr><tr><td>tinyint</td><td>很小的整数类型。带符号的范围是-128～127，无符号的范围是0～255</td></tr><tr><td>bool，boolean</td><td>布尔类型，是TINYINT(1)的同义词。zero值被视为假。非zero值被视为真</td></tr><tr><td>smallint</td><td>小的整数类型，带符号的范围是-32768～32767。无符号的范围是0～65535</td></tr><tr><td>mediumint</td><td>中等大小的整数类型。带符号的范围是-8388608～8388607，无符号的范围 是0～16777215</td></tr><tr><td>int</td><td>普通大小的整数类型。带符号的范围是-2147483648～2147483647，无符号 的范围是0～4294967295</td></tr><tr><td>integer</td><td>与INT的含义相同</td></tr><tr><td>bigint</td><td>大整数类型，带符号的范围是-9223372036854775808～ 9223372036854775807。无符号的范围是0～18446744073709551615</td></tr><tr><td>float</td><td>单精度浮点类型</td></tr><tr><td>double</td><td>双精度浮点类型</td></tr><tr><td>decimal</td><td>定点数类型</td></tr><tr><td>dec</td><td>与decimal的含义相同</td></tr></tbody></table><h2 id="日期和事件类型"><a href="#日期和事件类型" class="headerlink" title="日期和事件类型"></a>日期和事件类型</h2><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>date</td><td>日期类型，例如’2012-01-01’</td></tr><tr><td>datetime</td><td>日期和时间类型，例如’2012-01-01 12:00:00’</td></tr><tr><td>timestamp</td><td>时间戳类型，TIMESTAMP列用于INSERT或 UPDATE操作时记录日期和时间</td></tr><tr><td>time</td><td>时间类型</td></tr><tr><td>year</td><td>两位或四位的年份类型，默认为四位年份类型</td></tr></tbody></table><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>char(m)</td><td>固定长度字符串，M为存储长度</td></tr><tr><td>varchar(m)</td><td>可变长度的字符串，M为最大存储长度，实际存储长度为输入 字符的实际长度</td></tr><tr><td>binary(m)</td><td>BINARY类型类似于CHAR类型，但保存二进制字节字符串而 不是非二进制字符串。M为存储长度</td></tr><tr><td>varbinary(m)</td><td>VARBINARY类型类似于VARCHAR类型，但保存二进制字节 字符串而不是非二进制字符串。M为存储长度</td></tr><tr><td>blob</td><td>二进制大对象，包括TINYBLOB、BLOB、MEDIUMBLOB和 LONGBLOB 等4种BLOB类型</td></tr><tr><td>text</td><td>大文本类型，包括TINYTEXT、TEXT、MEDIUMTEXT和 LONGTEXT等4种TEXT类型</td></tr><tr><td>enum</td><td>枚举类型</td></tr><tr><td>set</td><td>集合类型</td></tr></tbody></table><h2 id="mysql特殊字符序列"><a href="#mysql特殊字符序列" class="headerlink" title="mysql特殊字符序列"></a>mysql特殊字符序列</h2><table><thead><tr><th>mysql特殊字符序列</th><th>转义后的字符</th></tr></thead><tbody><tr><td>\&quot;</td><td>双引号(“)</td></tr><tr><td>\&#39;</td><td>单引号(‘)</td></tr><tr><td>\\</td><td>反斜杠(\)</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\0</td><td>ASCII 0 (NUL) 字符</td></tr><tr><td>\%</td><td>%字符</td></tr><tr><td>\_</td><td>_字符</td></tr><tr><td>\b</td><td>ASCII 8 退格符</td></tr></tbody></table><h1 id="mysqL创建表"><a href="#mysqL创建表" class="headerlink" title="mysqL创建表"></a>mysqL创建表</h1><table><thead><tr><th>约束</th><th>描述</th></tr></thead><tbody><tr><td>primary key</td><td>指定字段为主键</td></tr><tr><td>auto_increment</td><td>指定字段为自动增加字段,eg:累加数据</td></tr><tr><td>index</td><td>为字段创建索引</td></tr><tr><td>not null</td><td>字段值不允许为空</td></tr><tr><td>null</td><td>字段值可以为空</td></tr><tr><td>comment</td><td>设置字段的注释信息</td></tr><tr><td>default</td><td>设置字段的默认值</td></tr></tbody></table><h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><p>方法一：在create table语句的末尾添加like子句，可以 将源表的表结构复制到新表中，语法格式如下。</p><p>​ • create table 新表名 like 源表</p><p>方法一： 在create table语句的末尾添加一个select语句， 可以实现表结构的复制，甚至可以将源表的表记录拷贝到新表中。下面的语法格式将源表的表结构以及源表的所有记录拷贝到新表中。</p><p>​ • create table 新表名 select * from 源表</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table 表名</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>可以使用ALTER TABLE语句修改表的结构，包括添加列、修 改列属性和删除列等操作。alter table </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table  表名 add 列名 数据类型和长度 列属性 //新增列</span><br><span class="line">alter table  表名 modify 列名 新数据类型和长度 新列</span><br><span class="line">属性 //修改列</span><br><span class="line">alter table  表名 drop column 列名  //删除列</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改约束条件"><a href="#修改约束条件" class="headerlink" title="修改约束条件"></a>修改约束条件</h3><p>向表的某个字段添加约束条件的语法格式如下（其中约束类型可以 是唯一性约束、主键约束及外键约束）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add constraint 约束名 约束类型 (字段名)//增加约束条件</span><br></pre></td></tr></table></figure><p>删除约束条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop primary key//删除主键</span><br><span class="line">alter table 表名 drop foreign key 约束名//删除外键</span><br><span class="line">alter table 表名 drop index 索引名//删除唯一性约束</span><br></pre></td></tr></table></figure><h3 id="修改表名字"><a href="#修改表名字" class="headerlink" title="修改表名字"></a>修改表名字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename table旧表名to新表名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改表的其他属性"><a href="#修改表的其他属性" class="headerlink" title="修改表的其他属性"></a>修改表的其他属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 engine=新的存储引擎类型</span><br><span class="line">alter table 表名 default charset=新的字符集</span><br><span class="line">alter table 表名 auto_increment=新的初始值</span><br><span class="line">alter table 表名 pack_keys=新的压缩类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名称</span><br><span class="line">values();输入要插入的数据</span><br><span class="line">   ——字符和日期要用单引号  按照这样写默认添加一列，也可在表后加入要添加的列；这样写必须要按照后面列的顺序进行加入数据</span><br><span class="line">   eg:insert into 表名称（column）</span><br><span class="line">values();输入要插入的数据</span><br><span class="line">——如果要插入空值，那么可以在列名称中忽略改列,在下面的例子中只有deptno和dname插入了数据，其他的都为Null</span><br><span class="line">eg:insert into dept (deptno, dname )</span><br><span class="line"> values (60, &#x27;MIS&#x27;);</span><br><span class="line">——也可以显示的插入NULL</span><br><span class="line">eg: insert into dept</span><br><span class="line"> values (70, &#x27;FINANCE&#x27;, NULL);</span><br><span class="line">——同时在插入的时候也可以一次性插入多个例子</span><br><span class="line">eg: insert into dept</span><br><span class="line"> values (70, &#x27;FINANCE&#x27;, NULL);</span><br><span class="line"> (70, &#x27;FINANCE&#x27;, NULL);</span><br><span class="line"> (70, &#x27;FINANCE&#x27;, NULL);</span><br><span class="line">——在插入的时候可以去用查询函数去进行插入</span><br><span class="line">eg:insert into manager</span><br><span class="line"> select *</span><br><span class="line"> from emp</span><br><span class="line"> where job = &#x27;MANAGER&#x27;;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update </span><br></pre></td></tr></table></figure><h1 id="mysql的一些函数"><a href="#mysql的一些函数" class="headerlink" title="mysql的一些函数"></a>mysql的一些函数</h1><h2 id="SYSDATE"><a href="#SYSDATE" class="headerlink" title="SYSDATE()"></a>SYSDATE()</h2><p>函数记录当前日期和时间，自动记录</p><h1 id="Mysql报错"><a href="#Mysql报错" class="headerlink" title="Mysql报错"></a>Mysql报错</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before start of result set at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException</span><br></pre></td></tr></table></figure><h2 id="After-end-of-result-set-（结果集结束后）"><a href="#After-end-of-result-set-（结果集结束后）" class="headerlink" title="After end of result set （结果集结束后）"></a>After end of result set （结果集结束后）</h2><p>顾名思义，根据这句话的意思我们很容易理解，也就是现在指针的位置是在结果集最后一行之后，没有指向任何数据，所以调用get方法时报错。</p><h2 id="Before-start-of-result-set-（结果集开始前）"><a href="#Before-start-of-result-set-（结果集开始前）" class="headerlink" title="Before start of result set （结果集开始前）"></a>Before start of result set （结果集开始前）</h2><p>和上面的错误是类似的，也就是现在指针的位置在结果集的第一行之前，没有指向任何数据，所以报错</p><p>使用next()函数得到结果的第一行，才可以进行数据的统计</p><p>因为此语句将指针移到下一行，也就是第一行，指针指向数据，所以调用get方法不会报错。</p><h1 id="mysql创建外连接用户——8-0版本"><a href="#mysql创建外连接用户——8-0版本" class="headerlink" title="mysql创建外连接用户——8.0版本"></a>mysql创建外连接用户——8.0版本</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220401192446902-3f21b3.png" alt="image-20220401192446902"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;lsy&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;//创建用户lsy 密码123456</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON*.*TO&#x27;lsy&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220401192841923-34c17a.png" alt="image-20220401192841923"></p><p>连接他人  MySQL -h+IP号 -u+用户号 -p </p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230522113850760-dfcb3b.png" alt="image-20230522113850760"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab的使用</title>
      <link href="/posts/44183.html"/>
      <url>/posts/44183.html</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB"><a href="#MATLAB" class="headerlink" title="MATLAB"></a>MATLAB</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="续行符"><a href="#续行符" class="headerlink" title="续行符"></a>续行符</h2><p>相当于C语言&#x2F;n<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220319144846000-513ff9.png" alt="image-20220319144846000"><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220319144953938-76a692.png" alt="image-20220319144953938"></p><p>注意使用方法</p><h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>clear : 清除命令，删除所有变量</p><p>若出现变量名和函数名重名，变量名优先处理</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220319145705531-a60733.png" alt="image-20220319145705531"></p><p>先执行当前文件下的文件，之后才执行搜索路径下的文件。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>“%”  后面所有文字为注释. </p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="变量及其操作"><a href="#变量及其操作" class="headerlink" title="变量及其操作"></a>变量及其操作</h2><p>（1）变量名必须是不含空格的单个词；<br>（2）变量名区分大小写；<br>（3）变量名最多不超过19个字符；<br>（4）变量名必须以字母打头，之后可以是<br>          任意字母、数字或下划线，变量名中<br>         不允许使用标点符号. </p><p>who 显示 变量名 whos显示全</p><h3 id="内存变量文件"><a href="#内存变量文件" class="headerlink" title="内存变量文件"></a>内存变量文件</h3><p>save:创建内存变量文件</p><p>load：装入内存变量文件</p><p>   eg: save mydata a x   </p><p>  &#x2F;&#x2F;把 a x 变量装在mydata.mat文件中 </p><p>​load mydata</p><p>&#x2F;&#x2F; mydata 保存在当前工作的文件夹中。</p><h2 id="数值数据"><a href="#数值数据" class="headerlink" title="数值数据"></a>数值数据</h2><p>整形：无符号 8 16 32 64</p><p>​有符号8 16 32 64   </p><p>  <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220426180955871-0fe5fe.png" alt="image-20220426180955871"></p><h3 id="uint8"><a href="#uint8" class="headerlink" title="uint8"></a>uint8</h3><p>将数值转化无符号八位整数</p><h3 id="int8"><a href="#int8" class="headerlink" title="int8"></a>int8</h3><p>数据转化成带符号八位整数</p><h3 id="single-函数"><a href="#single-函数" class="headerlink" title="single()函数"></a>single()函数</h3><p>其他类型转化成单精度</p><h3 id="double"><a href="#double" class="headerlink" title="double()"></a>double()</h3><p>其他类型数据转化成双精度</p><h3 id="class"><a href="#class" class="headerlink" title="class()"></a>class()</h3><p>查询变量类型</p><h3 id="复型数据："><a href="#复型数据：" class="headerlink" title="复型数据："></a>复型数据：</h3><p>可用I或者j来表示虚部</p><p> real函数：求复数的实部</p><p> imag函数：求复数的虚部</p><h3 id="format"><a href="#format" class="headerlink" title="format :"></a>format :</h3><p>确定数据格式输出格式</p><p>​       eg: format long</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220426181339294-185177.png" alt="image-20220426181339294"></p><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）如果是向量（无论是行向量还是列向量），都是直接求和</span></span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line">E = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line"><span class="comment">% （2）如果是矩阵，则需要根据行和列的方向作区分</span></span><br><span class="line">clc</span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">% a=sum(x); %按列求和(得到一个行向量）</span></span><br><span class="line">a = sum(E)</span><br><span class="line">a = sum(E,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% a=sum(x,2); %按行求和(得到一个列向量）</span></span><br><span class="line">a = sum(E,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% a=sum(x(:));%对整个矩阵求和</span></span><br><span class="line">a = sum(sum(E))</span><br><span class="line">a = sum(E(:))</span><br></pre></td></tr></table></figure><h3 id="exp函数"><a href="#exp函数" class="headerlink" title="exp函数:"></a>exp函数:</h3><p>以e为底的指数函数</p><h3 id="三角函数："><a href="#三角函数：" class="headerlink" title="三角函数："></a>三角函数：</h3><p>数值若是弧度制则正常，若是角度，则在</p><p>​函数后加上d;</p><p>​eg：sin(pi&#x2F;2) &#x3D;&#x3D; sin(90)</p><h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><p> 对实数：绝对值  ；</p><p> 复数：模长 ；  </p><p> 字符串 ASCII  abs(‘a’) </p><h3 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h3><p>round : 四舍五入</p><p>ceil :向上取整</p><p>floor:向下取整</p><p>fix:舍弃小数</p><h3 id="求余数函数"><a href="#求余数函数" class="headerlink" title="求余数函数"></a>求余数函数</h3><p>rem    mod </p><h3 id="isprime"><a href="#isprime" class="headerlink" title="isprime"></a>isprime</h3><p>判断一个数是否是素数</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find()找到所有非零元素的位置</p><p>find(A&#x3D;&#x3D;1)是1元素的位置</p><h3 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt"></a>sqrt</h3><p>开方函数</p><h3 id="factorial-N"><a href="#factorial-N" class="headerlink" title="factorial(N)"></a>factorial(N)</h3><p>计算阶乘</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="建立矩阵："><a href="#建立矩阵：" class="headerlink" title="建立矩阵："></a>建立矩阵：</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ol><li><p>直接输入法：中括号括起来，同一行用空格或者逗号分开，不同行用分号  eg A&#x3D;[1,2,3,4;5,6,4,7]</p></li><li><p>拼接矩阵：A一个矩阵，B一个矩阵</p></li></ol><p>​C&#x3D;[A,B;B,A]</p><ol start="3"><li>可以用实部矩阵和虚部矩阵构成复数矩阵</li></ol><p>​   C&#x3D;A+Bi</p><ol start="4"><li>冒号表达式</li></ol><p>e1:e2:e3     e1为初始值，e2为步长，e3为终止值</p><ol start="5"><li>linspace</li></ol><p>linspace(a,b,n)     a为第一个元素，b为最后一个元素，n为元素总数，当n省略时，自动产生100个元素</p><h4 id="结构矩阵"><a href="#结构矩阵" class="headerlink" title="结构矩阵"></a>结构矩阵</h4><p>格式为：结构矩阵元素.成员名 &#x3D; 表达式</p><h4 id="单元矩阵"><a href="#单元矩阵" class="headerlink" title="单元矩阵"></a>单元矩阵</h4><p>建立单元矩阵和一般矩阵相似，直接输入就可以了，单元矩阵元素用大括号括起来，eg:b&#x3D;{10,’asd’,60}</p><h4 id="空矩阵"><a href="#空矩阵" class="headerlink" title="空矩阵"></a>空矩阵</h4><p>a&#x3D;[]产生一个空矩阵</p><h4 id="zeros-——全零矩阵"><a href="#zeros-——全零矩阵" class="headerlink" title="zeros()——全零矩阵"></a>zeros()——全零矩阵</h4><p>b&#x3D;zeros(m，n)    产生一个m行、n列的零矩阵</p><h4 id="ones——全为1的矩阵"><a href="#ones——全为1的矩阵" class="headerlink" title="ones——全为1的矩阵"></a>ones——全为1的矩阵</h4><p>c&#x3D;ones(m，n)      产生一个m行、n列的元素全为1的矩阵</p><h4 id="eye——对角线、单位矩阵"><a href="#eye——对角线、单位矩阵" class="headerlink" title="eye——对角线、单位矩阵"></a>eye——对角线、单位矩阵</h4><p>d&#x3D;eye(m，n)     产生一个m行、n列的单位矩阵</p><h3 id="矩阵元素管理"><a href="#矩阵元素管理" class="headerlink" title="矩阵元素管理"></a>矩阵元素管理</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>eg:A(3.2) &#x3D; 100,    如果要赋值的元素范围大于矩阵的范围，那么矩阵将扩充，并且空下来的位置赋值为0</p><h4 id="引用元素"><a href="#引用元素" class="headerlink" title="引用元素"></a>引用元素</h4><p>matlab中按照列存储，引用元素，可以用A（2，3）</p><p>也可以用序号</p><h4 id="sub2ind函数："><a href="#sub2ind函数：" class="headerlink" title="sub2ind函数："></a>sub2ind函数：</h4><p>将矩阵中指定元素的行列转换成存储的序号：D &#x3D; sub2ind(S,I,J).S是行数和列数组成的下标，一般用size函数获取，I为行下标，J为列下标</p><p>计算矩阵中某一个元素在存贮中所处的位置</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220320200403025-3ab692.png" alt="image-20220320200403025"></p><h4 id="ind2sub函数："><a href="#ind2sub函数：" class="headerlink" title="ind2sub函数："></a>ind2sub函数：</h4><h4 id="序号转换成相应的下标"><a href="#序号转换成相应的下标" class="headerlink" title="序号转换成相应的下标"></a>序号转换成相应的下标</h4><p>[I,J] &#x3D; ind2sub(S,D)</p><h4 id="矩阵元素操作"><a href="#矩阵元素操作" class="headerlink" title="矩阵元素操作"></a>矩阵元素操作</h4><p>（1）矩阵A的第r行：A（r，：）</p><p>（2）矩阵A的第r列：A（：，r）</p><p>（3）依次提取矩阵A的每一列，将A拉伸为一个列向量：A（：）</p><p>（4）取矩阵A的第i1<del>i2行、第j1</del>j2列构成新矩阵:A(i1 : i2 ,  j1 : j2)</p><p>（5）以逆序提取矩阵A的第i1~i2行，构成新矩阵:A(i2 : -1：i1，：）</p><p>（6）以逆序提取矩阵A的第j1~j2列，构成新矩阵:A(:,   j2 : -1：j1 ）</p><p>（7）删除A的第i1~i2行，构成新矩阵:A(i1:i2，：)&#x3D;[ ]</p><p>​让要删除的元素变成空 </p><p>​eg:A(:,[2,4]) &#x3D; []&#x2F;&#x2F;让矩阵5和4列元素为空并且合并起来</p><p>（8）删除A的第j1~j2列，构成新矩阵:A(：， j1 : j2)&#x3D;[ ]</p><p>（9）将矩阵A和B拼接成新矩阵：[A  B]；</p><p>​[A；B]</p><h4 id="改成列向量"><a href="#改成列向量" class="headerlink" title="改成列向量"></a>改成列向量</h4><p>A（:）</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>det(A)——方阵的行列式</p><p>inv（A）——方阵的逆</p><p>[V，D]&#x3D;eig[A]——方阵的特征值与特征向量</p><p>求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。（V的每一列都是D中与之相同列的特征值的特征向量）</p><h4 id="end运算符"><a href="#end运算符" class="headerlink" title="end运算符"></a>end运算符</h4><p>表示某一维的末尾元素下标</p><h4 id="reshape函数"><a href="#reshape函数" class="headerlink" title="reshape函数"></a>reshape函数</h4><p>reshape(A,m,n):在矩阵总元素保持不变的前提下将矩阵A重新排成m*n的二维矩阵 ，但不改变矩阵元素的存储序列。</p><h4 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h4><p>返回的俩个整数，一个是矩阵的行数，第二个是矩阵的列数</p><h4 id="repamat"><a href="#repamat" class="headerlink" title="repamat"></a>repamat</h4><p> B &#x3D; repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</p><h2 id="matlab基本运算"><a href="#matlab基本运算" class="headerlink" title="matlab基本运算"></a>matlab基本运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>+加 - * &#x2F;右除 &#x2F;左除   ~乘方</p><p>注：都是基于矩阵运算</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220426181258096-5b98fd.png" alt="image-20220426181258096"></p><p>点运算 .*  ； .&#x2F; ；.&#x2F;；.~；   </p><p>点运算相当于一个矩阵的元素进行运算 eg: A.*B &#x3D;&#x3D; A和B中对应元素相乘</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220426144921741-c547d4.png" alt="image-20220426144921741"></p><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p>&lt; ;&lt;&#x3D;;&gt;;&gt;&#x3D;;&#x3D;&#x3D;;~&#x3D;(不等于)</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>&amp; ， | , ~</p><h3 id="inv求逆矩阵"><a href="#inv求逆矩阵" class="headerlink" title="inv求逆矩阵"></a>inv求逆矩阵</h3><h2 id="字符串数据"><a href="#字符串数据" class="headerlink" title="字符串数据"></a>字符串数据</h2><p>单引号括起来的字符序列</p><p>若要表示一个单引号，则要用两个‘’</p><p>要建立多行字符串，形成一个字符串矩阵，那么对应列要相同</p><h3 id="数字转化为字符串"><a href="#数字转化为字符串" class="headerlink" title="数字转化为字符串"></a>数字转化为字符串</h3><p>num2str(c)</p><h3 id="字符串合并函数"><a href="#字符串合并函数" class="headerlink" title="字符串合并函数"></a>字符串合并函数</h3><p> strcat(‘字符串1’,’字符串2’) </p><p>[‘字符串1’  ‘字符串2’]</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>eval(S) ,S 是字符串，用matlab命令来执行S字符串</p><h3 id="字符串和数值之间转换"><a href="#字符串和数值之间转换" class="headerlink" title="字符串和数值之间转换"></a>字符串和数值之间转换</h3><p>abs和double 把字符串矩阵转换成ASCII数值矩阵</p><p>char把ASCII矩阵转换成字符串矩阵</p><h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><p>相同长度可以用关系运算符，以字符串ASCII值进行比对 eg’www0’&gt;&#x3D;’W123’       ans &#x3D; 1 1 1 0</p><p>strcmp(s1,s2) : 比较两个字符串是否相同</p><p>strncmp(s1,s2,n): 比较两个字符串n个字符前是否相同</p><p>strcmpi(s1,s2): 忽略大小写比较两个字符串是否相同</p><p>strncmpi(s1,s2,n) : 忽略大小比较两个字符串n个字符前是否相同</p><h3 id="字符串查找和替换"><a href="#字符串查找和替换" class="headerlink" title="字符串查找和替换"></a>字符串查找和替换</h3><p>findstr(s1,s2):返回短的字符串在长字符串中的开始位置</p><p>strrep(s1,s2,s3)：将字符串s1中的所有子字符串s2替换成s3</p><h2 id="数组数据"><a href="#数组数据" class="headerlink" title="数组数据"></a>数组数据</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol><li>x&#x3D;[a  b  c  d  e  f ]          创建包含指定元素的行向量</li><li>x&#x3D;first：last<br>创建从first开始，加1计数，到last结束的行向量</li><li>x&#x3D;first：increment：last<br>创建从first开始，加increment计数，last结束的行向量</li><li>x&#x3D;linspace(first，last，n）<br>创建从first开始，到last结束，有n个元素的行向量</li><li>x&#x3D;logspace(first，last，n）<br>创建从开始，到结束，有n个元素的对数分隔行向量</li></ol><h3 id="数组元素访问"><a href="#数组元素访问" class="headerlink" title="数组元素访问"></a>数组元素访问</h3><ol><li>访问一个元素：  x(i)表示访问数组x的第i个元素. </li><li>访问一块元素：  x(a ：b ：c)表示访问数组x的从第a个元素开始，以步长为b到第c个元素（但不超过c），b可以为负数，b缺省时为1. </li><li>直接使用元素编址序号. x([a  b  c  d]) 表示提取数组x的第a、b、c、d个元素构成一个新的数组<br>[x(a)  x(b)    x(c)  x(d)].</li></ol><h3 id="改成列向量-1"><a href="#改成列向量-1" class="headerlink" title="改成列向量"></a>改成列向量</h3><ol><li>可以直接生成 eg: c&#x3D;[1;2;3;4]</li><li>可以转置生成 eg: b&#x3D;[1 2 3 4]; c&#x3D;b’;</li></ol><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><h2 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h2><h3 id="PLOT函数"><a href="#PLOT函数" class="headerlink" title="PLOT函数"></a>PLOT函数</h3><p>PLOT(X,Y,S)，其中X,Y是向量,向量中两两对应，分别表示点集的横坐标和纵坐标，S表示线型，</p><p>eg:        ·y  黄色   . 点   -  连线<br>·m  洋红   o 圈   :  短虚线<br>·c  蓝绿色     x  x-符号       -.  长短线     r  红色        +   加号      –  长虚线</p><p>PLOT(X,Y)–画实线<br>PLOT(X,Y1,S1,X,Y2,S2,……,X,Yn,Sn)  –将多条线画在一起</p><h3 id="符号函数-显函数、隐函数和参数方程"><a href="#符号函数-显函数、隐函数和参数方程" class="headerlink" title="符号函数(显函数、隐函数和参数方程)"></a>符号函数(显函数、隐函数和参数方程)</h3><h4 id="ezplot"><a href="#ezplot" class="headerlink" title="ezplot"></a>ezplot</h4><p>ezplot(‘f(x)’,[a,b]) ——表示在a&lt;x&lt;b绘制显函数f&#x3D;f(x)的函数图</p><p>ezplot(‘f(x,y)’,[xmin,xmax,ymin,ymax])——表示在区间xmin&lt;x&lt;xmax和 ymin&lt;y&lt;ymax绘制隐函数f(x,y)&#x3D;0的函数图</p><p>ezplot(‘x(t)’,’y(t)’,[tmin,tmax])——表示在区间tmin&lt;t&lt;tmax绘制参数方程 x&#x3D;x(t),y&#x3D;y(t)的函数图</p><h4 id="fplot"><a href="#fplot" class="headerlink" title="fplot"></a>fplot</h4><p>fplot(‘fun’,lims)——表示绘制字符串fun指定的函数在lims&#x3D;[xmin,xmax]的图形.</p><p>注意：<br>[1] fun必须是M文件的函数名或是独立变量为x的字符串.<br>[2] fplot函数不能画参数方程和隐函数图形，但在一个图上可以画多个图形。</p><h4 id="对数坐标图——坐标轴是10的多少次方"><a href="#对数坐标图——坐标轴是10的多少次方" class="headerlink" title="对数坐标图——坐标轴是10的多少次方"></a>对数坐标图——坐标轴是10的多少次方</h4><p>loglog(Y)         表示 x、y坐标都是对数坐标系<br>semilogx(Y)       表示 x坐标轴是对数坐标系<br>semilogy(…)      表示y坐标轴是对数坐标系<br>plotyy    有两个y坐标轴，一个在左边，一个在右边</p><h2 id="空间曲线"><a href="#空间曲线" class="headerlink" title="空间曲线"></a>空间曲线</h2><h3 id="一条曲线——PLOT3"><a href="#一条曲线——PLOT3" class="headerlink" title="一条曲线——PLOT3"></a>一条曲线——PLOT3</h3><p>PLOT3(x,y,z,s)——x,y,z，n维向量，分别表示曲线上点集的横坐标、纵坐标、函数值，s是指定颜色、线形等</p><h3 id="多条曲线——PLOT3"><a href="#多条曲线——PLOT3" class="headerlink" title="多条曲线——PLOT3"></a>多条曲线——PLOT3</h3><p>PLOT3(x,y,z)</p><p>其中x，y，z是都是m*n矩阵，其对应的每一列表示一条曲线.</p><h2 id="空间曲面"><a href="#空间曲面" class="headerlink" title="空间曲面"></a>空间曲面</h2><h3 id="surf-x-y-z"><a href="#surf-x-y-z" class="headerlink" title="surf(x,y,z)"></a>surf(x,y,z)</h3><p>其中X,Y,Z，表示数据矩阵。分别表示数据点的横坐标、纵坐标、函数值。画出数据点（x，y，z）表示的曲面</p><h3 id="Mesh-x-y-z"><a href="#Mesh-x-y-z" class="headerlink" title="Mesh(x,y,z)"></a>Mesh(x,y,z)</h3><p>其中X,Y,Z，数据矩阵。分别表示数据点的横坐标、纵坐标、函数值。画网格曲面，基于空间曲面的网格图</p><h3 id="meshz-X-Y-Z"><a href="#meshz-X-Y-Z" class="headerlink" title="meshz(X,Y,Z)"></a>meshz(X,Y,Z)</h3><p>在网格周围画一个curtain图(如,参考平面)</p><h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot"></a>subplot</h3><p>subplot(a,b,c)&#x2F;&#x2F;将这个界面分为a行b列第c个位置</p><h3 id="grid-on"><a href="#grid-on" class="headerlink" title="grid on"></a>grid on</h3><p>grid on 在图上显示网格</p><h3 id="rotate3d"><a href="#rotate3d" class="headerlink" title="rotate3d"></a>rotate3d</h3><p> rotate3d使得图片成3d图片</p><h3 id="meshgrid"><a href="#meshgrid" class="headerlink" title="meshgrid"></a>meshgrid</h3><p>meshgrid(x,y)产生一个以x为行，Y为列的矩阵</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220427211058095-592061.png" alt="image-20220427211058095"></p><h3 id="图像处理光滑"><a href="#图像处理光滑" class="headerlink" title="图像处理光滑"></a>图像处理光滑</h3><p>shading faceted：默认模式，在曲面或图形对象上叠加黑色的网格线；</p><p>shading flat：是在shading faceted的基础上去掉图上的网格线；</p><p>shading interp：对曲面或图形对象的颜色着色进行色彩的插值处理，使色彩平滑过渡 ；</p><h3 id="peaks"><a href="#peaks" class="headerlink" title="peaks"></a>peaks</h3><p>peaks:内部自带的山峰函数</p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停函数，类似与C语言的pause</p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p>注：所有操作都可以在图片上进行操作，**<u>但操作完要保存</u>**</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220427213110340-5af9cb.png" alt="image-20220427213110340"></p><h3 id="在图形上加格栅、图例和标注——可在图片上的插入找到"><a href="#在图形上加格栅、图例和标注——可在图片上的插入找到" class="headerlink" title="在图形上加格栅、图例和标注——可在图片上的插入找到"></a>在图形上加格栅、图例和标注——可在图片上的插入找到</h3><p> grid  ON: 加格栅在当前图上<br>         grid OFF: 删除格栅</p><p> xlabel(string): 在当前图形的x轴上加图例string</p><p> ylabel(string): 在当前图形的y轴上加图例string</p><p>zlabel(string): 在当前图形的z轴上加图例string</p><p>title(string): 在当前图形的顶端上加图例string</p><h3 id="gtext-‘string’"><a href="#gtext-‘string’" class="headerlink" title="gtext(‘string’)"></a>gtext(‘string’)</h3><p>命令gtext(‘string’)用鼠标放置标注在现有的图上.运行命令gtext(‘string’)时，屏幕上出现当前图形，在图形上出现一个交叉的十字，该十字随鼠标的移动移动，当按下鼠标左键时，该标注string放在当前十交叉的位置.</p><h3 id="Axis-定制坐标-——改坐标值"><a href="#Axis-定制坐标-——改坐标值" class="headerlink" title="Axis 定制坐标 ——改坐标值"></a>Axis 定制坐标 ——改坐标值</h3><p>Axis([xmin xmax ymin ymax zmin zmax])x、y、z的最大、最小值，定制图形坐标</p><p>axis off  关闭坐标</p><h3 id="图形保持——简化版就一个图上画多个线"><a href="#图形保持——简化版就一个图上画多个线" class="headerlink" title="图形保持——简化版就一个图上画多个线"></a>图形保持——简化版就一个图上画多个线</h3><p>hold  on   保持当前图形, 以便继续画图到当前图上<br>       hold  of   释放当前图形窗口</p><h3 id="打开一个新窗口"><a href="#打开一个新窗口" class="headerlink" title="打开一个新窗口"></a>打开一个新窗口</h3><p>   figure(h)新建h窗口，激活图形使其可见，并把它置于其它图形之上</p><p>一般配套使用pause 使得在当前窗口下暂停，点击后继续出现另一个窗口</p><h3 id="缩放图形"><a href="#缩放图形" class="headerlink" title="缩放图形"></a>缩放图形</h3><p>zoom  on   为当前图形打开缩放模式</p><p>​      单击鼠标左键，则在当前图形窗口中，以鼠标点中的点为中心的图形放大2倍；单击鼠标右键，则缩小2倍</p><p>zoom  off   关闭缩放模式</p><h3 id="改变视角——没用"><a href="#改变视角——没用" class="headerlink" title="改变视角——没用"></a>改变视角——没用</h3><p>  （1）view(a,b)<br>   命令view(a,b)改变视角到(a,b),a是方位角,b为仰角。缺省视角为（-37.5，30）。</p><p>（2）view（[x，y，z]）</p><p>​      view用空间矢量表示的，三个量只关心它们的比例，与数值的大小无关，x轴view（[1，0，0]），y轴view（[0，1，0]），z轴view（[0，0，1]）。</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>   Moviein(),  getframe,   movie()<br>函数Moviein()产生一个帧矩阵来存放动画中的帧；</p><p>函数getframe对当前的图象进行快照；</p><p>函数movie()按顺序回放各帧。</p><h2 id="特殊二维图形"><a href="#特殊二维图形" class="headerlink" title="特殊二维图形"></a>特殊二维图形</h2><h3 id="极坐标图：polar-theta-rho-s"><a href="#极坐标图：polar-theta-rho-s" class="headerlink" title="极坐标图：polar (theta,rho,s)"></a>极坐标图：polar (theta,rho,s)</h3><p> 用角度theta（弧度表示）和极半径rho作极坐标图，用s指定线型。</p><p>eg: <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220427220013763-6a3093.png" alt="image-20220427220013763"></p><p>在这其中，theta表示变量的取值范围，theta&#x3D;linspace(0,2<em>pi),   rho &#x3D; rho&#x3D;sin(2</em>theta).<em>cos(2</em>theta)；</p><h3 id="散点图-scatter（X-Y-S-C）"><a href="#散点图-scatter（X-Y-S-C）" class="headerlink" title="散点图:  scatter（X,Y,S,C）"></a>散点图:  scatter（X,Y,S,C）</h3><p>​     在向量X和Y的指定位置显示彩色圈．X和Y必须大小相同．</p><h3 id="平面等值线图："><a href="#平面等值线图：" class="headerlink" title="平面等值线图："></a>平面等值线图：</h3><p> contour (x,y,z,n) 绘制n个等值线的二维等值线图</p><h3 id="空间等值线图："><a href="#空间等值线图：" class="headerlink" title="空间等值线图："></a>空间等值线图：</h3><p> contour 3(x,y,z,n)       其中n表示等值线数。</p><h3 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h3><p>scatter3（X,Y,Z,S,C）  在向量X,Y和Z指定的位置上显示彩色圆圈.  向量X,Y和Z的大小必须相同.</p><h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><h2 id="数据拟合"><a href="#数据拟合" class="headerlink" title="数据拟合"></a>数据拟合</h2><p>对于数据拟合，有一个工具箱：cftool拟合工具箱，在聊天框输入cftool即可以打开这个工具，对于工具的具体使用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220526204845956-0340c3.png" alt="image-20220526204845956"></p><p>对于拟合方法：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Custom Equations 用户自定义函数</span><br><span class="line">Expotential e指数函数</span><br><span class="line">Fourier 傅立叶函数，含有三角函数</span><br><span class="line">Gaussian 正态分布函数，高斯函数</span><br><span class="line">Interpolant 插值函数，含有线性函数，移动平均等类型的拟合</span><br><span class="line">Polynomial 多项式函数</span><br><span class="line">Power 幂函数</span><br><span class="line">Rational 有理函数</span><br><span class="line">Smooth Spline （光滑插值或者光滑拟合，不太清楚）</span><br><span class="line">Sum of <span class="built_in">sin</span> functions 正弦函数类</span><br><span class="line">Weibull 威布尔函数</span><br></pre></td></tr></table></figure><h1 id="对于求导公式"><a href="#对于求导公式" class="headerlink" title="对于求导公式"></a>对于求导公式</h1><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>用法1: 格式： int（fun,x,a,b）<br>功能： 计算<a href="https://so.csdn.net/so/search?q=%E5%AE%9A%E7%A7%AF%E5%88%86&spm=1001.2101.3001.7020">定积分</a><br>用法2: 格式： int(f,x)<br>功能： 计算不定积分<br>注： 使用int函数之前， 先用syms声明x是符号变量</p><h1 id="对于特征值求解公式"><a href="#对于特征值求解公式" class="headerlink" title="对于特征值求解公式"></a>对于特征值求解公式</h1><p><strong>eig</strong></p><p>用来求解特征值</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><a href="https://so.csdn.net/so/search?q=matlab&spm=1001.2101.3001.7020">matlab</a>求和，取均值以及计算标准差的时候数据有nan使用下面三个特定的函数<br>（nansum，nanmean，nanstd）</p><h1 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h1><h2 id="randi-产生均匀分布的随机整数（i-int）"><a href="#randi-产生均匀分布的随机整数（i-int）" class="headerlink" title="randi : 产生均匀分布的随机整数（i &#x3D; int）"></a>randi : 产生均匀分布的随机整数（i &#x3D; int）</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%产生一个1至10之间的随机整数矩阵，大小为2x5；</span></span><br><span class="line">s1 = randi(<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个-5至5之间的随机整数矩阵，大小为1x10；</span></span><br><span class="line">s2 = randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">1</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="rand-产生0至1之间均匀分布的随机数"><a href="#rand-产生0至1之间均匀分布的随机数" class="headerlink" title="rand: 产生0至1之间均匀分布的随机数"></a>rand: 产生0至1之间均匀分布的随机数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%产生一个0至1之间的随机矩阵，大小为1x5；</span></span><br><span class="line">s3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个a至b之间的随机矩阵，大小为1x5；  % a + (b-a) * rand(1,5); 如：a,b = 2,5</span></span><br><span class="line">s4= <span class="number">2</span> + (<span class="number">5</span><span class="number">-2</span>) * <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="normrnd-产生正态分布的随机数"><a href="#normrnd-产生正态分布的随机数" class="headerlink" title="normrnd:产生正态分布的随机数"></a>normrnd:产生正态分布的随机数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%产生一个均值为0，标准差（方差开根号）为2的正态分布的随机矩阵，大小为3x4；</span></span><br><span class="line">s5 = normrnd(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="roundn—任意位置四舍五入"><a href="#roundn—任意位置四舍五入" class="headerlink" title="roundn—任意位置四舍五入"></a>roundn—任意位置四舍五入</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 0个位 1十位  2百位 -1小数点后一位  </span></span><br><span class="line">a = <span class="number">3.1415</span></span><br><span class="line">roundn(a,<span class="number">-2</span>)    <span class="comment">% ans   =  3.1400</span></span><br><span class="line">roundn(a,<span class="number">2</span>)      <span class="comment">% ans   =  0</span></span><br><span class="line">a =<span class="number">31415</span></span><br><span class="line">roundn(a,<span class="number">2</span>)   <span class="comment">% ans  = 31400</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">0</span>)  <span class="comment">%6</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">1</span>) <span class="comment">%10</span></span><br></pre></td></tr></table></figure><h1 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220819192855152-f8ad06.png" alt="image-20220819192855152"></p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven操作</title>
      <link href="/posts/56499.html"/>
      <url>/posts/56499.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>提供一套标准化的项目结构，所有软件通过Maven创造，都通用。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601090228589-b27aff.png" alt="image-20220601090228589"></p><p>Maven-project是项目名称，自己命名</p><p>Src放Java代码</p><p>pom.xml——maven配置文件</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601090443982-d0f4b3.png" alt="image-20220601090443982"></p><h1 id="标准化的构建流程"><a href="#标准化的构建流程" class="headerlink" title="标准化的构建流程"></a>标准化的构建流程</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601090609698-b5acd3.png" alt="image-20220601090609698"></p><p>标准是这样，但是Maven提供一个简化操作，可以帮助我们进行编译，打包</p><h1 id="提供依赖管理机制"><a href="#提供依赖管理机制" class="headerlink" title="提供依赖管理机制"></a>提供依赖管理机制</h1><p>管理你项目所依赖的三方资源（JAR）通过标准的坐标配置来管理各种依赖</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601092018371-be6f55.png" alt="image-20220601092018371"></p><p>JAR存放在仓库，在pom.xml中进行引用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601092144687-7e8442.png" alt="image-20220601092144687"></p><p>分为三个：本地仓库——本地仓库，中央仓库，远程仓库（私服）</p><p>去导包，当本地仓库没有这个JAR包，那么就去中央仓库查找，如果有，去中央仓库去进行下载。如果架设了私服，那么要先去私服寻找</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601092525887-0ffcf5.png" alt="image-20220601092525887"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601093608982-24b5fe.png" alt="image-20220601093608982"></p><h1 id="Maven坐标详解"><a href="#Maven坐标详解" class="headerlink" title="Maven坐标详解"></a>Maven坐标详解</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">作为例子来讲解，对于这个<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>指的是Maven项目属于哪个组织名称</span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>当前Maven项目名称</span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号  </span><br></pre></td></tr></table></figure><h1 id="Maven创建"><a href="#Maven创建" class="headerlink" title="Maven创建"></a>Maven创建</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601094331830-501952.png" alt="image-20220601094331830"></p><h1 id="插件——maven-helper"><a href="#插件——maven-helper" class="headerlink" title="插件——maven-helper"></a>插件——maven-helper</h1><p>帮助maven管理</p><h1 id="依赖管理："><a href="#依赖管理：" class="headerlink" title="依赖管理："></a>依赖管理：</h1><p>对于改完后需要进行刷新后才可以生效！！</p><p>自动生效：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601095309047-aee1fa.png" alt="image-20220601095309047"></p><p>对于作用域</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">对于<span class="tag">&lt;<span class="name">scope</span>&gt;</span>作用域<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220601100241457-e05fd1.png" alt="image-20220601100241457"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit操作</title>
      <link href="/posts/31992.html"/>
      <url>/posts/31992.html</url>
      
        <content type="html"><![CDATA[<h2 id="Junit概述"><a href="#Junit概述" class="headerlink" title="Junit概述"></a><code>Junit</code>概述</h2><h2 id="Junit定义："><a href="#Junit定义：" class="headerlink" title="Junit定义："></a><code>Junit</code>定义：</h2><p>官方地址：<code>Junit4</code>——<a href="https://junit.org/junit4/">https://junit.org/junit4/</a> </p><p>​<code>Junit5</code>——<a href="https://junit.org/junit5/">https://junit.org/junit5/</a></p><p>官方文档：</p><p>​<code>JUnit</code> is a simple framework to write repeatable tests. It is an instance of the <code>xUnit</code> architecture for unit testing frameworks.</p><p><code>JUnit</code>是一个编写可重复测试的简单框架。 它是用于单元测试框架的<code>xUnit</code>架构的一个实例。</p><p><code>xUnit</code> 又是什么呢？</p><p><code>xUnit</code>是一套基于测试驱动开发的测试框架。</p><p><code>xUnit</code>包括：<code>PythonUnit</code>、<code>CppUnit</code>等等。<code>JUnit</code>应该算是<code>xUnit</code>家族最成功的一个了。</p><h2 id="为什么要使用Junit"><a href="#为什么要使用Junit" class="headerlink" title="为什么要使用Junit"></a>为什么要使用<code>Junit</code></h2><p>​使用<code>JUnit</code>能够帮助我们减少在开发过程中的错误，把Bug扼杀在萌芽之中，有利于代码的后期维护和检查。做好了单元测试可以缩短开发周期，提高代码质量。这样我们就可以把更多的时间用到我们应该干的事情上来而不是去解决项目后期发现的越来越多的令人头疼的问题。</p><p>测试不是用来证明你是对的，而是用来证明你没有错。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li><code>JUnit</code> 是一个开放的资源框架，用于编写和运行测试。</li><li>提供注释来识别测试方法。</li><li>提供断言来测试预期结果。</li><li>提供测试运行来运行测试。</li><li><code>JUnit</code>测试允许你编写代码更快，并能提高质量。</li><li><code>JUnit</code> 优雅简洁。没那么复杂，花费时间较少。</li><li><code>JUnit</code> 测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。</li><li><code>JUnit</code> 测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。</li><li><code>JUnit</code> 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse:"></a>eclipse:</h3><p>方法一：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605144353007-4a79b3.png" alt="image-20220605144353007"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605144648929-da32b2.png" alt="image-20220605144648929"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605145231847-d13da1.png" alt="image-20220605145231847"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605145258357-03fadb.png" alt="image-20220605145258357"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605145325484-34ca47.png" alt="image-20220605145325484"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitText</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">text</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello, Junit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605145804068-e672ce.png" alt="image-20220605145804068"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20140708111458906-4a1941.png" alt="img"></p><p>Junit Window 有以下特性：</p><ul><li><strong>① Runs:</strong> 显示了执行了的junit测试用例(方法)总数</li><li><strong>② Errors:</strong> 显示结果为error&#x2F;exception的测试用例总数</li><li>**③ Failures:**显示测试用例执行失败总数</li><li>**④ Failure Trace:**展示 error&#x2F;exception or failure trace</li><li>**⑤ Show Failures Only:**只显示失败的用例信息</li><li>**⑥ Scroll Lock:**scroll lock</li><li><strong>⑦ Rerun Test:</strong> 重新运行测试用例</li><li>**⑧ Rerun Test – Failure First:**重新运行测试用例，先执行失败了的测试用例</li><li>**⑨ Stop Junit Test Run:**停止单元测试</li><li>**⑩ Test Run History:**显示测试用例运行历史</li></ul><p>方法二：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605150655607-ee1c5f.png" alt="image-20220605150655607"></p><h3 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605151417275-506e07.png" alt="image-20220605151417275"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605151729972-d722a7.png" alt="image-20220605151729972"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605151745079-358a02.png" alt="image-20220605151745079"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitText</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">text</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,junit!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><p>打开<code>pom.xml</code>文件配置下面这段话<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605153216693-6716d9.png" alt="image-20220605153216693"></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  maven自动配置在test区域内运行</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Junit入门"><a href="#Junit入门" class="headerlink" title="Junit入门"></a>Junit入门</h2><p>用JUnit写单元测试，首先是定义一个单元测试类；然后在类中定义测试方法，使用@Test标签即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJunit</span><span class="params">()</span> &#123;</span><br><span class="line">        String str= <span class="string">&quot;Junit is working fine&quot;</span>;</span><br><span class="line">        assertEquals(<span class="string">&quot;Junit is working fine&quot;</span>,str);</span><br><span class="line"><span class="comment">//        assertTrue(&quot;Junit is working fine&quot; == str);</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>断言</strong></p><p>对于上述每一个方法，都可以在最前面增加一个String类型的参数message，作为失败时的错误提示</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>assertEquals(expected, actual)</td><td>验证预期值与真实值是否相等，Fail则给出错误提示，message是一个可供选择的String，用来在Fail时给出错误提示</td></tr><tr><td>assertEquals(expected, actual, delta)</td><td>对浮点数类型的判断提供一定的容错</td></tr><tr><td>assertTrue(boolean condition)</td><td>验证contidion的值是true</td></tr><tr><td>assertFalse(boolean condition)</td><td>验证contidion的值是false</td></tr><tr><td>assertNull(Object obj)</td><td>验证obj的值是null</td></tr><tr><td>assertNotNull(Object obj)</td><td>验证obj的值不是null</td></tr><tr><td>assertSame(expected, actual)</td><td>验证expected和actual是同一个对象，即指向同一个对象</td></tr><tr><td>assertNotSame(expected, actual)</td><td>验证expected和actual不是同一个对象，即指向不同的对象</td></tr><tr><td>assertArrayEquals(expectedArray, resultArray)</td><td>验证两个数组是否相等</td></tr><tr><td>fail()</td><td>让测试方法失败</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAssertions</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//test data</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span> (<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span> (<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    String[] expectedArray = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">    String[] resultArray =  &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check that two objects are equal</span></span><br><span class="line">    assertEquals(str1, str4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check that a condition is true</span></span><br><span class="line">    assertTrue (val1 &lt; val2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check that a condition is false</span></span><br><span class="line">    assertFalse(val1 &gt; val2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check that an object isn&#x27;t null</span></span><br><span class="line">    assertNotNull(str6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check that an object is null</span></span><br><span class="line">    assertNull(str3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check if two object references point to the same object</span></span><br><span class="line">    assertSame(str4,str5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check if two object references not point to the same object</span></span><br><span class="line">    assertNotSame(str1,str2);</span><br><span class="line">    assertNotSame(str1,str4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check whether two arrays are equal to each other.</span></span><br><span class="line">    assertArrayEquals(expectedArray, resultArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong></p><ul><li><p>beforeClass() 方法首先执行，并且只执行一次。</p></li><li><p>afterClass() 方法最后执行，并且只执行一次。</p></li><li><p>before() 方法针对每一个测试用例执行，但是是在执行测试用例之前。</p></li><li><p>after() 方法针对每一个测试用例执行，但是是在执行测试用例之后。</p></li><li><p>在 before() 方法和 after() 方法之间，执行每一个测试用例。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execute only once, in the starting</span></span><br><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;in before class&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//execute only once, in the end</span></span><br><span class="line"><span class="meta">@AfterClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">afterClass</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;in after class&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//execute for each test, before executing test</span></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;in before&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//execute for each test, after executing test</span></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;in after&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test case 1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCase1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;in test case 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test case 2</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCase2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;in test case 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试套件</strong></p><p>在实际项目中，随着项目进度的开展，单元测试类会越来越多，可是直到现在我们还只会一个一个的单独运行测试类，这在实际项目实践中肯定是不可行的。为了解决这个问题，JUnit 提供了一种批量运行测试类的方法，叫做测试套件。</p><p>这样，每次需要验证系统功能正确性时，只执行一个或几个测试套件便可以了。测试套件的写法非常简单，我们需要遵循以下规则：</p><ol><li>创建一个空类作为测试套件的入口。</li><li>使用注解 org.junit.runner.RunWith 和 org.junit.runners.Suite.SuiteClasses 修饰这个空类。</li><li>将 org.junit.runners.Suite 作为参数传入注解 RunWith，以提示 JUnit 为此类使用套件运行器执行。</li><li>将需要放入此测试套件的测试类组成数组作为注解 SuiteClasses 的参数。</li><li>保证这个空类使用 public 修饰，而且存在公开的不带有任何参数的构造函数</li></ol><p>新建JunitTestOne测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试一。。。&quot;</span>);  </span><br><span class="line">    Assert.assertTrue(<span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建JunitTestTwo测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;测试二。。。&quot;</span>);  </span><br><span class="line">     Assert.assertTrue(<span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试套件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(Suite.class)</span></span><br><span class="line"><span class="meta">@SuiteClasses(&#123; JunitTestOne.class,JunitTestTwo.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllTests</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>很多时候，因为某些原因（比如正式代码还没有实现等），我们可能想让JUnit忽略某些方法，让它在跑所有测试方法的时候不要跑这个测试方法。要达到这个目的也很简单，只需要在要被忽略的测试方法前面加上 @Ignore 就可以了</p><p>@Test(expected &#x3D; IllegalArgumentException.class) 表示验证这个测试方法将抛出 IllegalArgumentException 异常，如果没有抛出的话，则测试失败。</p><h2 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h2><p>有时候当你测试类的时候，当中有的方法还没有完全写好，这时测试用例去测试就可能会失败。</p><p>@Ignore注释可以解决这个问题。</p><h3 id="创建一个类"><a href="#创建一个类" class="headerlink" title="创建一个类"></a>创建一个类</h3><p>先创建一个被测试的类MessageUtil.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个类用于打印给定的message</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageUtil</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.message=message;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行打印</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">printMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向message中添加一个”hi！“</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">salutationMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        message = <span class="string">&quot;hi!&quot;</span>+message;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Test-Case类"><a href="#创建Test-Case类" class="headerlink" title="创建Test Case类"></a>创建Test Case类</h3><p>1.创建TestJunit.java测试类用以测试<code>printMessage</code>方法（打印message）与<code>salutationmessage</code>方法（在message中添加”hi!”）</p><p>2.在类中加入测试方法<code>TestPrintMessage()</code> 和 <code>testSalutationMessage()</code></p><p>3.在<code>TestPrintMessage()</code> 上添加@Ignore</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Ignore;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testcase</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;I is back&quot;</span>;</span><br><span class="line">    <span class="type">MessageUtil</span> <span class="variable">messageUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageUtil</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside testPrintMessage()&quot;</span>);</span><br><span class="line">        message = <span class="string">&quot;Robert&quot;</span>;</span><br><span class="line">        <span class="comment">//设置断言</span></span><br><span class="line">        assertEquals(message,messageUtil.printMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSalutationMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside testSalutationMessage()&quot;</span>);</span><br><span class="line">        message = <span class="string">&quot;Hi!&quot;</span> + <span class="string">&quot;i am back&quot;</span>;</span><br><span class="line">        <span class="comment">//设置断言</span></span><br><span class="line">        assertEquals(message,messageUtil.salutationMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Test-Runner"><a href="#创建Test-Runner" class="headerlink" title="创建Test Runner"></a>创建Test Runner</h3><p>用来执行测试用例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.JUnitCore;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.Result;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.notification.Failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> JUnitCore.runClasses(Testcase.class);</span><br><span class="line">        <span class="keyword">for</span>(Failure failure:result.getFailures())&#123;</span><br><span class="line">            System.out.println(failure.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.wasSuccessful());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证输出</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605145831105-fb200f.png" alt="image-20220605145831105"></p><p>现在可以尝试在类的级别上使用@Ignore，可以保持Test Runner不变（将@Ignore注解放到类上）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Ignore;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testcase</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;I is back&quot;</span>;</span><br><span class="line">    <span class="type">MessageUtil</span> <span class="variable">messageUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageUtil</span>(message);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside testPrintMessage()&quot;</span>);</span><br><span class="line">        message = <span class="string">&quot;Robert&quot;</span>;</span><br><span class="line">        assertEquals(message,messageUtil.printMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSalutationMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside testSalutationMessage()&quot;</span>);</span><br><span class="line">        message = <span class="string">&quot;Hi!&quot;</span> + <span class="string">&quot;i am back&quot;</span>;</span><br><span class="line">        assertEquals(message,messageUtil.salutationMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Test runner 验证输出</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605150144513-748d63.png" alt="image-20220605150144513"></p><p>没有测试用例被测试。</p><h2 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h2><p>Junit提供了一个暂停的方便选项，如果测试用例花费时间超出指定毫秒数，Junit将会将他标记为失败。这需要timeout参数和@Test注释一起使用：@Test(timeout)</p><h3 id="创建一个类-1"><a href="#创建一个类-1" class="headerlink" title="创建一个类"></a>创建一个类</h3><p>1.沿用已经创建的MessageUtil.java</p><p>2.在<code>printMessage()</code>方法中添加一个while死循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行打印</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">printMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Testcase类"><a href="#Testcase类" class="headerlink" title="Testcase类"></a>Testcase类</h3><p>在<code>testPrintMessage()</code>测试用例添加1000ms的暂停时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(timeout=1000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Inside testPrintMessage()&quot;</span>);</span><br><span class="line">    message = <span class="string">&quot;Robert&quot;</span>;</span><br><span class="line">    assertEquals(message,messageUtil.printMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行TestRunner.java</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605151541158-3bbdee.png" alt="image-20220605151541158"></p><p><code>testPrintMessage()</code> 测试用例将标记单元测试失败。</p><h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>Junit用代码处理提供一个追踪异常的选项。你可以测试代码是否它抛出了想要得到的异常，这需要用到expected参数与@Test一起使用：@Test(expected)</p><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>我们仍然沿用<code>MessageUtil.java</code>(稍稍改动下)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">1</span>/a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test-Case类"><a href="#Test-Case类" class="headerlink" title="Test Case类"></a>Test Case类</h3><p>给 <code>testPrintMessage()</code> 测试用例添加需要的异常 <code>ArithmeticException</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = ArithmeticException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintMessage</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Inside testPrintMessage()&quot;</span>);</span><br><span class="line">messageUtil.printMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Test Runner</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605153208339-27c785.png" alt="image-20220605153208339"></p><p>测试用例通过，说明我们得到了想要的异常</p><h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>参数化测试允许开发人员使用不同的值反复运行同一个测试。</p><p>遵循5个步骤来创建参数化测试（稍后）</p><h3 id="创建一个类-2"><a href="#创建一个类-2" class="headerlink" title="创建一个类"></a>创建一个类</h3><p>创建一个叫做 PrimeNumberChecker.java 的 java 类来测试（检测一个数是否是质数）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeNumberCheker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">validate</span><span class="params">(<span class="keyword">final</span> Integer primeNumber)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;(primeNumber/<span class="number">2</span>);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primeNumber%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Parameterized-Test-Case-类"><a href="#创建Parameterized-Test-Case-类" class="headerlink" title="创建Parameterized Test Case 类"></a>创建Parameterized Test Case 类</h3><ol><li><p>用<code>@RunWith(Parameterized.class)</code>来注释test类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(Parameterized.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterizedTestCase</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个由@Parameters注释的公共的静态方法，他返回一个对象的集合（数组）来作为测试数据集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Parameterized</span>.Parameters</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title function_">primeNumbers</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[][] &#123;</span><br><span class="line">            &#123; <span class="number">2</span>, <span class="literal">true</span> &#125;,</span><br><span class="line">            &#123; <span class="number">6</span>, <span class="literal">false</span> &#125;,</span><br><span class="line">            &#123; <span class="number">19</span>, <span class="literal">true</span> &#125;,</span><br><span class="line">            &#123; <span class="number">22</span>, <span class="literal">false</span> &#125;,</span><br><span class="line">            &#123; <span class="number">23</span>, <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个公共构造函数，他接受和一行测试工具相等同的东西</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ParameterizedTestCase</span><span class="params">(Integer inputNumber,Boolean expectecResult)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.inputNumber = inputNumber;</span><br><span class="line">    <span class="built_in">this</span>.expectedResult = expectecResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为每一列测试数据创建一个实例变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PrimeNumberCheker primeNumberChecker;</span><br></pre></td></tr></table></figure></li><li><p>用实例变量作为测试数据的来源来创建你的测试用例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumberChecker</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Parameterized Number is : &quot;</span> + inputNumber);</span><br><span class="line">    assertEquals(expectedResult,</span><br><span class="line">            primeNumberChecker.validate(inputNumber));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>每一行数据都将在测试用例中被调用。</p><p>验证输出</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220605163736065-8c4f8a.png" alt="image-20220605163736065"></p><h3 id="全部正确"><a href="#全部正确" class="headerlink" title="全部正确"></a>全部正确</h3>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作</title>
      <link href="/posts/3828.html"/>
      <url>/posts/3828.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。简单的来说就是用来管理多人协同开发项目的技术。</p><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>对于本地来记录文件的每次更新，例如<code>wps</code>进行版本记录，记录每次本地的修改时间</p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p>文件放在服务器（统一的地方），协同开发者从服务器上同步更新或上传自己的修改，不过容易出现单点故障问题，服务器崩溃，所有代码都没了，每个人只有自己的代码，只有去服务器才能看历史记录，没有完整的代码</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>每个人都有全部代码，可以离线在本地提交，等联网后可以push上去</p><h3 id="Git和SVN区别"><a href="#Git和SVN区别" class="headerlink" title="Git和SVN区别"></a>Git和SVN区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。</p><h2 id="基本linx命令"><a href="#基本linx命令" class="headerlink" title="基本linx命令"></a>基本<code>linx</code>命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd : 改变目录。</span><br><span class="line"></span><br><span class="line">cd .. 回退到上一个目录，直接cd进入默认目录 注意中间有个空格</span><br><span class="line"></span><br><span class="line">pwd : 显示当前所在的目录路径。</span><br><span class="line">    </span><br><span class="line">clear 清屏。</span><br><span class="line"></span><br><span class="line">ls:  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</span><br><span class="line"></span><br><span class="line">touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</span><br><span class="line"></span><br><span class="line">rm:  删除一个文件, rm index.js 就会把index.js文件删除。</span><br><span class="line"></span><br><span class="line">mkdir:  新建一个目录,就是新建一个文件夹。</span><br><span class="line"></span><br><span class="line">rm -r :  删除一个文件夹, rm -r src 删除src目录</span><br><span class="line"></span><br><span class="line">提示：： rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</span><br><span class="line">    </span><br><span class="line">mv 移动文件, </span><br><span class="line">eg: mv index.html src      </span><br><span class="line">    其中index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</span><br><span class="line"></span><br><span class="line">reset 重新初始化终端/清屏。</span><br><span class="line"></span><br><span class="line">history 查看命令历史。</span><br><span class="line"></span><br><span class="line">help 帮助。</span><br><span class="line"></span><br><span class="line">exit 退出。</span><br><span class="line"></span><br><span class="line">#表示注释</span><br></pre></td></tr></table></figure><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看配置文件</span><br><span class="line">git config -l </span><br><span class="line"></span><br><span class="line">查看系统配置文件</span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line">查看用户自己配置文件</span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure><h2 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h2><p>git一般有四个区域，工作目录，暂存区，资源库，远程库</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221111182239587-c6c93e.png" alt="image-20221111182239587"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Workspace：工作区，就是你平时存放项目代码的地方</span><br><span class="line"></span><br><span class="line">Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息(一般显示不出来)</span><br><span class="line"></span><br><span class="line">Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</span><br><span class="line"></span><br><span class="line">Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提交流程：</span><br><span class="line">本地仓库 git add .    //将所有文件提交到暂存区</span><br><span class="line">暂存区  git commit    //文件提交到本地仓库</span><br><span class="line">本地仓库  git push   //本地仓库提交到远程仓库</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><h3 id="git初始化——本地仓库搭建"><a href="#git初始化——本地仓库搭建" class="headerlink" title="git初始化——本地仓库搭建"></a>git初始化——本地仓库搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建全新的仓库</span><br><span class="line">git init   // git 文件初始化,初始化为git，初始化本地仓库</span><br><span class="line"></span><br><span class="line">克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</span><br><span class="line">git clone &#123;url&#125;  //git 克隆来进行初始化</span><br></pre></td></tr></table></figure><h3 id="git文件操作"><a href="#git文件操作" class="headerlink" title="git文件操作"></a>git文件操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态加入到暂存区中变为Staged.</span><br><span class="line"></span><br><span class="line">Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</span><br><span class="line"></span><br><span class="line">Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这里面！！这个git checkout即从库中取出文件, 覆盖当前修改 !</span><br><span class="line"></span><br><span class="line">Staged: 暂存状态. 执行git commit则将修改同步到本地库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified（回滚）</span><br></pre></td></tr></table></figure><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"> git add .                  添加所有文件到暂存区</span><br><span class="line"> git commit -m <span class="string">&quot;消息内容&quot;</span>    提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line"> git log   提交记录</span><br><span class="line">    </span><br><span class="line"> 回滚</span><br><span class="line">git reset --hard 《commitID》  其中commitID可以通过git log查看</span><br><span class="line">    会直接重置为这个时候的版本，</span><br><span class="line">    </span><br><span class="line">git reflog    显示当前分支的最近几次提交    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line">    </span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line">    </span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line">    </span><br><span class="line">下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line">   # 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line">    </span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在主目录下建立”<code>.gitignore</code>“文件，此文件有如下规则：</p><ol><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[<code>abc</code>]）代表可选字符范围，大括号（{<code>string1</code>,<code>string2</code>,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure></li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>更多git细节去<code>gitee</code>下方的链接去进行操作 ————OVER</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221111194849215-931dc9.png" alt="image-20221111194849215"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录</title>
      <link href="/posts/39410.html"/>
      <url>/posts/39410.html</url>
      
        <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">插入的元素有顺序，里面的元素有优先级，对于元素的排序即可</span><br><span class="line"></span><br><span class="line">初级实现方法：</span><br><span class="line"><span class="number">1.</span>数组实现，无序数组进行实现， 对于元素进来，让元素直接插入到数组中，当需要出战的时候，对数组进行遍历，找到数组中最大的元素，将它和数组最后一个元素交换，之后将最后一个数组元素赋值为<span class="literal">null</span></span><br><span class="line"><span class="number">2.</span>数组实现，有序，对存放进数组的元素，按照一个大小顺序进行排序插入，即插入一个元素放在末尾，然后用交换的方式交换到它合适的位置即可。</span><br><span class="line"><span class="number">3</span>用链表表示,插入就简单的插入，但是要进行出队列的时候，需要对整个链表进行遍历，然后找到最大的，进行出链表。</span><br><span class="line">    </span><br><span class="line">堆实现可以使得复杂度在o(logn)  -&gt;以<span class="number">2</span>为底，因为可以显然得出对于一棵树的高度，是二的幂次才会加一</span><br><span class="line">对于一个含有N个元素的基于堆的优先队列，插入元素操作需要lgN+<span class="number">1</span>次比较，删除元素操作需要不超过2lgN次比较</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于堆实现优先队列来说，可以将堆按照数组的方式进行存储，可以很容易证得 对于k节点的左节点是2k，右节点是2k+<span class="number">1</span>,所以需要以这种方式来进行实现。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">实现：</span><br><span class="line">    需要一个数组（不一定的整数数组，Comparable去存储）去存储当前队列元素</span><br><span class="line">    需要N存储当前队列元素个数</span><br><span class="line">    less方法用来比较两个元素大小</span><br><span class="line">    exch方法用来交换两个元素位置</span><br><span class="line">    一个上浮函数去进行元素上调，当一个元素加入到底部的时候，需要上调放到合适的位置，和他所在二叉树的根节点进行比较，如果大于根节点，那么就往上浮，直到上升到根</span><br><span class="line">    一个下沉函数进行函数下调，当前节点和子节点比较，如果小于最大子节点，那么下沉交换位置到合适位置即可。</span><br><span class="line">    </span><br><span class="line">    插入：将一个元素放入堆最后，之后上升即可</span><br><span class="line">    删除：将最后一个元素放在根节点，然后进行下沉，根节点数量减少</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230308191513580-0fd0af.png" alt="image-20230308191513580"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue()   无参构造器，默认容量<span class="number">11</span>和自然顺序进行排序</span><br><span class="line">PriorityQueue(<span class="type">int</span> capacity)  指定大小</span><br><span class="line">PriorityQueue(Comparator&lt;?<span class="built_in">super</span> E&gt; comparator) 采用自己定义比较器</span><br><span class="line">    eg:PriorityQueue&lt;Integer&gt; minTop = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k,(a, b) -&gt; a -b);</span><br><span class="line"> <span class="comment">// k 堆的初始容量，(a,b) -&gt; a -b 比较器</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; <span class="comment">//在队尾插入元素，插入失败时抛出异常，并调整堆结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>; <span class="comment">//在队尾插入元素，插入失败时抛出false，并调整堆结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span>; <span class="comment">//获取队头元素并删除，并返回，失败时前者抛出异常，再调整堆结构</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>; <span class="comment">//获取队头元素并删除，并返回，失败时前者抛出null，再调整堆结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span>; <span class="comment">//返回队头元素（不删除），失败时前者抛出异常</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>；<span class="comment">//返回队头元素（不删除），失败时前者抛出null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">//获取队列中元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">//清空队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>; <span class="comment">//判断队列中是否包含指定元素（从队头到队尾遍历）</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>; <span class="comment">//迭代器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>Deque是double ended queue，将其理解成双端结束的队列，双端队列，可以在首尾插入或删除元素。</p><h2 id="接口分析"><a href="#接口分析" class="headerlink" title="接口分析"></a>接口分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addFirst(): 向队头插入元素，如果元素为空，则发生NPE(空指针异常)</span><br><span class="line">addLast(): 向队尾插入元素，如果为空，则发生NPE</span><br><span class="line"><span class="title function_">offerFirst</span><span class="params">()</span>: 向队头插入元素，如果插入成功返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line"><span class="title function_">offerLast</span><span class="params">()</span>: 向队尾插入元素，如果插入成功返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line"><span class="title function_">removeFirst</span><span class="params">()</span>: 返回并移除队头元素，如果该元素是<span class="literal">null</span>，则发生NoSuchElementException</span><br><span class="line"><span class="title function_">removeLast</span><span class="params">()</span>: 返回并移除队尾元素，如果该元素是<span class="literal">null</span>，则发生NoSuchElementException</span><br><span class="line"><span class="title function_">pollFirst</span><span class="params">()</span>: 返回并移除队头元素，如果队列无元素，则返回<span class="literal">null</span></span><br><span class="line"><span class="title function_">pollLast</span><span class="params">()</span>: 返回并移除队尾元素，如果队列无元素，则返回<span class="literal">null</span></span><br><span class="line"><span class="title function_">getFirst</span><span class="params">()</span>: 获取队头元素但不移除，如果队列无元素，则发生NoSuchElementException</span><br><span class="line"><span class="title function_">getLast</span><span class="params">()</span>: 获取队尾元素但不移除，如果队列无元素，则发生NoSuchElementException</span><br><span class="line"><span class="title function_">peekFirst</span><span class="params">()</span>: 获取队头元素但不移除，如果队列无元素，则返回<span class="literal">null</span></span><br><span class="line"><span class="title function_">peekLast</span><span class="params">()</span>: 获取队尾元素但不移除，如果队列无元素，则返回<span class="literal">null</span></span><br><span class="line"><span class="title function_">pop</span><span class="params">()</span>: 弹出栈中元素，也就是返回并移除队头元素，等价于removeFirst()，如果队列无元素，则发生NoSuchElementException</span><br><span class="line"><span class="title function_">push</span><span class="params">()</span>: 向栈中压入元素，也就是向队头增加元素，等价于addFirst()，如果元素为<span class="literal">null</span>，则发生NPE，如果栈空间受到限制，则发生IllegalStateException</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayDeque: 基于数组实现的线性双向队列，通常作为栈或队列使用，但是栈的效率不如LinkedList高。</span><br><span class="line">LinkedList: 基于链表实现的链式双向队列，通常作为栈或队列使用，但是队列的效率不如ArrayQueue高</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230329194214638-5b7ee4.png" alt="image-20230329194214638"></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230301170137604-0116a2.png" alt="image-20230301170137604"></p><p>利用hashMap进行计算</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230301203758010-858189.png" alt="image-20230301203758010"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230301213501073-22055d.png" alt="image-20230301213501073"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230301212402511-1884d1.png" alt="image-20230301212402511"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230305151027297-702e49.png" alt="image-20230305151027297"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230306195849654-7eafb6.png" alt="image-20230306195849654"></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>对Map数组进行遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; en=buy.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : en) &#123;</span><br><span class="line">    String key=entry.getKey();</span><br><span class="line">    Integer value=entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;-&gt;&gt;&gt;&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map对不存在的数组进行填充</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="number">11</span>);</span><br><span class="line">     map.put(<span class="number">2</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 存在Key1，返回11</span></span><br><span class="line">    System.out.println(map.getOrDefault(<span class="number">1</span>,<span class="number">22</span>));</span><br><span class="line">    <span class="comment">// 不存在Key3，返回默认值33</span></span><br><span class="line">    System.out.println(map.getOrDefault(<span class="number">3</span>,<span class="number">33</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(map.getOrDefault(<span class="number">2</span>,<span class="number">33</span>));</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line">    <span class="literal">null</span>    -&gt;  因为有键<span class="number">2</span>所以是<span class="literal">null</span></span><br><span class="line">由于该方法判定条件是只要满足获取的值不为空或者包含对应的key则不返回默认值，意味着就算出现key to <span class="literal">null</span>这种键值对时，依然返回<span class="literal">null</span>而不是默认值</span><br></pre></td></tr></table></figure><p>将数组全部填充为一个元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(array, -<span class="number">1</span>)  -&gt; 将array数组全部填充为-<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取字符串长度</span><br><span class="line">length（）</span><br><span class="line"></span><br><span class="line">字符串查找</span><br><span class="line">indexOf（）【首次出现】         lastIndexOf（）【最后出现】</span><br><span class="line"></span><br><span class="line">获取指定索引位置的字符 </span><br><span class="line">charAt（）</span><br><span class="line"></span><br><span class="line">字符串截取</span><br><span class="line">substring（<span class="type">int</span> beginIndex)</span><br><span class="line">substring (<span class="type">int</span> beginIndex，<span class="type">int</span> endIndex【不截】)</span><br><span class="line"></span><br><span class="line">去掉前导和尾部的空格</span><br><span class="line">trim（）</span><br><span class="line"></span><br><span class="line">字符串替换 </span><br><span class="line">replace（<span class="type">char</span> oldChar，<span class="type">char</span> newChar）</span><br><span class="line"></span><br><span class="line">判断字符串的开始与结尾 </span><br><span class="line">startsWith（String prefix）</span><br><span class="line">endsWith（String suffix）</span><br><span class="line"></span><br><span class="line">比较字符串内容是否相等</span><br><span class="line">equals（String otherstr）</span><br><span class="line">equalsIgnoreCase（String otherstr）</span><br><span class="line"></span><br><span class="line">按字典顺序比较两个字符串</span><br><span class="line">compareTo（String otherstr）</span><br><span class="line"></span><br><span class="line">字母大小写转换</span><br><span class="line">toLowerCase（）</span><br><span class="line">toUpperCase（）</span><br><span class="line"></span><br><span class="line">字符串分割</span><br><span class="line">split（String sign）</span><br><span class="line">split（String sign，<span class="type">int</span> limit）</span><br><span class="line"></span><br><span class="line">格式化字符串   静态方法</span><br><span class="line">format（String format，Object···args）</span><br><span class="line">format(Local l，String format，Object···args）</span><br><span class="line"></span><br><span class="line">字符串生成器</span><br><span class="line">StringBuilder类的  append（content）    </span><br><span class="line">insert（<span class="type">int</span> offset，arg）    </span><br><span class="line">delete（<span class="type">int</span> start，<span class="type">int</span> end）</span><br><span class="line">       </span><br><span class="line">分割字符串以连续的空格进行分割</span><br><span class="line">       </span><br><span class="line"> s.split(<span class="string">&quot;\\s+&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="字符判断"><a href="#字符判断" class="headerlink" title="字符判断"></a>字符判断</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A-Z  ASSIC码的范围为 <span class="number">65</span>-<span class="number">90</span></span><br><span class="line">a-z     范围为 <span class="number">97</span> - <span class="number">122</span></span><br><span class="line">    </span><br><span class="line">Character.isLowerCase(<span class="type">char</span>)  -&gt;判断字符是否小写</span><br><span class="line">Character.isUpperCase(<span class="type">char</span>)  -&gt; 判断字符是否大写</span><br><span class="line">Character.isLetterOrDigit -&gt; 判断字符是否是大小写和数字</span><br><span class="line"><span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">字符数组转化为字符串 -&gt;              <span class="keyword">new</span> <span class="title class_">String</span>(temp);  其中temp为字符数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><code>KMP</code>算法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KMP算法适用于模式串的匹配，相当于indexof() 这个函数方法， 复杂度也是o()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP算法，适用于字符串匹配问题，</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 简单的来说就是对于长字符串，遍历一遍就可以知道是否包含短字符串</span></span><br><span class="line"><span class="comment"> * 长字符串的遍历从头遍历到尾部，</span></span><br><span class="line"><span class="comment"> * 刚开始的匹配和双指针类似，但是如果遇到两个指针所指向的字符不匹配，KMP算法会寻找next数组，将短字符指针移动到数组的位置</span></span><br><span class="line"><span class="comment"> * next数组存储的是相同前缀位置，遇到不同将指针跳转到前缀位置即可。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 具体解法看https://leetcode.cn/problems/</span></span><br><span class="line"><span class="comment"> * find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">haystack</span> <span class="operator">=</span> <span class="string">&quot;aabaaabaaac&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">needle</span> <span class="operator">=</span> <span class="string">&quot;aabaaac&quot;</span>;</span><br><span class="line">        System.out.println(KMP(haystack, needle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目描述</span></span><br><span class="line"><span class="comment">     * 给你两个字符串 haystack 和 needle ，</span></span><br><span class="line"><span class="comment">     * 请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">KMP</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> needle.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] father = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] son = needle.toCharArray();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 首先构造next数组进行计算</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 首先讲解一下原理，对于第i个字符，需要找到 0  -  i-1 中相同的真字串，</span></span><br><span class="line"><span class="comment">         * 通俗的来说，如果当前指针j指针位于K，那么如果能找到p[0] - p[K] == p[i-k] - p[i]</span></span><br><span class="line"><span class="comment">         * 那么相当于i+1字符串和k+1字符串有相同的前缀，那么p[i+1] 的值就 = k+1 ; 不相等的时候跳转到相同前缀字符串继续进行比较</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//对初始化节点进行构造，</span></span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从i = 1 开始匹配</span></span><br><span class="line">        <span class="comment">//定义i是右指针，j是左指针进行遍历</span></span><br><span class="line">        <span class="comment">//注意，这里j不能定义为-1,如果定义为-1那么直接跳过了p0和p1的比较，</span></span><br><span class="line">        <span class="comment">//这是一个关键点。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里i小于n-1，因为对于最后一位字符，不需要进行跳转，所以不需要对最后一位字符进行存贮。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || son[i] == son[j]) &#123;</span><br><span class="line">                next[i+<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line">        <span class="comment">//构造完成数组后进行模式串匹配</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模式串匹配的道理一致，父串和子串进行挨个匹配，如果相等，那么将两个指针都++</span></span><br><span class="line"><span class="comment">         * 如果不相等，那么对于子串就需要回调，找到上一个相同前缀的字符，继续匹配</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || father[i] == son[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n ) <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230307144106602-b8d8c6.png" alt="image-20230307144106602"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230309163602863-91dbd6.png" alt="image-20230309163602863"></p><p>动态规划</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230310105743449-14c4a1.png" alt="image-20230310105743449"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230313155352901-d3d436.png" alt="image-20230313155352901"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230315205603155-95abd1.png" alt="image-20230315205603155"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>对于回文串的问题来说，一般回文串都可以用动态规划这个经典解法进行计算</p><h1 id="数与位"><a href="#数与位" class="headerlink" title="数与位"></a>数与位</h1><h2 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toString(num,n) </span><br><span class="line">    上面代码的作用就将十进制s转化为n进制的</span><br><span class="line">Integer.bitCount(num);</span><br><span class="line">内置了计算二进制表达中<span class="number">1</span>的数量的函数</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230320222134457-56fb65.png" alt="image-20230320222134457"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230321155221397-ee9aca.png" alt="image-20230321155221397"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230322134629952-d5eb03.png" alt="image-20230322134629952"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230322145420125-a6092b.png" alt="image-20230322145420125"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230323161909273-5f0851.png" alt="image-20230323161909273"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230323162003726-0a7bbf.png" alt="image-20230323162003726"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230323171805981-02de95.png" alt="image-20230323171805981"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230326192119896-6640eb.png" alt="image-20230326192119896"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230327144319801-ccf706.png" alt="image-20230327144319801"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230328151217301-480f2b.png" alt="image-20230328151217301"></p><h1 id="50-题方法！！！！！！！！32-方法！！！！！！！！！！！"><a href="#50-题方法！！！！！！！！32-方法！！！！！！！！！！！" class="headerlink" title="50 题方法！！！！！！！！32 方法！！！！！！！！！！！"></a>50 题方法！！！！！！！！32 方法！！！！！！！！！！！</h1><h1 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230330200729011-7484fd.png" alt="image-20230330200729011"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230829163708815-dd62f6.png" alt="image-20230829163708815"></p><h1 id="20250228"><a href="#20250228" class="headerlink" title="20250228"></a>20250228</h1><p>今日一题设计食物评分，感觉意义不是很大，但是自己做超时了</p><p>(题目链接)[<a href="https://leetcode.cn/problems/design-a-food-rating-system/description/]">https://leetcode.cn/problems/design-a-food-rating-system/description/]</a></p><p>题解用树方式构造，但是没见过这种方式，等以后有机会研究一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FoodRatings &#123;</span><br><span class="line">    private Map&lt;String, Pair&lt;Integer, String&gt;&gt; foodMap;</span><br><span class="line">    private Map&lt;String, TreeSet&lt;Pair&lt;Integer, String&gt;&gt;&gt; ratingMap;</span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) &#123;</span><br><span class="line">        n = foods.length;</span><br><span class="line">        foodMap = new HashMap&lt;&gt;();</span><br><span class="line">        ratingMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            String food = foods[i];</span><br><span class="line">            String cuisine = cuisines[i];</span><br><span class="line">            int rating = ratings[i];</span><br><span class="line">            foodMap.put(food, new Pair&lt;&gt;(rating, cuisine));</span><br><span class="line">            ratingMap.computeIfAbsent(cuisine, k -&gt; new TreeSet&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">                if (!a.getKey().equals(b.getKey())) &#123;</span><br><span class="line">                    return a.getKey() - b.getKey();</span><br><span class="line">                &#125;</span><br><span class="line">                return a.getValue().compareTo(b.getValue());</span><br><span class="line">            &#125;)).add(new Pair&lt;&gt;(n - rating, food));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void changeRating(String food, int newRating) &#123;</span><br><span class="line">        Pair&lt;Integer, String&gt; pair = foodMap.get(food);</span><br><span class="line">        int oldRating = pair.getKey();</span><br><span class="line">        String cuisine = pair.getValue();</span><br><span class="line">        ratingMap.get(cuisine).remove(new Pair&lt;&gt;(n - oldRating, food));</span><br><span class="line">        ratingMap.get(cuisine).add(new Pair&lt;&gt;(n - newRating, food));</span><br><span class="line">        foodMap.put(food, new Pair&lt;&gt;(newRating, cuisine));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String highestRated(String cuisine) &#123;</span><br><span class="line">        return ratingMap.get(cuisine).first().getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础HTML+CSS</title>
      <link href="/posts/54938.html"/>
      <url>/posts/54938.html</url>
      
        <content type="html"><![CDATA[<h1 id="VS自用快捷键"><a href="#VS自用快捷键" class="headerlink" title="VS自用快捷键"></a>VS自用快捷键</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">！可以自动补全一个网页自带的一些信息</span><br><span class="line">ctrl+k 格式化代码</span><br><span class="line">ctrl+l 选中一行</span><br><span class="line">ctrl+enter 自动运行</span><br></pre></td></tr></table></figure><h1 id="基础HTML和CSS"><a href="#基础HTML和CSS" class="headerlink" title="基础HTML和CSS"></a>基础HTML和CSS</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">meta标签来说，主要来设置网页的源数据</span><br><span class="line">meta主要用于设置网页中的一些元数据，元数据并不是给用户看的,是给浏览器或者搜索引擎看的</span><br><span class="line">属性：charset:指定网页的字符集</span><br><span class="line"> name:指定的数据的名称  一般常用的属性有以下两个</span><br><span class="line"> </span><br><span class="line"> keywords:表示网站的关键字，可以同时指定多个关键字，关键字间使用，隔开。进行搜索的时候用作关键字来识别</span><br><span class="line"> description:表示网站的描述信息,</span><br><span class="line"></span><br><span class="line"> content：制定的数据内容，会作为搜索结果的文字进行展示</span><br><span class="line"></span><br><span class="line">title 内容会作为搜索结果的找链接展示出来</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf8&quot;</span> <span class="attr">version</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http-equiv属性，</span><br><span class="line">http-equiv 如果设置了http-equiv属性，<span class="tag">&lt;<span class="name">meta</span>&gt;</span>元素就是一个pragma指令，提供的信息相当于一个类似名称的HTTP头所能提供的信息</span><br><span class="line">常见的几个属性值：</span><br><span class="line">content-security-policy：允许页面作者为当前页面定义一个内容策略。内容策略主要指定允许的服务器来源和脚本端点，这有助于防范跨站脚本攻击。</span><br><span class="line">content-type：声明文档的MIME类型和字符编码。如果指定，content属性必须有 &quot;text/html; charset=utf-8 &quot;的值。这相当于一个指定了charset属性的<span class="tag">&lt;<span class="name">meta</span>&gt;</span>元素，并对文档中的位置有同样的限制。注意：只能在使用text/html的文档中使用，不能在使用XML MIME类型的文档中使用。</span><br><span class="line">default-style：设置默认的CSS样式表集的名称。</span><br><span class="line">x-ua-compatible： 如果指定，内容属性必须有 &quot;IE=edge&quot;的值。用户代理被要求忽略这个pragma。</span><br><span class="line">refresh：该指令指定页面重新加载及重定向的方式 </span><br><span class="line">直到页面应该被重新加载的秒数--只有当content属性包含一个正整数时。</span><br><span class="line">直到页面重定向到另一个页面的秒数--只有当内容属性包含一个正整数，后面跟着字符串&#x27;;url=&#x27;，以及一个有效的URL。</span><br></pre></td></tr></table></figure><h3 id="块元素与行内元素"><a href="#块元素与行内元素" class="headerlink" title="块元素与行内元素"></a>块元素与行内元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">块元素（block element）</span><br><span class="line">●在网页中一般通过块元素来对页面进行布局</span><br><span class="line">行内元素（inline element）</span><br><span class="line">    ●行内元素主要用来包裹文字</span><br><span class="line">    ●一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素 </span><br><span class="line">    ○如p元素中不能放任何的块元素</span><br></pre></td></tr></table></figure><h3 id="内容修正"><a href="#内容修正" class="headerlink" title="内容修正"></a>内容修正</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正，比如</span><br><span class="line">    ●标签写在了根元素的外部</span><br><span class="line">    ●p元素中嵌套了块元素</span><br><span class="line">    ●根元素中出现了除head和body以外的子元素</span><br><span class="line">通过浏览器中的查看网页源代码并不能看到修正效果，而使用检查进入开发者调试可以看到被修正的结果。</span><br><span class="line">不过虽然浏览器能够对不规范的页面内容进行修正，还是不建议编写不规范的代码，因为这对后期代码维护或团队代码协作将是非常不好的后果和体验。</span><br></pre></td></tr></table></figure><h2 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h2><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><h4 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示这个页眉的所有元素</span><br><span class="line">*&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据签名来选中指定元素</span><br><span class="line">p&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据元素的class属性值来选择一组元素</span><br><span class="line">.classname&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据元素的id值来选择一组元素</span><br><span class="line">#id&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并集选择器和交集选择器"><a href="#并集选择器和交集选择器" class="headerlink" title="并集选择器和交集选择器"></a>并集选择器和交集选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并集来说是多个选择器的元素</span><br><span class="line">h1,span&#123;</span><br><span class="line">color:green;</span><br><span class="line">&#125;</span><br><span class="line">交集选择器 -- 两个条件都满足才可以，是div而且类名得是red</span><br><span class="line">div.red&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择父元素指定的子元素 语法父元素 &gt; 子元素  直接包含的元素叫父元素</span><br><span class="line">div &gt; h2 &#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后代选择器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选中元素内的指定后代元素</span><br><span class="line">div h2 &#123;</span><br><span class="line">        color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪选择器————————————非常重要"><a href="#伪选择器————————————非常重要" class="headerlink" title="伪选择器————————————非常重要"></a>伪选择器————————————非常重要</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">伪类：不存在的类，特殊的类。用来描述一个元素的特殊状态如：第一个子元素、被点击的元素、鼠标移入的元素</span><br><span class="line">伪类一般情况下都是使用:开头</span><br><span class="line">:first-child 第一个子元素</span><br><span class="line">:last-child 最后一个子元素</span><br><span class="line">:nth-child()中间写数字表示对应的元素  </span><br><span class="line">n：第n个，n的范围0到正无穷</span><br><span class="line">2n或even：选中偶数位的元素</span><br><span class="line">2n+1或odd：选中奇数位的元素</span><br><span class="line">以上这些伪类都是根据所有的子元素进行排序的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:first-of-type 同类型中的第一个子元素</span><br><span class="line">:last-of-type 同类型中的最后一个子元素</span><br><span class="line">:nth-of-type() 选中同类型中的第n个子元素</span><br><span class="line">这几个伪类的功能和上述的类似，不同点是他们是在同类型元素中进行排序的</span><br><span class="line">:not()否定伪类，将符合条件的元素从选择器中去除</span><br></pre></td></tr></table></figure><h5 id="对于访问元素"><a href="#对于访问元素" class="headerlink" title="对于访问元素"></a>对于访问元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:link 未访问的链接</span><br><span class="line">:visited 已访问的链接 </span><br><span class="line">由于隐私的原因，所以visited这个伪类只能修改链接的颜色</span><br><span class="line">:hover 鼠标悬停的链接</span><br><span class="line">:active 鼠标点击的链接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）</span><br><span class="line">伪元素使用::开头</span><br><span class="line">::first-letter 表示第一个字母</span><br><span class="line">::first-line 表示第一行</span><br><span class="line">::selection 表示选中的内容</span><br><span class="line"></span><br><span class="line">::before 元素的开始</span><br><span class="line">::after 元素的最后</span><br><span class="line">::before和::after 必须结合content属性来使用</span><br></pre></td></tr></table></figure><h2 id="一些不了解的属性"><a href="#一些不了解的属性" class="headerlink" title="一些不了解的属性"></a>一些不了解的属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要让一个元素在父元素中垂直居中，那么就让父元素的line-height和父元素的height相等即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于超链接的下划线去除，设置属性text-decoration: none;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字体加粗：   font-weight: bold;</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><h2 id="行内元素不支持宽度和高度"><a href="#行内元素不支持宽度和高度" class="headerlink" title="行内元素不支持宽度和高度"></a>行内元素不支持宽度和高度</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行内元素不支持设置宽度和高度，一般是内容进行撑开，如果要设置宽度和高度，那么就把它转化为块元素</span><br><span class="line">display:block;</span><br></pre></td></tr></table></figure><h2 id="背景颜色会延申到边框，如果边框没有颜色那么会盖住"><a href="#背景颜色会延申到边框，如果边框没有颜色那么会盖住" class="headerlink" title="背景颜色会延申到边框，如果边框没有颜色那么会盖住"></a>背景颜色会延申到边框，如果边框没有颜色那么会盖住</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">背景颜色一般会延申到边框，但是由于边框有颜色，所以会进行遮盖，但是如果边框透明</span><br><span class="line">border: 2px solid   transparent; 背景颜色会进行溢出遮盖</span><br><span class="line">background-clip: content-box;讲边框只设置在内容区</span><br></pre></td></tr></table></figure><h2 id="如果要显示一行而且溢出后对溢出文字设置省略号设置"><a href="#如果要显示一行而且溢出后对溢出文字设置省略号设置" class="headerlink" title="如果要显示一行而且溢出后对溢出文字设置省略号设置"></a>如果要显示一行而且溢出后对溢出文字设置省略号设置</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* 设置区域大小 */</span><br><span class="line">width: 200px;</span><br><span class="line">/* 设置区域溢出的处理，为隐藏 */</span><br><span class="line">overflow: hidden;</span><br><span class="line">/* 设置文字溢出处理为省略号 */</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">/* 设置网页处理空白 为不换行 */</span><br><span class="line">white-space:nowrap;</span><br><span class="line"></span><br><span class="line">注意四个缺一不可，而且对块元素设置才有效，因为要设置宽度</span><br></pre></td></tr></table></figure><h2 id="前端图片网页是按需进行加载的"><a href="#前端图片网页是按需进行加载的" class="headerlink" title="前端图片网页是按需进行加载的"></a>前端图片网页是按需进行加载的</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于图片资源来说，它相当于是浏览器的外部资源，需要进行单独请求，对于浏览器进行渲染的时候，首先需要对内容进行渲染，之后对于需要的图片进行申请加载，没有访问到的图片，不进行申请加载，所以如果网速较慢的，对于图片一个horver现象会出现闪白，因为需要的图片没有访问到，所以留白，</span><br><span class="line">对于问题的解决</span><br><span class="line">：解决图片闪烁的问题：</span><br><span class="line"></span><br><span class="line">可以将多个小图片统一保存到一个大图片中，然后通过调整background-position来显示响应的图片</span><br><span class="line"></span><br><span class="line">这样图片会同时加载到网页中就可以有效的避免出现闪烁的问题</span><br><span class="line"></span><br><span class="line">这个技术在网页中应用十分广泛，被称为CSS-Sprite，这种图我们称为雪碧图</span><br><span class="line"></span><br><span class="line">雪碧图的使用步骤：</span><br><span class="line"></span><br><span class="line">先确定要使用的图标</span><br><span class="line">测量图标的大小</span><br><span class="line">根据测量结果创建一个元素</span><br><span class="line">将雪碧图设置为元素的背景图片</span><br><span class="line">设置一个偏移量以显示正确的图片</span><br><span class="line">雪碧图的特点：</span><br><span class="line"></span><br><span class="line">一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户的体验</span><br></pre></td></tr></table></figure><h2 id="对于隐藏文字，一般来说，对于图片的搜索会有文字，一般文字会隐藏掉"><a href="#对于隐藏文字，一般来说，对于图片的搜索会有文字，一般文字会隐藏掉" class="headerlink" title="对于隐藏文字，一般来说，对于图片的搜索会有文字，一般文字会隐藏掉"></a>对于隐藏文字，一般来说，对于图片的搜索会有文字，一般文字会隐藏掉</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 隐藏文字的手段 */</span><br><span class="line">text-indent: -999px;</span><br><span class="line"></span><br><span class="line">使用这个属性的时候同时也得把overflow hidden使用上</span><br></pre></td></tr></table></figure><h2 id="元素隐藏两个方式"><a href="#元素隐藏两个方式" class="headerlink" title="元素隐藏两个方式"></a>元素隐藏两个方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果隐藏之后占据的位置不计 -- 注意浮动和绝对定位不再文档流</span><br><span class="line">就可以使用display:none;</span><br><span class="line">如果要使用隐藏前的东西占据位置，那么就使用</span><br><span class="line">    visibility: hidden;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://blog.csdn.net/qq_35925558/category_11061834.html">CSDN web从入门到精通</a></p><p><a href="https://www.yuque.com/cessstudy/kak11d/fg5v84">鱼雀笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML+CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs</title>
      <link href="/posts/19874.html"/>
      <url>/posts/19874.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nodejs基础"><a href="#Nodejs基础" class="headerlink" title="Nodejs基础"></a>Nodejs基础</h1><h2 id="安装以及认识"><a href="#安装以及认识" class="headerlink" title="安装以及认识"></a>安装以及认识</h2><h3 id="认识nodejs"><a href="#认识nodejs" class="headerlink" title="认识nodejs"></a>认识nodejs</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodejs就是一款应用程序，是一款软件，可以运行<span class="title class_">JavaScript</span></span><br><span class="line"></span><br><span class="line">作用：开发服务器应用，开发工具类应用，开发桌面端应用</span><br></pre></td></tr></table></figure><h3 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//nodejs.org/en</span></span><br><span class="line">选择<span class="variable constant_">LTS</span>类型进行安装，长期维护稳定版本</span><br><span class="line"></span><br><span class="line">验证安装：打开cmd ，node -v查看版本号</span><br></pre></td></tr></table></figure><h3 id="cmd基本用法（复习）"><a href="#cmd基本用法（复习）" class="headerlink" title="cmd基本用法（复习）"></a>cmd基本用法（复习）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">切换盘符     D：</span><br><span class="line">查看当前目录下的文件 dir   dir /s  查看当前目录下所有的文件，包括子文件</span><br><span class="line">切换文件  cd 文件名称  切换到上一级 cd ..</span><br><span class="line">停止运行 ctrl+c</span><br><span class="line">用<span class="title class_">TAb</span>键可以选择dir</span><br></pre></td></tr></table></figure><h3 id="使用node运行js文件"><a href="#使用node运行js文件" class="headerlink" title="使用node运行js文件"></a>使用node运行js文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">用 cmd 将目录切换到js文件目录， node 文件名.<span class="property">js</span> 就可以运行</span><br><span class="line">在vscode中运行：</span><br><span class="line">右键文件 &gt; 在集成终端中打开，之后和cmd一样 的操作 node 文件名.<span class="property">js</span></span><br></pre></td></tr></table></figure><h3 id="nodejs中不可以使用webAPI"><a href="#nodejs中不可以使用webAPI" class="headerlink" title="nodejs中不可以使用webAPI"></a>nodejs中不可以使用webAPI</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230510152323118-191d3f.png" alt="image-20230510152323118"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230510152333843-99ea4f.png" alt="image-20230510152333843"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">因为nodejs对象中不包含dom和bom对象</span><br><span class="line">有一样的  <span class="variable language_">console</span> 和 定时器对象</span><br></pre></td></tr></table></figure><h3 id="顶级对象"><a href="#顶级对象" class="headerlink" title="顶级对象"></a>顶级对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在nodejs中的顶级对象不是<span class="variable language_">window</span> 而是<span class="variable language_">global</span>对象 或者globalThis  两者是一样的</span><br></pre></td></tr></table></figure><h2 id="VScode中有提示"><a href="#VScode中有提示" class="headerlink" title="VScode中有提示"></a>VScode中有提示</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @types/node</span><br></pre></td></tr></table></figure><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="计算程序内存占比"><a href="#计算程序内存占比" class="headerlink" title="计算程序内存占比"></a>计算程序内存占比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>)</span><br><span class="line">process.<span class="title function_">memoryUsage</span>()</span><br><span class="line">里面输出后第一个参数 rss代表内存占比，单位为字节</span><br></pre></td></tr></table></figure><h2 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h2><p>Buffer 是一个类似于数组的 <code>对象</code> ，用于表示固定长度的字节序列</p><p>Buffer 本质是一段内存空间，专门用来处理 <code>二进制数据</code> 。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/e63bd2526bce2f0bbc003f3d0e122915459d9f2b-06357b.png" alt="image-20230320173023659"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>Buffer 大小固定且无法调整</li><li>Buffer 性能较好，可以直接对计算机内存进行操作</li><li>每个元素的大小为 1 字节（byte）</li></ol><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/1f67ed9e1b8884786dafcc4deb804f96234af9f4-803ab1.png" alt="image-20230320173043532"></p><h3 id="创建Buffer的方式"><a href="#创建Buffer的方式" class="headerlink" title="创建Buffer的方式"></a>创建Buffer的方式</h3><h4 id="alloc创建"><a href="#alloc创建" class="headerlink" title="alloc创建"></a>alloc创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了一个长度为 10 字节的 Buffer，相当于申请了 10 字节的内存空间，每个字节的值为 0</span></span><br><span class="line"><span class="comment">//alloc进行分配的时候，先选中一块地址，然后将地址里面的元素全部赋值为0</span></span><br><span class="line"><span class="keyword">let</span> buf_1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>) <span class="comment">//=&gt;结果为&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><h4 id="allocUnsafe创建"><a href="#allocUnsafe创建" class="headerlink" title="allocUnsafe创建"></a>allocUnsafe创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了一个长度为 10 字节的 Buffer，buffer 中可能存在旧数据，可能会影响执行结果，所以叫 unsafe ，但是效率比 alloc 高</span></span><br><span class="line"><span class="comment">//相当于直接在内存里面寻找到内存为10的区域分配给buf_2,但是里面的内容不会进行初始化</span></span><br><span class="line"><span class="keyword">let</span> buf_2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="from创建"><a href="#from创建" class="headerlink" title="from创建"></a>from创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过字符串创建 Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf_3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// 通过数组创建 Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf_4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>])</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建完成后本质上是以二进制的形式保存，但是一般打印为了更好地显示，采用十六进制进行显示</span><br></pre></td></tr></table></figure><h3 id="buff与字符串的转化"><a href="#buff与字符串的转化" class="headerlink" title="buff与字符串的转化"></a>buff与字符串的转化</h3><p>我们可以借助 <code>toString</code> 方法将 Buffer 转为字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buf_4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_4.<span class="title function_">toString</span>()) <span class="comment">//=&gt;iloveyou</span></span><br></pre></td></tr></table></figure><p>**注意: **<code>toString</code> 默认是按照 <code>utf-8</code> 编码方式进行转换的</p><h3 id="Buffer的读写"><a href="#Buffer的读写" class="headerlink" title="Buffer的读写"></a>Buffer的读写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于buffer来讲，前面说过，类似与数组，所以可以用数据的方式对buffer进行操作</span><br><span class="line"><span class="keyword">let</span> buf_3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_3[<span class="number">1</span>]) <span class="comment">//=&gt;101</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">buf_3[<span class="number">1</span>] = <span class="number">97</span></span><br><span class="line"><span class="comment">//查看字符串结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_3.<span class="title function_">toString</span>()) <span class="comment">//=&gt;hallo</span></span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于buffer数组元素进行修改的时候，由于每个数组元素占用一个字节，一个字节所能表示的整数最多为<span class="number">255</span>，所以当修改大于<span class="number">255</span>的数字的时候，就会发生溢出现象，对于这种情况，buff处理是抛弃高位，保留低八位</span><br><span class="line"><span class="attr">eg</span>:buff_7[<span class="number">0</span>] = <span class="number">361</span> <span class="comment">// =&gt;舍弃高位 ， 本来表示361 0001 0110 1001，但由于溢出，所以只保留后八位0110 1001</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buff_7);<span class="comment">//69  </span></span><br></pre></td></tr></table></figure><h4 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于中文，一般是utf-8的类型，一个中文占三个字节</span><br></pre></td></tr></table></figure><h2 id="fs（file-system）"><a href="#fs（file-system）" class="headerlink" title="fs（file system）"></a>fs（file system）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs模块可以实现与硬盘的交互，包括文件的创建，删除，重命名等等以及相关文件操作</span><br></pre></td></tr></table></figure><h3 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>writeFile</td><td>异步写入</td></tr><tr><td>writeFileSync</td><td>同步写入</td></tr><tr><td>appendFile &#x2F; appendFileSync</td><td>追加写入</td></tr><tr><td>createWriteStream</td><td>流式写入</td></tr></tbody></table><h4 id="writeFile异步写入"><a href="#writeFile异步写入" class="headerlink" title="writeFile异步写入"></a>writeFile异步写入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法： fs.<span class="title function_">writeFile</span>(file, data[, options], callback)</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- file 文件名</span><br><span class="line">- data 待写入的数据</span><br><span class="line">- options 选项设置 （可选）什么类型的数据，<span class="attr">eg</span>:utf-<span class="number">8</span>，</span><br><span class="line">  或者也可以标识追加写入，&#123;flag : <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line">- callback 写入回调</span><br><span class="line">- 返回值： <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// require 是 Node.js 环境中的 &#x27;全局&#x27; 变量，用来导入模块,fs是模块名称</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 [三人行，必有我师焉。] 写入到当前文件夹下的 [座右铭.txt] 文件中</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;冲天香阵透长安，满城尽带黄金甲！&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="writeFileSync-同步写入"><a href="#writeFileSync-同步写入" class="headerlink" title="writeFileSync 同步写入"></a>writeFileSync 同步写入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法: fs.<span class="title function_">writeFileSync</span>(file, data[, options])</span><br><span class="line">参数与 fs.<span class="property">writeFile</span> 大体一致，只是没有 callback 参数</span><br><span class="line">返回值：<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;三人行，必有我师焉。&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="appendFile-appendFileSync-追加写入"><a href="#appendFile-appendFileSync-追加写入" class="headerlink" title="appendFile &#x2F; appendFileSync 追加写入"></a>appendFile &#x2F; appendFileSync 追加写入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">appendFile 作用是在文件尾部追加内容，appendFile语法与writeFile语法完全相同</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">fs.<span class="title function_">appendFile</span>(file, data[, options], callback)</span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(file, data[, options])</span><br><span class="line">返回值：二者都为 <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">实例代码：</span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;待到秋来九月八,我花开后百花杀!&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;追加写入成功&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./座右铭1.txt&#x27;</span>, <span class="string">&#x27;待到秋来九月八,我花开后百花杀!&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="createWriteStream-流式写入"><a href="#createWriteStream-流式写入" class="headerlink" title="createWriteStream 流式写入"></a>createWriteStream 流式写入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：fs.<span class="title function_">createWriteStream</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">path 文件路径</span><br><span class="line">options 选项配置（ 可选 ） </span><br><span class="line">返回值: <span class="title class_">Object</span></span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方塘一鉴开\n&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\n&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\n&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;为有源头活水来\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ws.end()</span></span><br><span class="line">ws.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于end和close方法，</span><br><span class="line">close方法代表关闭可写流</span><br><span class="line"></span><br><span class="line">end方法：该方法参数可传可不传：</span><br><span class="line">传了参数，等价于 先调用ws.<span class="title function_">write</span>(内容)把内容写入，然后调用ws.<span class="title function_">close</span>()</span><br><span class="line">不传参数，等价于直接调用ws.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>readFile</td><td>异步读取</td></tr><tr><td>readFileSync</td><td>同步读取</td></tr><tr><td>createReadStream</td><td>流式读取</td></tr></tbody></table><h4 id="readFile-异步读取"><a href="#readFile-异步读取" class="headerlink" title="readFile 异步读取"></a>readFile 异步读取</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法: fs.<span class="title function_">readFile</span>(path[, options], callback)</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件路径</span><br><span class="line">- options 选项配置</span><br><span class="line">- callback 回调函数  两个参数，一个err表示错误，另一个data表示读取到的数据，注意读取到的数据是buff类型数据，可以toString转化为字符串</span><br><span class="line">返 回 值 ：<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="readFileSync-同步读取"><a href="#readFileSync-同步读取" class="headerlink" title="readFileSync 同步读取"></a>readFileSync 同步读取</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：fs.<span class="title function_">readFileSync</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件路径</span><br><span class="line">- options 选项配置</span><br><span class="line">返 回 值 ：string | <span class="title class_">Buffer</span></span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"><span class="keyword">let</span> data =  fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="createReadStream-流读取"><a href="#createReadStream-流读取" class="headerlink" title="createReadStream 流读取"></a>createReadStream 流读取</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：fs.<span class="title function_">createReadStream</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件路径</span><br><span class="line">- options 选项配置（ 可选 ）</span><br><span class="line"> </span><br><span class="line">返回值：<span class="title class_">Object</span></span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;./观书有感.txt&quot;</span>) 传入地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件打开&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">chunk相当于读取的数据，这里读取的数据是指流一次能读取多少数据，这个可以在options里面进行设置，highWaterMark，很多设置在options里面都有设置</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="property">length</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;err&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">//文件读取完毕后触发</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">//最后文件关闭触发</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;关闭&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rs.<span class="title function_">pause</span>() 暂停读取,会暂停data事件的触发，将流动模式转变非流动模式</span><br><span class="line">rs.<span class="title function_">resume</span>()恢复data事件,继续读取，变为流动模式</span><br></pre></td></tr></table></figure><h3 id="文件写入写出区别"><a href="#文件写入写出区别" class="headerlink" title="文件写入写出区别"></a>文件写入写出区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于普通的读写操作来讲，不论异步还是非异步，都是将所有的文件内容读取出来后进行写入，内存占比相当于文件的大小，占比非常高</span><br><span class="line">但是对于流写入写出来讲，规定了每次读取的字节数量，那么就相当于每次读取多少字节，接着让流文件进行写入，占比内存相当于一次读取多少字节的内存，但由于读取速度大于写入速度，所以一般会大于一次读取字节的内存大小，对于写不完的数据，会放在缓存队列里面，等待写入</span><br><span class="line"></span><br><span class="line">所以由此可见，大文件的读取一般使用流进行读取，小文件可以选取直接读取</span><br></pre></td></tr></table></figure><h3 id="文件移动与重命名"><a href="#文件移动与重命名" class="headerlink" title="文件移动与重命名"></a>文件移动与重命名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rename</span>(oldPath, newPath, callback)</span><br><span class="line">fs.<span class="title function_">renameSync</span>(oldPath, newPath)</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- oldPath 文件当前的路径</span><br><span class="line">- newPath 文件新的路径</span><br><span class="line">- callback 操作后的回调</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&quot;./座右铭1.txt&quot;</span>, <span class="string">&quot;./论语.txt&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="title function_">r</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">re</span>(<span class="string">&quot;修改名字成功！&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&quot;./论语.txt&quot;</span>, <span class="string">&quot;../论语.txt&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修改地址失败&quot;</span>);</span><br><span class="line">        <span class="title function_">rejected</span>(<span class="string">&quot;失败&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;修改地址成功&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在 <span class="title class_">Node</span>.<span class="property">js</span> 中，我们可以使用unlink 或 <span class="string">`unlinkSync`</span> 来删除文件,或者使用rmSync 、rm来进行删除</span><br><span class="line"></span><br><span class="line">语法:</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlink</span>(path, callback)</span><br><span class="line">fs.<span class="title function_">unlinkSync</span>(path)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rm</span>(path, callback)</span><br><span class="line">fs.<span class="title function_">rmSync</span>(path)</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">path 文件路径</span><br><span class="line">callback 操作后的回调</span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;../论语.txt&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;../demo_1.js&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>mkdir &#x2F; mkdirSync</td><td>创建文件夹</td></tr><tr><td>readdir &#x2F; readdirSync</td><td>读取文件夹</td></tr><tr><td>rmdir &#x2F; rmdirSync</td><td>删除文件夹</td></tr></tbody></table><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">fs.<span class="title function_">mkdir</span>(path[, options], callback)</span><br><span class="line">fs.<span class="title function_">mkdirSync</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件夹路径</span><br><span class="line">- options 选项配置（可选）</span><br><span class="line">- callback 操作后的回调</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./html&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">如果要进行递归进行创建，那么对于option，设置 &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;</span><br><span class="line">代码示例：</span><br><span class="line">递归创建</span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&quot;./a/b/c&quot;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(path[, options], callback)</span><br><span class="line">fs.<span class="title function_">readdirSync</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件夹路径</span><br><span class="line">- options 选项配置（可选 ）</span><br><span class="line">- callback 操作后的回调</span><br><span class="line">示例代码：</span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">fs.<span class="title function_">rmdir</span>(path[, options], callback)</span><br><span class="line">fs.<span class="title function_">rmdirSync</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件夹路径</span><br><span class="line">- options 选项配置（可选）</span><br><span class="line">- callback 操作后的回调</span><br><span class="line"></span><br><span class="line">示例代码：</span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&#x27;./html&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">递归删除,和添加一个道理</span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&#x27;./a&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">注意，现在逐渐抛弃这个方法，使用rm方法进行删除，</span><br><span class="line">下面展示递归删除：</span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./a&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查看资源状态"><a href="#查看资源状态" class="headerlink" title="查看资源状态"></a>查看资源状态</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">stat</span>(path[, options], callback)</span><br><span class="line">fs.<span class="title function_">statSync</span>(path[, options])</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">- path 文件夹路径</span><br><span class="line">- options 选项配置（可选）</span><br><span class="line">- callback 操作后的回调</span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&quot;../../exercise/七里香.mp4&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isFile</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isDirectory</span>());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>data的输出信息</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230514115743558-b61bf4.png" alt="image-20230514115743558"></p><p><strong>结果值对象结构</strong>：</p><ul><li>size 文件体积</li><li>birthtime 创建时间</li><li>mtime 最后修改时间</li><li>atime 最后访问时间</li><li>isFile() 检测是否为文件</li><li>isDirectory() 检测是否为文件夹</li></ul><h3 id="相对路径问题以及解决办法"><a href="#相对路径问题以及解决办法" class="headerlink" title="相对路径问题以及解决办法"></a>相对路径问题以及解决办法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs 模块对资源进行操作时，路径的写法有两种： </span><br><span class="line"></span><br><span class="line">- 相对路径</span><br><span class="line">  - ./座右铭.<span class="property">txt</span> 当前目录下的 座右铭.<span class="property">txt</span></span><br><span class="line">  - 座右铭.<span class="property">txt</span> 等效于上面的写法</span><br><span class="line">  - ../座右铭.<span class="property">txt</span> 当前目录的上一级目录中的 座右铭.<span class="property">txt</span> </span><br><span class="line"></span><br><span class="line">- 绝对路径</span><br><span class="line">  - <span class="attr">D</span>:/demo.<span class="property">txt</span> 盘符下的绝对路径</span><br><span class="line">  - /demo 系统下的绝对路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：相对路径中所谓的 当前目录 ，指的是 命名行的工作目录 ，而并非是文件的所在目录，所以当命名行的工作目录与文件所在目录不一致时，会出现一些 Bug，当前目录指的是运行环境的目录，所以为了解决这个问题，一般写成绝对路径。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">__dirname 与 <span class="built_in">require</span> 类似，都是 <span class="title class_">Node</span>.<span class="property">js</span> 环境中的 <span class="string">&#x27;全局&#x27;</span> 变量</span><br><span class="line"></span><br><span class="line">__dirname 保存着当前文件夹所在目录的绝对路径，可以使用 __dirname 与文件名拼接成绝对路径,来解决相对路径出现的问题bug</span><br><span class="line"></span><br><span class="line">__filename 保存当前文件的所有绝对路径</span><br><span class="line">如下显示，第一个是__dirname  第二个打印是__filename</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230514121349441-f74180.png" alt="image-20230514121349441"></p><h3 id="options可选参数"><a href="#options可选参数" class="headerlink" title="options可选参数"></a>options可选参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">highWaterMark</span>:<span class="number">3</span>, <span class="comment">//文件一次读多少字节,默认 64*1024</span></span><br><span class="line">特别注意这个highWaterMark，所代表的意思就是<span class="string">&quot;水位线&quot;</span>,默认大小是16k，那<span class="string">&quot;水位线&quot;</span>是具体什么意思？</span><br><span class="line">按照它源码中的写法，这个highWaterMark的值就代表 当前写入的字节 + 缓存中的字节数 的和，如果超过这个值，虽然不会阻止你继续往缓存中去写入，但是可读流的<span class="title function_">write</span>()方法的返回值会变为<span class="literal">false</span>，不超过的话，返回的是<span class="literal">true</span>。这样做的目的，是为了能够做到读一部分，写一部分，不会导致内存爆满。</span><br><span class="line"></span><br><span class="line">    <span class="attr">flags</span>:<span class="string">&#x27;r&#x27;</span>, <span class="comment">//默认 &#x27;r&#x27;，读取类型，上面有a表示追加的意思</span></span><br><span class="line">    <span class="attr">autoClose</span>:<span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></span><br><span class="line">    <span class="attr">start</span>:<span class="number">0</span>, <span class="comment">//读取文件开始位置</span></span><br><span class="line">    <span class="attr">end</span>:<span class="number">3</span>, <span class="comment">//流是闭合区间 包含start也含end</span></span><br><span class="line">    <span class="attr">encoding</span>:<span class="string">&#x27;utf8&#x27;</span> <span class="comment">//默认nul</span></span><br><span class="line"></span><br><span class="line">一堆wirte方法相当于一个异步方法，他们能串行同步执行是因为第一次写入直接执行，其他步骤放在缓存区内，然后等第一次写完，从缓存中取出一个写入，这样一个个取出来写入，直至写完，</span><br><span class="line">缓存区需要链表实现</span><br></pre></td></tr></table></figure><h2 id="Path模块操作"><a href="#Path模块操作" class="headerlink" title="Path模块操作"></a>Path模块操作</h2><p>操作路径常用的一些API</p><table><thead><tr><th><strong>API</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>path.resolve(value[,value1])</td><td>拼接规范的绝对路径常用</td></tr><tr><td>path.sep   （属性）</td><td>获取操作系统的路径分隔符</td></tr><tr><td>path.parse(value)</td><td>解析路径并返回对象</td></tr><tr><td>path.basename(value)</td><td>获取路径的基础名称</td></tr><tr><td>path.dirname(value)</td><td>获取路径的目录名</td></tr><tr><td>path.extname(value)</td><td>获得路径的扩展名</td></tr></tbody></table><h2 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>（hypertext transport protocol）协议；中文叫 超文本传输协议</span><br><span class="line"></span><br><span class="line">是一种基于<span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span>的应用层通信协议</span><br><span class="line"></span><br><span class="line">这个协议详细规定了 浏览器 和 万维网服务器 之间互相通信的规则</span><br><span class="line"></span><br><span class="line">协议中主要规定了两个方面的内容:</span><br><span class="line"></span><br><span class="line">- 客户端：用来向服务器发送数据，可以被称之为请求报文</span><br><span class="line">- 服务端：向客户端返回数据，可以被称之为响应报文</span><br><span class="line"></span><br><span class="line">报文：可以简单理解为就是一堆字符串</span><br></pre></td></tr></table></figure><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- 请求方法（get、post、put、<span class="keyword">delete</span>等）</span><br><span class="line"></span><br><span class="line">- 请求 <span class="variable constant_">URL</span>（统一资源定位器）</span><br><span class="line"></span><br><span class="line">  例如：<span class="attr">http</span>:<span class="comment">//www.baidu.com/index.html?a=100&amp;b=200#logo</span></span><br><span class="line"></span><br><span class="line">  - <span class="attr">http</span>:          协议 (https、ftp、ssh等)</span><br><span class="line">  - www.<span class="property">baidu</span>.<span class="property">com</span>  域名</span><br><span class="line">  - <span class="number">80</span>             端口号</span><br><span class="line">  - /index.<span class="property">html</span>     路径</span><br><span class="line">  - a=<span class="number">100</span>&amp;b=<span class="number">200</span>     查询字符串</span><br><span class="line">  - #logo           哈希 (锚点链接)</span><br><span class="line"></span><br><span class="line">- <span class="variable constant_">HTTP</span>协议版本号</span><br></pre></td></tr></table></figure><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>格式：『头名：头值』</p><p>常见的请求头有：</p><table><thead><tr><th>请求头</th><th>解释</th></tr></thead><tbody><tr><td>Host</td><td>主机名</td></tr><tr><td>Connection</td><td>连接的设置 keep-alive（保持连接）；close（关闭连接）</td></tr><tr><td>Cache-Control</td><td>缓存控制 max-age &#x3D; 0 （没有缓存）</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>将网页中的http请求转化为 https 请求（很少用）老网站升级</td></tr><tr><td>User-Agent</td><td>用户代理，客户端字符串标识，服务器可以通过这个标识来识别这个请求来自哪个客户端 ，一般在PC端和手机端的区分</td></tr><tr><td>Accept</td><td>设置浏览器接收的数据类型</td></tr><tr><td>Accept-Encoding</td><td>设置接收的压缩方式</td></tr><tr><td>Accept-Language</td><td>设置接收的语言 q&#x3D;0.7 为喜好系数，满分为1</td></tr><tr><td>Cookie</td><td>后面单独讲</td></tr></tbody></table><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">请求体内容的格式是非常灵活的，</span><br><span class="line">（可以是空）==&gt; <span class="variable constant_">GET</span>请求，</span><br><span class="line">（也可以是字符串，还可以是<span class="title class_">JSON</span>）===&gt; <span class="variable constant_">POST</span>请求</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">- 字符串：keywords=手机&amp;price=<span class="number">2000</span></span><br><span class="line">- <span class="title class_">JSON</span>：&#123;<span class="string">&quot;keywords&quot;</span>:<span class="string">&quot;手机&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">2000</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- 响应行:  <span class="string">`HTTP/1.1 200 OK`</span></span><br><span class="line"></span><br><span class="line">  - <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>：<span class="variable constant_">HTTP</span>协议版本号</span><br><span class="line"></span><br><span class="line">  - <span class="number">200</span>：响应状态码 <span class="number">404</span> <span class="title class_">Not</span> <span class="title class_">Found</span> <span class="number">500</span> <span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span></span><br><span class="line">    还有一些状态码，参考：<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</span></span><br><span class="line">  </span><br><span class="line">  - <span class="variable constant_">OK</span>：响应状态描述</span><br><span class="line"></span><br><span class="line"> 响应状态码 和 响应字符串 关系是 一一对应 的。</span><br></pre></td></tr></table></figure><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="string">`Cache-Control`</span>: 缓存控制 private 私有的，只允许客户端缓存数据</span><br><span class="line">- <span class="string">`Connection`</span>: 链接设置</span><br><span class="line">- <span class="string">`Content-Type:text/html;charset=utf-8`</span>: 设置响应体的数据类型以及字符集,响应体为html，字符集utf-<span class="number">8</span></span><br><span class="line">- <span class="string">`Content-Length`</span>: 响应体的长度，单位为字节</span><br></pre></td></tr></table></figure><h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">响应体内容的类型是非常灵活的，常见的类型有 <span class="variable constant_">HTML</span>、<span class="variable constant_">CSS</span>、<span class="variable constant_">JS</span>、图片、<span class="title class_">JSON</span></span><br></pre></td></tr></table></figure><h3 id="创建HTTP服务"><a href="#创建HTTP服务" class="headerlink" title="创建HTTP服务"></a>创建HTTP服务</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 创建服务对象 create 创建 server 服务</span></span><br><span class="line"><span class="comment">// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据</span></span><br><span class="line"><span class="comment">// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文</span></span><br><span class="line"><span class="keyword">const</span> serve = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;你好啊&lt;/h1&gt;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3. 监听端口, 启动服务</span></span><br><span class="line">serve.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经正在启动！！！！&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">命令行ctrl + c停止服务</span><br><span class="line"></span><br><span class="line">响应内容中文乱码的解决办法</span><br><span class="line">   <span class="comment">// 设置响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">端口号被占用</span><br><span class="line">   <span class="title class_">Error</span>: listen <span class="attr">EADDRINUSE</span>: address already <span class="keyword">in</span> use :::<span class="number">9000</span></span><br><span class="line">   <span class="number">1</span>）关闭当前正在运行监听端口的服务 （使用较多）</span><br><span class="line">   <span class="number">2</span>）修改其他端口号</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>协议默认端口是 <span class="number">80</span> 。<span class="variable constant_">HTTPS</span>协议的默认端口是 <span class="number">443</span>, <span class="variable constant_">HTTP</span> 服务开发常用端口有 <span class="number">3000</span>，<span class="number">8080</span>，<span class="number">8090</span>，<span class="number">9000</span> 等</span><br><span class="line"></span><br><span class="line">如果端口被其他程序占用，可以使用资源监视器找到占用端口的程序，然后使用任务管理器关闭对应的程序</span><br></pre></td></tr></table></figure><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><table><thead><tr><th align="left">含义</th><th align="left">语法</th></tr></thead><tbody><tr><td align="left">请求方法</td><td align="left">request.method</td></tr><tr><td align="left">请求版本</td><td align="left">request.httpVersion</td></tr><tr><td align="left">请求路径</td><td align="left">request.url   只能获取路径以及查询字符串，无法获取 URL 中的域名以及协议的内容</td></tr><tr><td align="left">URL 路径</td><td align="left">require(‘url’).parse(request.url).pathname</td></tr><tr><td align="left">URL 查询字符串</td><td align="left">require(‘url’).parse(request.url,  true).query</td></tr><tr><td align="left">请求头</td><td align="left">request.headers  将请求信息转化成一个对象，并将属性名都转化成了小写</td></tr><tr><td align="left">请求体</td><td align="left">request.on(‘data’, function(chunk){})  注意这里每次获得的chunk是一个buffer类型是数据，不完整，要完整需要进行拼接整合</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取请求的方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span>)  <span class="comment">//=&gt;GET</span></span><br><span class="line">  <span class="comment">// 获取请求的 url</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>)  <span class="comment">// 只包含 url 中的 路径 与查询字符串</span></span><br><span class="line">  <span class="comment">// 获取 http 协议的版本号</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">httpVersion</span>)  <span class="comment">//=&gt; 1.1</span></span><br><span class="line">  <span class="comment">// 获取 http 的请求头</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">headers</span>) <span class="comment">//=&gt;结果是一个对象</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  request.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">      body += chunk;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="提取-http-报文的-url的路径-与-查询字符串"><a href="#提取-http-报文的-url的路径-与-查询字符串" class="headerlink" title="提取 http 报文的 url的路径 与 查询字符串"></a>提取 http 报文的 url的路径 与 查询字符串</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 导入 url 模块</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 解析 request.url</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>)   <span class="comment">//=&gt;/search?keyword=h5</span></span><br><span class="line">  <span class="comment">// 使用 parse 解析 request.url 的内容</span></span><br><span class="line">  <span class="comment">// true 将 query 属性将会设置为一个 对象</span></span><br><span class="line">  <span class="keyword">let</span> res = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)  <span class="comment">// 如下图所示，为一个对象</span></span><br><span class="line">  <span class="comment">// 路径</span></span><br><span class="line">  <span class="keyword">let</span> pathname = res.<span class="property">pathname</span></span><br><span class="line">  <span class="comment">// 查询字符串</span></span><br><span class="line">  <span class="keyword">let</span> keyword = res.<span class="property">query</span>.<span class="property">keyword</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(keyword)   <span class="comment">//=&gt;h5</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230515100859625-c27016.png" alt="image-20230515100859625"></p><p>方法二：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化 url 对象</span></span><br><span class="line">  <span class="comment">// let url = new URL(&#x27;/search?a=100&amp;b=200&#x27;,&#x27;http://127.0.0.1:9000&#x27;)</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>, <span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url)  <span class="comment">//=&gt;如图所示，为一个对象</span></span><br><span class="line">  <span class="comment">// 输出路径</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="property">pathname</span>)  <span class="comment">//=&gt;/search</span></span><br><span class="line">  <span class="comment">// 输出 keyword 查询字符串</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>))  <span class="comment">//=&gt; 100</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">&#x27;url new&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230515100844742-8bf48e.png" alt="image-20230515100844742"></p><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><table><thead><tr><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>设置响应状态码</td><td>response.statusCode</td></tr><tr><td>设置响应状态描述</td><td>response.statusMessage （ 用的非常少 ）</td></tr><tr><td>设置响应头信息</td><td>response.setHeader(‘头名’, ‘头值’)  (可以自定义)</td></tr><tr><td>设置响应体</td><td>response.write(‘xx’) write方法可以重复调用<br/>response.end(‘xxx’)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置多个同名的响应头</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;test&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">在对响应体进行设置的时候，write方法可以执行多次，end方法只能执行一次，end方法传参相当于把参数穿进去并且关闭连接，所以关闭连接后不可以继续进行响应</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">将一个复杂的程序文件依据一定规则（规范）拆分成多个文件的过程称之为模块化</span><br><span class="line"></span><br><span class="line">其中拆分出的每个文件就是一个模块，模块的内部数据是私有的，不过模块可以暴露内部数据以便其他模块使用</span><br></pre></td></tr></table></figure><h3 id="CommonJS规范暴漏数据"><a href="#CommonJS规范暴漏数据" class="headerlink" title="CommonJS规范暴漏数据"></a>CommonJS规范暴漏数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = value</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = value</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; value :value,<span class="attr">value2</span>:value&#125;</span><br><span class="line"></span><br><span class="line">使用时有几点注意：</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> 可以暴露任意数据</span><br><span class="line">不能使用<span class="built_in">exports</span> = value的形式暴露数据，模块内部<span class="variable language_">module</span> 与 <span class="built_in">exports</span> 的隐式关系</span><br><span class="line"><span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;&#125;，<span class="built_in">require</span> 返回的是目标模块中<span class="variable language_">module</span>.<span class="property">exports</span>的值</span><br></pre></td></tr></table></figure><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于自己创建的模块，导入时路径建议写相对路径，且不能省略 ./ 和 ../</span><br><span class="line"></span><br><span class="line">js和json文件导入时可以不用写后缀，c/c++编写的node扩展文件也可以不写后缀，但是一般用不到，直接使用node的<span class="built_in">require</span>()方法即可将 <span class="title class_">JSON</span> 文件转换成 <span class="variable constant_">JS</span> 对象</span><br><span class="line"></span><br><span class="line">如果导入其他类型的文件，会以js文件进行处理</span><br><span class="line"></span><br><span class="line">如果导入的路径是个文件夹，则会首先检测该文件夹下package.<span class="property">json</span> 文件中main属性对应的文件，如果存在则导入，反之如果文件不存在会报错。如果 main 属性不存在，或者 package.<span class="property">json</span> 不存在，则会尝试导入文件夹下的index.<span class="property">js</span> 和index.<span class="property">json</span>，如果还是没找到，就会报错</span><br><span class="line"></span><br><span class="line">导入 node.<span class="property">js</span> 内置模块时，直接 <span class="built_in">require</span> 模块的名字即可，无需加./和../</span><br></pre></td></tr></table></figure><h3 id="ES6模块导入和CommonJS导入区别"><a href="#ES6模块导入和CommonJS导入区别" class="headerlink" title="ES6模块导入和CommonJS导入区别"></a>ES6模块导入和CommonJS导入区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES6模块导入，导入的相当于是一个引用数据，换句话，对ES6里面的数据进行操作，里面的数据是进行连带操作的，只是进行了数据引用，但是CommmonJs导入是对数据进行了拷贝赋值，所以和原来数据没有关系，具体看下面例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tiemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    counter++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    tiemo,</span><br><span class="line">    counter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">引入</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">require</span>(<span class="string">&#x27;./2-抛出方法.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">me.<span class="title function_">tiemo</span>()  =&gt;&gt;&gt;&gt;<span class="number">4</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">counter</span>); =&gt;&gt;&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES6</span>模块</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">tiemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    counter++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">引入</span><br><span class="line"> <span class="keyword">import</span> &#123;tiemo,counter&#125; <span class="keyword">from</span>  <span class="string">&#x27;./2-抛出方法.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">tiemo</span>()   =&gt;&gt;&gt;&gt;<span class="number">4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);   =&gt;&gt;&gt;&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h1><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm -v  验证是否成功安装</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建一个空目录，然后以此目录作为工作目录启动命令行工具，执行npm init</span><br></pre></td></tr></table></figure><p>示例以及属性翻译</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;1-npm&quot;</span>, #包的名字</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>, #包的版本</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>, #包的描述</span><br><span class="line"><span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>, #包的入口文件</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;     #脚本配置</span><br><span class="line"><span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>, #作者</span><br><span class="line"><span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span> #开源证书</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> package <span class="title function_">name</span> (包名) 不能使用中文、大写，默认值是文件夹的名称，所以文件夹名称也不</span><br><span class="line">   能使用中文和大写</span><br><span class="line"><span class="number">2.</span> <span class="title function_">version</span> (版本号)要求 x.<span class="property">x</span>.<span class="property">x</span> 的形式定义，x必须是数字，默认值是<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="number">3.</span> <span class="variable constant_">ISC</span> 证书与 <span class="variable constant_">MIT</span> 证书功能上是相同的，关于开源证书扩展阅读 <span class="attr">http</span>:<span class="comment">//www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</span></span><br><span class="line"><span class="number">4.</span> package.<span class="property">json</span> 可以手动创建与修改</span><br><span class="line"><span class="number">5.</span> 使用npm init -y或者npm init --yes 极速创建package.<span class="property">json</span></span><br></pre></td></tr></table></figure><h4 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 命令行 『npm s/search 关键字』</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="string">`网站搜索`</span> 网址是 <span class="attr">https</span>:<span class="comment">//www.npmjs.com/</span></span><br></pre></td></tr></table></figure><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式</span></span><br><span class="line">npm install &lt;包名&gt;</span><br><span class="line">npm i &lt;包名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line"></span><br><span class="line">npm install uniq</span><br><span class="line">npm i uniq</span><br><span class="line"></span><br><span class="line">运行之后文件夹下会增加两个资源</span><br><span class="line"></span><br><span class="line">- node_modules 文件夹 存放下载的包</span><br><span class="line">- package-lock.json 包的锁文件，用来锁定包的版本</span><br></pre></td></tr></table></figure><h4 id="require导入npm包"><a href="#require导入npm包" class="headerlink" title="require导入npm包"></a>require导入npm包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在当前文件夹下 node_modules 中寻找同名的文件夹</span><br><span class="line">在上级目录中下的 node_modules 中寻找同名的文件夹，直至找到磁盘根目录</span><br></pre></td></tr></table></figure><h3 id="生产环境与开发环境"><a href="#生产环境与开发环境" class="headerlink" title="生产环境与开发环境"></a>生产环境与开发环境</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">开发环境 是程序员专门用来写代码的环境，一般是指程序员的电脑，开发环境的项目一般只能程序员自己访问</span><br><span class="line"></span><br><span class="line">生产环境 是项目代码正式运行的环境，一般是指正式的服务器电脑，生产环境的项目一般每个客户都可以访问</span><br></pre></td></tr></table></figure><h4 id="生产依赖与开发依赖"><a href="#生产依赖与开发依赖" class="headerlink" title="生产依赖与开发依赖"></a>生产依赖与开发依赖</h4><table><thead><tr><th>类型</th><th>命令</th><th>补充</th></tr></thead><tbody><tr><td>生产依赖</td><td>npm i -S uniq <br/>npm i –save uniq</td><td>-S 等效于 –save，-S 是默认选项<br/>包信息保存在 package.json 中 dependencies 属性</td></tr><tr><td>开发依赖</td><td>npm i -D less<br/>npm i –save-dev less</td><td>-D 等效于 –save-dev<br/>包信息保存在 package.json 中 devDependencies 属性</td></tr></tbody></table><h3 id="npm全局安装"><a href="#npm全局安装" class="headerlink" title="npm全局安装"></a>npm全局安装</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">我们可以执行安装选项 -g 进行全局安装</span><br><span class="line"></span><br><span class="line">npm i -g 包名</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 全局安装的命令不受工作目录位置影响</span><br><span class="line">- 可以通过npm root -g可以查看全局安装包的位置</span><br><span class="line">- 不是所有的包都适合全局安装，只有全局类的工具才适合，可以通过查看包的官方文档来确定安装方式，这里先不必太纠结</span><br></pre></td></tr></table></figure><h3 id="安装包依赖"><a href="#安装包依赖" class="headerlink" title="安装包依赖"></a>安装包依赖</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm install</span><br><span class="line">通过该命令可以依据 package.<span class="property">json</span> 和 package-lock.<span class="property">json</span> 的依赖声明安装项目依赖</span><br></pre></td></tr></table></figure><h3 id="安装指定版本的包或者对以前包进行版本更改"><a href="#安装指定版本的包或者对以前包进行版本更改" class="headerlink" title="安装指定版本的包或者对以前包进行版本更改"></a>安装指定版本的包或者对以前包进行版本更改</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## 格式</span><br><span class="line">npm i &lt;包名@版本号&gt;</span><br><span class="line"></span><br><span class="line">## 示例</span><br><span class="line">npm i jquery@<span class="number">1.11</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><h3 id="删除依赖包"><a href="#删除依赖包" class="headerlink" title="删除依赖包"></a>删除依赖包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## 局部删除</span><br><span class="line">npm remove uniq</span><br><span class="line">npm r uniq</span><br><span class="line"></span><br><span class="line">## 全局删除</span><br><span class="line">npm remove -g nodemon</span><br></pre></td></tr></table></figure><h3 id="配置命令别名"><a href="#配置命令别名" class="headerlink" title="配置命令别名"></a>配置命令别名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">通过配置命令别名可以更简单的执行命令</span><br><span class="line"></span><br><span class="line">配置 package.<span class="property">json</span> 中的scripts属性</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;server&quot;</span>: <span class="string">&quot;node server.js&quot;</span>,</span><br><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;node index.js&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br><span class="line">配置完成之后，可以使用别名执行命令</span><br><span class="line">npm run server</span><br><span class="line">npm run start   /  npm start</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">补充说明：</span><br><span class="line"></span><br><span class="line">-npm start是项目中常用的一个命令，一般用来启动项目</span><br><span class="line">-npm run有自动向上级目录查找的特性，跟<span class="built_in">require</span>函数也一样</span><br><span class="line">- 对于陌生的项目，我们可以通过查看scripts属性来参考项目的一些操作</span><br></pre></td></tr></table></figure><h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>cnpm 是一个淘宝构建的npmjs.com的完整镜像，也称为『淘宝镜像』，网址<a href="https://npmmirror.com/">https://npmmirror.com/</a><br>cnpm 服务部署在国内阿里云服务器上，可以提高包的下载速度</p><p>官方也提供了一个全局工具包 cnpm ，操作命令与 npm 大体相同</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们可以通过 npm 来安装 cnpm 工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>初始化</td><td>cnpm init &#x2F; cnpm init</td></tr><tr><td>安装包</td><td>cnpm i uniq<br/>cnpm i -S uniq<br/>cnpm i -D uniq<br/>cnpm i -g nodemon</td></tr><tr><td>安装项目依赖</td><td>cnpm i</td></tr><tr><td>删除</td><td>cnpm r uniq</td></tr></tbody></table><h2 id="npm-配置淘宝镜像–推荐"><a href="#npm-配置淘宝镜像–推荐" class="headerlink" title="npm 配置淘宝镜像–推荐"></a>npm 配置淘宝镜像–推荐</h2><p>用 npm 也可以使用淘宝镜像，配置的方式有两种</p><ul><li>直接配置</li><li>工具配置</li></ul><h3 id="直接配置"><a href="#直接配置" class="headerlink" title="直接配置"></a>直接配置</h3><p>执行如下命令即可完成配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><h3 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h3><p>使用 nrm 配置 npm 的镜像地址 npm registry manager</p><ol><li><p>安装 nrm</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g nrm</span><br></pre></td></tr></table></figure></li><li><p>修改镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm use taobao</span><br><span class="line"></span><br><span class="line">nrm ls 检查可用的镜像资源</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>检查是否配置成功（选做）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>检查 registry 地址是否为 <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com/</a> , 如果是则表明成功</p></li></ol><blockquote><p>补充说明：</p><ol><li>建议使用第二种方式进行镜像配置，因为后续修改起来会比较方便</li><li>虽然 cnpm 可以提高速度，但是 npm 也可以通过淘宝镜像进行加速，所以 &lt;span npm 的使用率还是高于 cnpm</li></ol></blockquote><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><h3 id="yarn-介绍"><a href="#yarn-介绍" class="headerlink" title="yarn 介绍"></a>yarn 介绍</h3><blockquote><p>yarn 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具，官方网址：<a href="https://yarnpkg.com/">https://yarnpkg.com/</a></p></blockquote><h3 id="yarn-特点"><a href="#yarn-特点" class="headerlink" title="yarn 特点"></a>yarn 特点</h3><p>yarn 官方宣称的一些特点</p><ul><li>速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快</li><li>超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性</li><li>超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的工作</li></ul><h3 id="yarn-安装"><a href="#yarn-安装" class="headerlink" title="yarn 安装"></a>yarn 安装</h3><p>我们可以使用 npm 安装 yarn</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g yarn</span><br></pre></td></tr></table></figure><h3 id="yarn-常用命令"><a href="#yarn-常用命令" class="headerlink" title="yarn 常用命令"></a>yarn 常用命令</h3><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>初始化</td><td>yarn init &#x2F; yarn init -y</td></tr><tr><td>安装包</td><td>yarn add uniq 生产依赖<br/>yarn add less –dev 开发依赖<br/>yarn global add nodemon 全局安装</td></tr><tr><td>删除包</td><td>yarn remove uniq 删除项目依赖包<br>yarn global remove nodemon 全局删除包</td></tr><tr><td>安装项目依赖</td><td>yarn</td></tr><tr><td>运行命令别名</td><td>yarn &lt;别名&gt; # 不需要添加 <code>run</code></td></tr></tbody></table><blockquote><p>思考题：</p><p>这里有个小问题就是 <span style="color:red">全局安装的包不可用</span>，yarn 全局安装包的位置可以通过 <code>yarn global bin</code>来查看，</p><p>那你有没有办法使 yarn 全局安装的包能够正常运行？</p><ul><li>配置 path 环境</li></ul></blockquote><h3 id="yarn-配置淘宝镜像"><a href="#yarn-配置淘宝镜像" class="headerlink" title="yarn 配置淘宝镜像"></a>yarn 配置淘宝镜像</h3><p>可以通过如下命令配置淘宝镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn config set registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p>可以通过 <code>yarn config list</code> 查看 yarn 的配置项</p><h3 id="npm-和-yarn-选择"><a href="#npm-和-yarn-选择" class="headerlink" title="npm 和 yarn 选择"></a>npm 和 yarn 选择</h3><p>大家可以根据不同的场景进行选择</p><ol><li><p>个人项目</p><p>如果是个人项目，<span style="color:red">哪个工具都可以</span>，可以根据自己的喜好来选择</p></li><li><p>公司项目<br>如果是公司要根据项目代码来选择，可以 <span style="color:red">通过锁文件判断</span> 项目的包管理工具</p><ul><li>npm 的锁文件为 <code>package-lock.json</code></li><li>yarn 的锁文件为 <code>yarn.lock</code></li></ul></li></ol><blockquote><p>包管理工具 <span style="color:red">不要混着用，切记，切记，切记</span></p></blockquote><h2 id="管理发布包"><a href="#管理发布包" class="headerlink" title="管理发布包"></a>管理发布包</h2><h3 id="创建与发布"><a href="#创建与发布" class="headerlink" title="创建与发布"></a>创建与发布</h3><p>我们可以将自己开发的工具包发布到 npm 服务上，方便自己和其他开发者使用，操作步骤如下：</p><ol><li><p>创建文件夹，并创建文件 index.js， 在文件中声明函数，使用 module.exports 暴露</p></li><li><p>npm 初始化工具包，package.json 填写包的信息 (包的名字是唯一的)</p></li><li><p>注册账号 <a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a></p></li><li><p>激活账号 （ <span style="color:red">一定要激活账号</span> ）</p></li><li><p>修改为官方的官方镜像 (命令行中运行 <code>nrm use npm</code> )</p></li><li><p>命令行下 <code>npm login</code> 填写相关用户信息</p></li><li><p>命令行下 <code>npm publish</code> 提交包 👌</p></li></ol><h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><p>后续可以对自己发布的包进行更新，操作步骤如下</p><ol><li><p>更新包中的代码</p></li><li><p>测试代码是否可用</p></li><li><p>修改 <code>package.json</code> 中的版本号</p></li><li><p>发布更新</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h3><p>执行如下命令删除包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm unpublish --force</span><br></pre></td></tr></table></figure><blockquote><p>删除包需要满足一定的条件， <a href="https://docs.npmjs.com/policies/unpublish">https://docs.npmjs.com/policies/unpublish</a></p><ul><li>你是包的作者</li><li>发布小于 24 小时</li><li>大于 24 小时后，没有其他包依赖，并且每周小于 300 下载量，并且只有一个维护者</li></ul></blockquote><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><p>在很多语言中都有包管理工具，比如：</p><table><thead><tr><th>语言</th><th>包管理工具</th></tr></thead><tbody><tr><td>PHP</td><td>composer</td></tr><tr><td>Python</td><td>pip</td></tr><tr><td>Java</td><td>maven</td></tr><tr><td>Go</td><td>go mod</td></tr><tr><td>JavaScript</td><td>npm&#x2F;yarn&#x2F;cnpm&#x2F;other</td></tr><tr><td>Ruby</td><td>rubyGems</td></tr></tbody></table><p>除了编程语言领域有包管理工具之外，操作系统层面也存在包管理工具，不过这个包指的是『<code>软件包</code>』</p><table><thead><tr><th>操作系统</th><th>包管理工具</th><th>网址</th></tr></thead><tbody><tr><td>Centos</td><td>yum</td><td><a href="https://packages.debian.org/stable/">https://packages.debian.org/stable/</a></td></tr><tr><td>Ubuntu</td><td>apt</td><td><a href="https://packages.ubuntu.com/">https://packages.ubuntu.com/</a></td></tr><tr><td>MacOS</td><td>homebrew</td><td><a href="https://brew.sh/">https://brew.sh/</a></td></tr><tr><td>Windows</td><td>chocolatey</td><td><a href="https://chocolatey.org/">https://chocolatey.org/</a></td></tr></tbody></table><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><p>nvm 全称 <code>Node Version Manager</code> 顾名思义它是用来管理 node 版本的工具，方便切换不同版本的Node.js</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>nvm 的使用非常的简单，跟 npm 的使用方法类似</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>首先先下载 nvm，下载地址 <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a> ，</p><p>选择 <code>nvm-setup.exe</code> 下载即可（网络异常的小朋友可以在资料文件夹中获取）</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nvm list available</td><td>显示所有可以下载的 Node.js 版本</td></tr><tr><td>nvm list</td><td>显示已安装的版本</td></tr><tr><td>nvm install 18.12.1</td><td>安装 18.12.1 版本的 Node.js</td></tr><tr><td>nvm install latest</td><td>安装最新版的 Node.js</td></tr><tr><td>nvm uninstall 18.12.1</td><td>删除某个版本的 Node.js</td></tr><tr><td>nvm use 18.12.1</td><td>切换 18.12.1 的 Node.js</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法</title>
      <link href="/posts/36266.html"/>
      <url>/posts/36266.html</url>
      
        <content type="html"><![CDATA[<h1 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">模板字符串（template string）是增强版的字符串，用反引号 <span class="string">` 标识，特点</span></span><br><span class="line"><span class="string">字符串中可以出现换行符</span></span><br><span class="line"><span class="string">可以使用 <span class="subst">$&#123;xxx&#125;</span> 形式输出变量，近似 EL 表达式</span></span><br><span class="line"><span class="string">应用场景：当遇到字符串与变量拼接的情况使用模板字符串</span></span><br><span class="line"><span class="string">let name = &#x27;jack&#x27;;</span></span><br><span class="line"><span class="string">console.log(`</span>hello, $&#123;name&#125;<span class="string">`);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let ul = `</span>&lt;ul&gt;</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>peach<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">          &lt;/ul&gt;</span><br></pre></td></tr></table></figure><h1 id="rest参数和spread扩展运算符"><a href="#rest参数和spread扩展运算符" class="headerlink" title="rest参数和spread扩展运算符"></a>rest参数和spread扩展运算符</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于rest参数来讲，相当于对于不确定的函数参数，可以把他转化为数组接收</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> =(<span class="params">a,b,...args</span>) =&gt;&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">&#125;</span><br><span class="line">对于这个函数来讲，如果输入五个参数，那么...args会接收三个参数并且转化为数组的形式存储</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于spread扩展运算符来讲，</span><br><span class="line">扩展运算符spread也是三个点...，它好比 rest 参数的逆运算，将一个数组、伪数组转为用逗号分隔的参数序列，对数组进行解包，扩展运算符也可以将对象解包</span><br><span class="line">可用在调用函数时，传递的实参，将一个数组转换为参数序列（与rest参数的区别，一个用在形参，一个实参）</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">感觉鸡肋，不知道能干嘛</span><br></pre></td></tr></table></figure><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES6</span> 提供了新的数据结构<span class="title class_">Set</span>（集合），它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用扩展运算符 ... 和 <span class="keyword">for</span>...<span class="keyword">of</span> 进行遍历</span><br><span class="line"></span><br><span class="line"><span class="attr">eg</span>: <span class="keyword">let</span> st = <span class="keyword">new</span> <span class="title class_">Set</span>（）</span><br><span class="line"></span><br><span class="line">st.<span class="property">size</span>：返回集合个数</span><br><span class="line">st.<span class="title function_">add</span>(item)：往集合中添加一个新元素 item，返回当前集合</span><br><span class="line">st.<span class="title function_">delete</span>(item)：删除集合中的元素，返回 boolean 值</span><br><span class="line">st.<span class="title function_">has</span>(item)：检测集合中是否包含某个元素，返回 boolean 值</span><br><span class="line">st.<span class="title function_">clear</span>()：清空集合</span><br><span class="line">集合转为数组：[...st]</span><br><span class="line">合并两个集合：[...st1, ...st2]</span><br></pre></td></tr></table></figure><h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES6</span> 提供了 <span class="title class_">Map</span> 数据结构。它类似于对象，也是键值对的集合。但是 “键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<span class="title class_">Map</span> 也实现了 iterator 接口，所以可以使用扩展运算符 ... 和 <span class="keyword">for</span>...<span class="keyword">of</span> 进行遍历</span><br><span class="line"></span><br><span class="line"><span class="title class_">Map</span> 的属性和方法：（k 为键，v为值）</span><br><span class="line">size：返回 <span class="title class_">Map</span> 的元素（键值对）个数</span><br><span class="line"><span class="title function_">set</span>(k, v)：增加一个键值对，返回当前 <span class="title class_">Map</span></span><br><span class="line"><span class="title function_">get</span>(k)：返回键值对的键值</span><br><span class="line"><span class="title function_">has</span>()：检测 <span class="title class_">Map</span> 中是否包含某个元素</span><br><span class="line"><span class="title function_">clear</span>()：清空集合，返回 <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">ES6</span>对象而言，更加规范化，有了构造器constructor，也有了继承<span class="keyword">extends</span>，静态属性<span class="keyword">static</span>,有了getter 和setter方法</span><br></pre></td></tr></table></figure><h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">EPSILON</span> 是 <span class="title class_">JavaScript</span> 表示的最小精度，一般用来处理浮点数运算。例如可以用于两个浮点数的比较</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">equal</span> = (<span class="params">x, y</span>) =&gt; x - y &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equal</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">isFinite</span> 检测一个数是否为有限数</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES6</span> 给 <span class="title class_">Number</span> 添加了 <span class="built_in">parseInt</span> 方法，<span class="title class_">Number</span>.<span class="property">parseInt</span> 完全等同于 <span class="built_in">parseInt</span>。将字符串转为整数，或者进行进制转换。<span class="title class_">Number</span>.<span class="property">parseFloat</span> 则等同于 <span class="built_in">parseFloat</span>()   </span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>() 判断一个数是否为整数</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>() 将数字的小数部分抹掉</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">sign</span> 判断一个数到底为正数 负数 还是零 </span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>()检测一个数值是否为 <span class="title class_">NaN</span> </span><br></pre></td></tr></table></figure><h1 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>() 方法判断两个值是否完全相同。<span class="title class_">Object</span>.<span class="property">is</span> 比较两个值是否严格相等，与 === 行为 基本一致，返回一个 <span class="title class_">Boolean</span> 类型</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">assign</span> 对象的合并，相当于浅拷贝？？ <span class="comment">// 有相同属性，后面的会覆盖前面的</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">setPrototypeOf</span> 用于设置对象的原型对象</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">getPrototypeof</span> 用于获取对象的原型对象，相当于 __proto__</span><br></pre></td></tr></table></figure><h1 id="模块化（感觉vue里面大量用）"><a href="#模块化（感觉vue里面大量用）" class="headerlink" title="模块化（感觉vue里面大量用）"></a>模块化（感觉vue里面大量用）</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> 命令用于规定模块的对外接口</span><br><span class="line"><span class="keyword">import</span> 命令用于输入其他模块提供的功能</span><br></pre></td></tr></table></figure><h1 id="ES7新特性"><a href="#ES7新特性" class="headerlink" title="ES7新特性"></a>ES7新特性</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property">includes</span></span><br><span class="line">includes 方法用来检测数组中是否包含某个元素，返回布尔类型值</span><br><span class="line">在 <span class="title class_">ES7</span> 中引入指数运算符 **，用来实现幂运算，功能与 <span class="title class_">Math</span>.<span class="title function_">pow</span>(a, b) 结果相同</span><br></pre></td></tr></table></figure><h1 id="ES8新特性"><a href="#ES8新特性" class="headerlink" title="ES8新特性"></a>ES8新特性</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">async</span> 和 <span class="keyword">await</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">await</span> 相当于一个运算符，右边接一个值。一般为一个 <span class="title class_">Promise</span> 对象，也可以是一个非 <span class="title class_">Promise</span> 类型。</span><br><span class="line">当右接一个非 promise 类型，<span class="keyword">await</span> 表达式返回的值就是这个值；当右接一个 promise 对象，则 <span class="keyword">await</span> 表达式会阻塞后面的代码，等待当前 promise 对象 resolve 的值</span><br><span class="line">综合 <span class="keyword">async</span> 和 <span class="keyword">await</span> 而言</span><br><span class="line"><span class="keyword">await</span> 必须写在 <span class="keyword">async</span> 函数中</span><br><span class="line"><span class="keyword">await</span> 右侧的表达式一般为 promise 对象</span><br><span class="line"><span class="keyword">await</span> 返回的是 promise 成功的值</span><br><span class="line"><span class="keyword">await</span> 的 promise 失败了就会抛出异常，需要使用 <span class="keyword">try</span>-<span class="keyword">catch</span> 捕获处理</span><br><span class="line"><span class="title class_">Promise</span> 使用链式调用解决了传统方式回调地狱的问题，而 <span class="keyword">async</span>-<span class="keyword">await</span> 又进一步优化了代码的可读性</span><br></pre></td></tr></table></figure><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://es6.ruanyifeng.com/#docs/async#%E8%AF%AD%E6%B3%95">ES6语法教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript</title>
      <link href="/posts/11351.html"/>
      <url>/posts/11351.html</url>
      
        <content type="html"><![CDATA[<h1 id="javaScript基本用法"><a href="#javaScript基本用法" class="headerlink" title="javaScript基本用法"></a>javaScript基本用法</h1><h2 id="表示形式-引入方式"><a href="#表示形式-引入方式" class="headerlink" title="表示形式&#x2F;引入方式"></a>表示形式&#x2F;引入方式</h2><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>对于js的使用，一般显示有三种方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;你好啊&#x27;</span>) --在网页弹出层弹出一个窗口展示</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;手动写入&#x27;</span>) -- 直接写入内容将页面改写成这个样式</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message&#x27;</span>) --在控制台打印信息</span><br><span class="line">innerHTML = <span class="string">&quot;段落已修改。&quot;</span> 是用于修改元素的 <span class="variable constant_">HTML</span> 内容(innerHTML)的 <span class="title class_">JavaScript</span> 代码。</span><br><span class="line"></span><br><span class="line">输入代码</span><br><span class="line">&lt;button onclick=<span class="string">&quot;prompt(&#x27;请输入你的名字&#x27;)&quot;</span>&gt;控制台&lt;/button&gt;</span><br><span class="line">点击完成后弹出一个输入框让你进行输入</span><br><span class="line">num = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入&#x27;</span>);</span><br><span class="line">也可以这样书写，让输入的值保存在num里面</span><br></pre></td></tr></table></figure><h3 id="对于js代码的引入"><a href="#对于js代码的引入" class="headerlink" title="对于js代码的引入"></a>对于js代码的引入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">首先可以元素内引入，如以下三种方式为例子：</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;alert(&#x27;你好啊&#x27;)&quot;</span> value=<span class="string">&quot;点我&quot;</span>&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;控制台打印！&#x27;)&quot;</span>&gt;</span>控制台<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;点我&#x27;);&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以script标签引入</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;根据script标签在控制台打印&quot;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">第三种方式，可以自己写一个js文件后缀，用script引入</span><br><span class="line">&lt;script src=<span class="string">&quot;demo.js&quot;</span>&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>对于引入来说，执行顺序按照引入的先后顺序来进行执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于第三种方式js方式的引入，不可以在script标签里面继续写方法，不会执行</span><br><span class="line">&lt;script src=<span class="string">&quot;demo.js&quot;</span>&gt;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;根据script标签在控制台打印&quot;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">方法体里面的<span class="variable language_">console</span>语句不会执行</span><br></pre></td></tr></table></figure><h2 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h2><p>对于javascript来讲，大小写敏感，所以对于变量的命名以及使用来说，大小写的书写一定要规范。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于变量声明来说，如果不声明直接使用，会报错</span><br><span class="line">如果声明没有赋值，那么会<span class="literal">undefined</span></span><br><span class="line">如果不声明直接赋值，js允许，但是会未全局变量，不提倡</span><br><span class="line">如果重新声明 <span class="title class_">JavaScript</span> 变量，该变量的值不会丢失：</span><br><span class="line"></span><br><span class="line">函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖</span><br></pre></td></tr></table></figure><h2 id="对于let-var-const的区别"><a href="#对于let-var-const的区别" class="headerlink" title="对于let,var,const的区别"></a>对于let,var,const的区别</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419153109858-269692.png" alt="image-20230419153109858"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在 <span class="title class_">ES6</span> 之前，是没有块级作用域的概念的。</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES6</span> 可以使用 <span class="keyword">let</span> 关键字来实现块级作用域。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 声明的变量只在 <span class="keyword">let</span> 命令所在的代码块 &#123;&#125; 内有效，在 &#123;&#125; 之外不能访问。</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">值类型(基本类型)：字符串（<span class="title class_">String</span>）、数字(<span class="title class_">Number</span>)、布尔(<span class="title class_">Boolean</span>)、空（<span class="title class_">Null</span>）、未定义（<span class="title class_">Undefined</span>）、<span class="title class_">Symbol</span>。</span><br><span class="line"></span><br><span class="line">引用数据类型（对象类型）：对象(<span class="title class_">Object</span>)、数组(<span class="title class_">Array</span>)、函数(<span class="title class_">Function</span>)，还有两个特殊的对象：正则（<span class="title class_">RegExp</span>）和日期（<span class="title class_">Date</span>）。</span><br><span class="line"></span><br><span class="line">我的理解是值类型就是引用值，数据类型相当于指针的意思</span><br></pre></td></tr></table></figure><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419163224483-c3d614.png" alt="image-20230419163224483"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419163247110-460216.png" alt="image-20230419163247110"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419163304250-a165d4.png" alt="image-20230419163304250"></p><h2 id="对象概念"><a href="#对象概念" class="headerlink" title="对象概念"></a>对象概念</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来说，里面的数据都是对象的形式，即<span class="attr">name</span>:value键值对的存储形式，相当于java的类吧</span><br><span class="line">对于一个对象可以这样定义：</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    id : <span class="number">5566</span>,</span><br><span class="line">    fullName : <span class="keyword">function</span>(<span class="params"></span>) </span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">在上面的定义中，定义了三个属性和一个方法，</span><br><span class="line">对于属性的访问，一般有两种方法person.<span class="property">lastName</span>; person[<span class="string">&quot;lastName&quot;</span>];</span><br><span class="line"></span><br><span class="line">这两个方法，第一个方法有时候不能使用，第二个方法通用</span><br><span class="line">两种情况不能使用：属性名包含特殊字符</span><br><span class="line">对于属性名给定的属性不确定，即给定的属性不是一个常量是一个变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于方法的调用person.<span class="title function_">fullName</span>();不添加 (), 它会返回函数的定义：</span><br><span class="line">对于方法的创建：</span><br><span class="line">methodName : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于javascript里面的函数定义来说</span><br><span class="line">function functionname()</span><br><span class="line">&#123;</span><br><span class="line">    // 执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量和全局变量创建区别"><a href="#局部变量和全局变量创建区别" class="headerlink" title="局部变量和全局变量创建区别"></a>局部变量和全局变量创建区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于局部变量来说，一般存在函数内，函数开始执行时创建，函数执行完后局部变量会自动销毁。</span><br><span class="line"><span class="comment">// 此处不能调用 carName 变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 函数内可调用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">变量在函数外定义，即为全局变量</span><br><span class="line">全局变量有 全局作用域: 网页中所有脚本和函数均可使用。 </span><br><span class="line">全局变量在函数内修改和外部修改效果一样</span><br><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot; Volvo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数内可调用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但要注意的一点是，如果在函数里面申明变量没有<span class="keyword">var</span>，那么为全局变量</span><br><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于获取一个元素"><a href="#对于获取一个元素" class="headerlink" title="对于获取一个元素"></a>对于获取一个元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于获取一个元素id的时候，可以采用下面的方法,参数传入id</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">一定一定要注意大小写，以及格式，报错</span><br><span class="line"><span class="title class_">Document</span>.<span class="property">getElementById</span> is not a <span class="keyword">function</span>  可能就是大小写出错！！</span><br></pre></td></tr></table></figure><h2 id="this作用域"><a href="#this作用域" class="headerlink" title="this作用域"></a>this作用域</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果对于函数调用默认是<span class="variable language_">window</span>，对于元素标签内调用为元素本身，如果<span class="keyword">new</span>一个然后再<span class="keyword">new</span>的进行调用，那么就是<span class="keyword">new</span>出来的结果</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）<span class="variable language_">this</span>的指向是在函数执行的时候确定的，在函数定义的时候是确定不了，实际上<span class="variable language_">this</span>的最终指向的是那个调用它的对象</span><br><span class="line">（<span class="number">2</span>）调用执行函数时，“.”前面是什么，<span class="variable language_">this</span>就是什么。前面没有对象，就是<span class="variable language_">window</span>了。</span><br><span class="line"></span><br><span class="line">在方法中，<span class="variable language_">this</span> 表示该方法所属的对象。</span><br><span class="line">如果单独使用，<span class="variable language_">this</span> 表示全局对象。</span><br><span class="line">在函数中，<span class="variable language_">this</span> 表示全局对象。</span><br><span class="line">在函数中，在严格模式下，<span class="variable language_">this</span> 是未定义的(<span class="literal">undefined</span>)。</span><br><span class="line">在事件中，<span class="variable language_">this</span> 表示接收事件的元素。</span><br><span class="line">类似 <span class="title function_">call</span>() 和 <span class="title function_">apply</span>() 方法可以将 <span class="variable language_">this</span> 引用到任何对象。</span><br><span class="line"></span><br><span class="line">对于call和apply方法来讲，可以对<span class="variable language_">this</span>进行重新定义，举个简单的例子，对于一个对象里面的方法，在外面重新定义的对象可以重定向进行使用，看下面的例子：</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.<span class="property">fullName</span>.<span class="title function_">call</span>(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line">同样的，一个函数可以当作一个对象，可以对外面函数直接进行<span class="variable language_">this</span>转化调用，具体请看<span class="variable constant_">CSDN</span>博客，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">call</span>() 和 <span class="title function_">apply</span>() 之间的区别</span><br><span class="line">不同之处是：</span><br><span class="line"><span class="title function_">call</span>() 方法分别接受参数。</span><br><span class="line"><span class="title function_">apply</span>() 方法接受数组形式的参数。</span><br><span class="line">如果要使用数组而不是参数列表，则 <span class="title function_">apply</span>() 方法非常方便</span><br></pre></td></tr></table></figure><h2 id="常见的HTML事件"><a href="#常见的HTML事件" class="headerlink" title="常见的HTML事件"></a>常见的HTML事件</h2><table><thead><tr><th align="left">事件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onchange</td><td align="left">HTML 元素改变</td></tr><tr><td align="left">onclick</td><td align="left">用户点击 HTML 元素</td></tr><tr><td align="left">onmouseover</td><td align="left">鼠标指针移动到指定的元素上时发生</td></tr><tr><td align="left">onmouseout</td><td align="left">用户从一个 HTML 元素上移开鼠标时发生</td></tr><tr><td align="left">onkeydown</td><td align="left">用户按下键盘按键</td></tr><tr><td align="left">onload</td><td align="left">浏览器已完成页面的加载</td></tr></tbody></table><h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于string字符串来讲，首先可以用单引号或者双引号都创建一个字符</span><br><span class="line">可以用索引寻找字符串中的一个字符</span><br><span class="line">可以在字符串里面使用引号，但是得注意引号不能相同</span><br><span class="line">如果引号相同需要使用转义字符\  <span class="attr">eg</span>:\<span class="string">&#x27; \&quot;</span></span><br><span class="line"><span class="string">可以用内置函数length来获取字符串长度</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">也可以将字符串创建为对象</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span>; <span class="comment">//string类型</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">//object类型</span></span><br><span class="line">x != y 对象不同不相等</span><br><span class="line">一般不推荐string对象，因为会拖慢执行速度，并可能产生其他副作用</span><br></pre></td></tr></table></figure><h3 id="注意一点"><a href="#注意一点" class="headerlink" title="注意一点"></a>注意一点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来讲，在进行字符串比较的时候，==是进行值比较</span><br><span class="line">举个例子：</span><br><span class="line"><span class="number">10</span> ==  <span class="literal">true</span></span><br><span class="line"> <span class="number">10</span> === <span class="string">&quot;10&quot;</span> <span class="literal">false</span></span><br><span class="line">两个等号是值相等，三个等号是连类型也进行判断，要注意误区</span><br><span class="line">t</span><br></pre></td></tr></table></figure><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来讲，<span class="keyword">break</span>语句，不仅仅可以在循环中使用，还可以在其他地方</span><br><span class="line"><span class="keyword">continue</span> 语句（带有或不带标签引用）只能用在循环中。</span><br><span class="line"><span class="keyword">break</span> 语句（不带标签引用），只能用在循环或 <span class="keyword">switch</span> 中。</span><br><span class="line">通过标签引用，<span class="keyword">break</span> 语句可用于跳出任何 <span class="title class_">JavaScript</span> 代码块：</span><br><span class="line">eg：cars=[<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Ford&quot;</span>];</span><br><span class="line"><span class="attr">list</span>: </span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">0</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">1</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">2</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="keyword">break</span> list;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">3</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">4</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">5</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于二者的区别来讲</span><br><span class="line"><span class="literal">null</span>是一个只有一个值的特殊类型，表示一个空对象引用，一般常用来对于大对象数据的释放等</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span>表示没有设置值的一个对象，相当于声明这个变量了，但是没有给这个变量赋值，相当于没有赋值变量的默认值</span><br><span class="line"></span><br><span class="line">对于两者的区别：</span><br><span class="line"><span class="literal">null</span>是object对象类型的数据，<span class="literal">undefined</span>是表示<span class="literal">undefined</span>类型数据</span><br><span class="line">对于二者的值来比较是相同的，但是类型是不同的</span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来讲，他是支持正则表达式，它把正则表达式当作一个对象来进行处理</span><br><span class="line"></span><br><span class="line">语法 : <span class="regexp">/正则表达式主体/</span>修饰符(可选)</span><br><span class="line"></span><br><span class="line">首先对于字符串来讲，有两个函数支持正则表达式</span><br><span class="line"><span class="title function_">search</span>() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</span><br><span class="line"><span class="title function_">replace</span>() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">RegExp</span>对象，在javascript里面定义了正则化对象，</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>() 方法是一个正则表达式方法。</span><br><span class="line"><span class="title function_">test</span>() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="title function_">exec</span>() 方法是一个正则表达式方法。</span><br><span class="line"><span class="title function_">exec</span>() 方法用于检索字符串中的正则表达式的匹配。</span><br><span class="line">该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 <span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h2 id="debugger关键字"><a href="#debugger关键字" class="headerlink" title="debugger关键字"></a>debugger关键字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="keyword">debugger</span>关键字，可以在进行测试以及调试的时候，在此处暂停<span class="title class_">JavaScript</span>的运行，从而进行调试，其原理和在编译器设置duan</span><br></pre></td></tr></table></figure><h2 id="‘use-strict’严格模式"><a href="#‘use-strict’严格模式" class="headerlink" title="‘use strict’严格模式"></a>‘use strict’严格模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">JavaScript</span>来讲用来规范程序员的代码书写规范，所以一般使用严格模式来进行约束，严格了一些格式书写上面的错误以及规范写法，函数不声明不能赋值等问题，详细参考菜鸟教程</span><br></pre></td></tr></table></figure><h2 id="JavaScript验证API"><a href="#JavaScript验证API" class="headerlink" title="JavaScript验证API"></a>JavaScript验证API</h2><p>约束验证DOM方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">checkValidity</span>()如果 input 元素中的数据是合法的返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">setCustomValidity</span>()</span><br><span class="line">设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。相当于如果发生错误会显示什么。</span><br><span class="line"></span><br><span class="line">使用 setCustomValidity 设置了自定义提示后，</span><br><span class="line">validity.<span class="property">customError</span> 就会变成 <span class="literal">true</span>，</span><br><span class="line">checkValidity 总是会返回 <span class="literal">false</span>。如果要重新判断需要取消自定义提示，方式如下：</span><br><span class="line"><span class="title function_">setCustomValidity</span>(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line"><span class="title function_">setCustomValidity</span>(<span class="literal">null</span>) </span><br><span class="line"><span class="title function_">setCustomValidity</span>(<span class="literal">undefined</span>)</span><br><span class="line">有着三种方法，选一种即可</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">validity</td><td align="left">布尔属性值，返回 input 输入值是否合法</td></tr><tr><td align="left">validationMessage</td><td align="left">浏览器错误提示信息</td></tr><tr><td align="left">willValidate</td><td align="left">指定 input 是否需要验证</td></tr></tbody></table><h3 id="validity的一些属性值"><a href="#validity的一些属性值" class="headerlink" title="validity的一些属性值"></a>validity的一些属性值</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">customError</td><td align="left">设置为 true, 如果设置了自定义的 validity 信息。</td></tr><tr><td align="left">patternMismatch</td><td align="left">设置为 true, 如果元素的值不匹配它的模式属性。</td></tr><tr><td align="left">rangeOverflow</td><td align="left">设置为 true, 如果元素的值大于设置的最大值。</td></tr><tr><td align="left">rangeUnderflow</td><td align="left">设置为 true, 如果元素的值小于它的最小值。</td></tr><tr><td align="left">stepMismatch</td><td align="left">设置为 true, 如果元素的值不是按照规定的 step 属性设置。</td></tr><tr><td align="left">tooLong</td><td align="left">设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。</td></tr><tr><td align="left">typeMismatch</td><td align="left">设置为 true, 如果元素的值不是预期相匹配的类型。</td></tr><tr><td align="left">valueMissing</td><td align="left">设置为 true，如果元素 (required 属性) 没有值。</td></tr><tr><td align="left">valid</td><td align="left">设置为 true，如果元素的值是合法的。</td></tr></tbody></table><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span> 英文全称 <span class="title class_">JavaScript</span> <span class="title class_">Object</span> <span class="title class_">Notation</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>可以当作js对象的字符串表示，本质上是一个字符串，他的表达形式和js对象字符串类似</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>()用于将一个 <span class="title class_">JSON</span> 字符串转换为 <span class="title class_">JavaScript</span> 对象。</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>()用于将 <span class="title class_">JavaScript</span> 值转换为 <span class="title class_">JSON</span> 字符串。</span><br></pre></td></tr></table></figure><h2 id="与javascript-void-0"><a href="#与javascript-void-0" class="headerlink" title="#与javascript:void(0)"></a>#与javascript:void(0)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">href=<span class="string">&quot;#&quot;</span>与href=<span class="string">&quot;javascript:void(0)&quot;</span>的区别</span><br><span class="line">首先对于<span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>)来讲，它相当于javascript去运行一个没有返回值的函数，这里代表运行<span class="number">0</span>也相当于啥也没有运行 <span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="title function_">func</span>())一般形式这样表示</span><br><span class="line"></span><br><span class="line"># 包含了一个位置信息，默认的锚是#top 也就是网页的上端。</span><br><span class="line">而<span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>), 仅仅表示一个死链接。</span><br><span class="line">在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。</span><br><span class="line">如果你要定义一个死链接请使用 <span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>) 。</span><br></pre></td></tr></table></figure><h2 id="Iterator-接口和for-of"><a href="#Iterator-接口和for-of" class="headerlink" title="Iterator 接口和for of"></a>Iterator 接口和for of</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">默认的 <span class="title class_">Iterator</span> 接口部署在数据结构的<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性，或者说，一个数据结构只要具有<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性，就可以认为是“可遍历的”（iterable）。<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器</span><br><span class="line"></span><br><span class="line">对于<span class="title class_">ES6</span>来讲，一些原生属性配置了这个属性，自然可以使用遍历，以下属性：</span><br><span class="line"><span class="title class_">Array</span></span><br><span class="line"><span class="title class_">Map</span></span><br><span class="line"><span class="title class_">Set</span></span><br><span class="line"><span class="title class_">String</span></span><br><span class="line"><span class="title class_">TypedArray</span></span><br><span class="line">函数的 <span class="variable language_">arguments</span> 对象</span><br><span class="line"><span class="title class_">NodeList</span> 对象</span><br><span class="line"></span><br><span class="line"><span class="attr">eg</span>:</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于类似数组的对象（存在数值键名和length属性），部署 <span class="title class_">Iterator</span> 接口，有一个简便方法，就是<span class="title class_">Symbol</span>.<span class="property">iterator</span>方法直接引用数组的 <span class="title class_">Iterator</span> 接口。</span><br><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串也是类似的一个数组的对象，也原生具有 <span class="title class_">Iterator</span> 接口。</span><br><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">iterator.<span class="title function_">next</span>() -&gt;完成对字符串的遍历</span><br></pre></td></tr></table></figure><h3 id="最简单实现"><a href="#最简单实现" class="headerlink" title="最简单实现"></a>最简单实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// &quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">iterator</span>()方法几乎不用部署任何代码，只要用 <span class="keyword">yield</span> 命令给出每一步的返回值即可。</span><br></pre></td></tr></table></figure><h3 id="现有数据结构对iterator使用"><a href="#现有数据结构对iterator使用" class="headerlink" title="现有数据结构对iterator使用"></a>现有数据结构对iterator使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">entries</span>() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 <span class="title class_">Set</span>，键名与键值相同。<span class="title class_">Map</span> 结构的 <span class="title class_">Iterator</span> 接口，默认就是调用entries方法。</span><br><span class="line"><span class="title function_">keys</span>() 返回一个遍历器对象，用来遍历所有的键名。</span><br><span class="line"><span class="title function_">values</span>() 返回一个遍历器对象，用来遍历所有的键值。</span><br></pre></td></tr></table></figure><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一个数据结构只要部署了<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性，就被视为具有 iterator 接口，就可以用<span class="keyword">for</span>...<span class="keyword">of</span>循环遍历它的成员。也就是说，<span class="keyword">for</span>...<span class="keyword">of</span>循环内部调用的是数据结构的<span class="title class_">Symbol</span>.<span class="property">iterator</span>方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">for</span> <span class="keyword">of</span>对<span class="title class_">Set</span> 结构遍历时，返回的是一个值，而 <span class="title class_">Map</span> 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 <span class="title class_">Map</span> 成员的键名和键值。</span><br></pre></td></tr></table></figure><h3 id="for…in-和for…of区别"><a href="#for…in-和for…of区别" class="headerlink" title="for…in 和for…of区别"></a>for…in 和for…of区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JavaScript</span> 原有的<span class="keyword">for</span>...<span class="keyword">in</span>循环，只能获得对象的键名，不能直接获取键值。<span class="title class_">ES6</span> 提供<span class="keyword">for</span>...<span class="keyword">of</span>循环，允许遍历获得键值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>...<span class="keyword">of</span>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<span class="keyword">for</span>...<span class="keyword">in</span>循环也不一样。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">即<span class="keyword">for</span> <span class="keyword">in</span> 还会返回属性值，但是<span class="keyword">for</span> <span class="keyword">of</span>只会返回数组遍历器循环的值</span><br><span class="line"></span><br><span class="line">但是对于普通的对象，必须有iterator接口才可以调用<span class="keyword">for</span> <span class="keyword">of</span>方法，但是<span class="keyword">for</span> <span class="keyword">in</span>方法就可以直接使用，返回键名</span><br></pre></td></tr></table></figure><h3 id="其他遍历语法区别"><a href="#其他遍历语法区别" class="headerlink" title="其他遍历语法区别"></a>其他遍历语法区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">以数组为例，<span class="title class_">JavaScript</span> 提供多种遍历语法。最原始的写法就是<span class="keyword">for</span>循环。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br><span class="line">这种写法比较麻烦，因此数组提供内置的forEach方法。</span><br><span class="line"></span><br><span class="line">myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line">这种写法的问题在于，无法中途跳出forEach循环，<span class="keyword">break</span>命令或<span class="keyword">return</span>命令都不能奏效。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>循环可以遍历数组的键名。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>循环有几个缺点。</span><br><span class="line"></span><br><span class="line">数组的键名是数字，但是<span class="keyword">for</span>...<span class="keyword">in</span>循环是以字符串作为键名“<span class="number">0</span>”、“<span class="number">1</span>”、“<span class="number">2</span>”等等。</span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</span><br><span class="line">某些情况下，<span class="keyword">for</span>...<span class="keyword">in</span>循环会以任意顺序遍历键名。</span><br><span class="line">总之，<span class="keyword">for</span>...<span class="keyword">in</span>循环主要是为遍历对象而设计的，不适用于遍历数组。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">of</span>循环相比上面几种做法，有一些显著的优点。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">有着同<span class="keyword">for</span>...<span class="keyword">in</span>一样的简洁语法，但是没有<span class="keyword">for</span>...<span class="keyword">in</span>那些缺点。</span><br><span class="line">不同于forEach方法，它可以与<span class="keyword">break</span>、<span class="keyword">continue</span>和<span class="keyword">return</span>配合使用。</span><br><span class="line">提供了遍历所有数据结构的统一操作接口。</span><br><span class="line">下面是一个使用 <span class="keyword">break</span> 语句，跳出<span class="keyword">for</span>...<span class="keyword">of</span>循环的例子。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line">上面的例子，会输出斐波纳契数列小于等于 <span class="number">1000</span> 的项。如果当前项大于 <span class="number">1000</span>，就会使用<span class="keyword">break</span>语句跳出<span class="keyword">for</span>...<span class="keyword">of</span>循环。</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;</span><br><span class="line"></span><br><span class="line">(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)</span><br><span class="line">// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span><br><span class="line">() =&gt; &#123;函数声明&#125;</span><br><span class="line"></span><br><span class="line">使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。</span><br><span class="line"></span><br><span class="line">箭头函数是不能提升的，所以需要在使用之前定义。</span><br><span class="line"></span><br><span class="line">箭头函数 this 是静态的，始终指向声明时所在作用域下 this 的值</span><br><span class="line">箭头函数不能作为构造函数实例化</span><br><span class="line">不能使用 arguments</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于JavaScript来讲，对函数参数个数以及类型没有明确规定，如果指定参数没有赋值，那么默认为undefined,</span><br><span class="line"></span><br><span class="line">对于ES6而言，给定了默认值，function myFunction(x, y = 10) &#123;&#125;   这个函数如果y没有明确给值，那么y默认为10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arguments 对象</span><br><span class="line">对于函数传递的参数，都存在arguments 对象里面，可以通过对对象的调用实现对函数参数的使用</span><br></pre></td></tr></table></figure><h2 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在函数中调用的参数是函数的隐式参数。</span><br><span class="line"></span><br><span class="line">JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。</span><br><span class="line"></span><br><span class="line">如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。</span><br><span class="line"></span><br><span class="line">隐式参数的改变在函数外是不可见的。</span><br></pre></td></tr></table></figure><h2 id="通过对象传递参数"><a href="#通过对象传递参数" class="headerlink" title="通过对象传递参数"></a>通过对象传递参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在JavaScript中，可以引用对象的值。</span><br><span class="line"></span><br><span class="line">因此我们在函数内部修改对象的属性就会修改其初始的值。</span><br><span class="line"></span><br><span class="line">修改对象属性可作用于函数外部（全局变量）。</span><br><span class="line"></span><br><span class="line">修改对象属性在函数外是可见的。</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 JavaScript 中，所有函数都能访问它们上一层的作用域。</span><br><span class="line"></span><br><span class="line">JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。</span><br><span class="line"></span><br><span class="line">为了保存局部变量，从而使用了嵌套函数</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">            let count = 1;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                count++;</span><br><span class="line">                console.log(count)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">const r = fn();</span><br><span class="line">如上面的代码，r保存了fn（）里面的常量count并且每次调用++， 因为r是一个变量，存放在内存中，但是r依托于fn 那么就可以找到fn ，fn又要靠返回函数来进行使用，那么就可以找到返回函数，这样相当于保存了返回函数，count赋值操作只运行了一次。</span><br><span class="line"></span><br><span class="line">对于上面变量const r保存 一般使用不可变量const保存， let也可以 不建议</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于对闭包的应用，</span><br><span class="line"></span><br><span class="line">    let add = x=&gt;y=&gt;x+y;</span><br><span class="line">    let add2 = add(2);</span><br><span class="line">    </span><br><span class="line">    本来函数的操作为</span><br><span class="line">    let add = (x,y) =&gt; x+y;</span><br><span class="line">    add(2,3)</span><br><span class="line">    现在add2函数只需要一个参数就可以完成这个操作，</span><br><span class="line">    </span><br><span class="line">如果是a =&gt; b =&gt; c =&gt; &#123;xxx&#125;这种多次柯里化的,如何理解?</span><br><span class="line">理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值</span><br></pre></td></tr></table></figure><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">原型prototype</span><br><span class="line">每个函数都有一个prototype属性，它默认指向一个object空对象(即称为原型对象)。原型对象中有一个属性constructor，它指向函数对象</span><br><span class="line"></span><br><span class="line">即一个函数来讲，有默认属性prototype，他指向一个空对象object  这个空对象有个属性constructor 它又反过来指向函数</span><br><span class="line"></span><br><span class="line">对于函数来讲，函数其实也是一个对象，所以对属性prototype赋新的属性和函数，这个对象都可以调用</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Fun</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;demo1111&quot;</span>) &#125;</span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Fun</span>().<span class="title function_">test</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Fun</span>().<span class="property">name</span>)</span><br></pre></td></tr></table></figure><h2 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于每一个函数function来说，都有一个prototype属性，叫做显式原型 </span><br><span class="line">对于每一个实例化对象来讲，都有一个__proto__属性，称为隐式原型</span><br><span class="line">对象的隐式原型实际上为对应构造函数显式原型的值</span><br><span class="line"> var fn = new Fun()</span><br><span class="line">  console.log(fn.__proto__ == Fun.prototype) =&gt;  true</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从上面的探寻中已经知道，每个对象都有一个__proto__属性，而且这个属性是可以进行叠加的，所以对于一个对象属性寻找来说，如果在自身属性中没有找到，那么就沿着这条链子继续往深的找，</span><br><span class="line"></span><br><span class="line">我的理解来说，有点像java的继承，首先在子类中寻找，如果没有去父类中找，一直找到object里面</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于所有的函数都是Function函数的实例，包括自己本身，</span><br><span class="line">__proto__函数这个属性是一个空的object实例对象</span><br><span class="line">Object的原型对象是原型链的尽头Object.__proto__ 是 null</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取对象属性的时候，会到原型链中进行查找，但是设置对象属性的时候，如果对象没有这个属性，那么直接加上就好了，</span><br><span class="line">方法一般定义在原型中，属性一般通过构造函数定义在对象本身</span><br></pre></td></tr></table></figure><h2 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="attr">n</span>: <span class="number">2</span>, <span class="attr">m</span>: <span class="number">3</span>&#125;<span class="comment">// 这里是改了A.prototype的引用</span></span><br><span class="line">上面相当于对A的原型进行了重新定义，并不是添加，如果添加是可以实时响应的</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>, b.<span class="property">m</span>, c.<span class="property">n</span>, c.<span class="property">m</span>) <span class="comment">// 1 undefined 2 3</span></span><br></pre></td></tr></table></figure><h2 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、构造函数 通过 Star.prototype 指向 原型对象；</span><br><span class="line"></span><br><span class="line">2、原型对象 通过 Star.prototype.constructor 指向 构造函数；</span><br><span class="line"></span><br><span class="line">3、ldh对象实例 通过 ldh._ _proto_ _指向 原型对象；</span><br><span class="line">再通过 原型对象的constructor，要写成ldh._ _proto_ _constructor，指回 构造函数；</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230426193441114-1ff48d.png" alt="image-20230426193441114"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230426200205855-938e30.png" alt="image-20230426200205855"></p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域在函数定义时就已经确定了，而不是在函数调用时</span><br><span class="line">var x = 10;</span><br><span class="line">function fn() &#123; console.log(x); &#125;</span><br><span class="line">function show(f) &#123;</span><br><span class="line">  var x = 20;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn); // 输出10</span><br><span class="line">因为作用域在定义的时候就确定了，所以输出10</span><br></pre></td></tr></table></figure><h1 id="javascript异步调用"><a href="#javascript异步调用" class="headerlink" title="javascript异步调用"></a>javascript异步调用</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于回调函数而言，把函数当作一个参数传到另外一个函数中，当需要用这个函数是，再回调运行()这个函数</span><br><span class="line"></span><br><span class="line">回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。（作为参数传递到另外一个函数中，这个作为参数的函数就是回调函数）</span><br><span class="line"></span><br><span class="line">理解：函数可以作为一个参数传递到另外一个函数中</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于回调函数的特点来讲，</span><br><span class="line"><span class="number">1.</span>不会立即执行</span><br><span class="line"></span><br><span class="line">回调函数作为参数传递给一个函数的时候，传递的只是函数的定义并不会立即执行。和普通的函数一样，回调函数在调用函数数中也要通过()运算符调用才会执行。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>回调函数是一个闭包</span><br><span class="line"></span><br><span class="line">回调函数是一个闭包，也就是说它能访问到其外层定义的变量。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>执行前类型判断</span><br><span class="line"></span><br><span class="line">在执行回调函数前最好确认其是一个函数。</span><br></pre></td></tr></table></figure><h3 id="回调函数this问题"><a href="#回调函数this问题" class="headerlink" title="回调函数this问题"></a>回调函数this问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于回调函数<span class="variable language_">this</span>，回调函数调用时<span class="variable language_">this</span>的执行上下文并不是回调函数定义时的那个上下文，而是调用它的函数所在的上下文，即定义这个函数所在的上下文，如果函数在外面单独定义，那么<span class="variable language_">this</span>很可能就是<span class="title class_">Window</span>,<span class="variable language_">this</span>指向是离它最近的或者嵌套级别的 <span class="keyword">function</span>/方法的调用者，</span><br><span class="line"></span><br><span class="line">解决方法<span class="number">1</span>：使用箭头函数在里面进行定义</span><br><span class="line">回调函数（若回调函数是普通函数时）当参数传入另外的函数时，若不知道这个函数内部怎么调用回调函数，就会出现回调函数中的<span class="variable language_">this</span>指向不明确的问题。所以 把箭头函数当回调函数，然后作为参数传入另外的函数中就不会出现<span class="variable language_">this</span>指向不明的问题。</span><br><span class="line"><span class="attr">eg</span>: <span class="keyword">function</span> <span class="title function_">createData</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> obj =&#123;</span><br><span class="line">            <span class="attr">data</span>:<span class="number">100</span>,</span><br><span class="line">            <span class="attr">tool</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">createData</span>(<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">data</span> = n;</span><br><span class="line">                &#125;)   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj.<span class="title function_">tool</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">data</span>);</span><br><span class="line">解决方法二：可以使用call和apply来进行重新定向</span><br><span class="line">解决方法三：在运用正确的<span class="variable language_">this</span>前，可以将正确的<span class="variable language_">this</span>声明成为一个变量从而进行使用</span><br></pre></td></tr></table></figure><h3 id="回调函数传参问题"><a href="#回调函数传参问题" class="headerlink" title="回调函数传参问题"></a>回调函数传参问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">将回调函数的参数作为与回调函数同等级的参数进行传递</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2Vi5YmN56uv5a6a5YGa,size_20,color_FFFFFF,t_70,g_se,x_16-cf06ae.png" alt="在这里插入图片描述"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">回调函数的参数在调用回调函数内部创建</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2Vi5YmN56uv5a6a5YGa,size_20,color_FFFFFF,t_70,g_se,x_16-16822285726932-7bdd95.png" alt="在这里插入图片描述"></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">宏任务：<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>、<span class="title class_">Ajax</span>、I/O、<span class="variable constant_">UI</span>交互事件(比如<span class="variable constant_">DOM</span>事件)</span><br><span class="line"></span><br><span class="line">微任务：<span class="title class_">Promise</span>回调、<span class="keyword">async</span>/<span class="keyword">await</span>、process.<span class="title function_">nextTick</span>(<span class="title class_">Node</span>独有，注册函数的优先级比<span class="title class_">Promise</span>回调函数要高)、<span class="title class_">MutaionObserver</span></span><br><span class="line"></span><br><span class="line">微任务执行时机比宏任务要早（记住）</span><br><span class="line"></span><br><span class="line">注意：script全部代码、(这个是执行栈的代码，属于同步代码)，包括<span class="keyword">new</span> <span class="title class_">Promise</span>（<span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;）里面的代码，只有then、<span class="keyword">catch</span>回调才是微任务</span><br></pre></td></tr></table></figure><h2 id="promise规则"><a href="#promise规则" class="headerlink" title="promise规则"></a>promise规则</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）</span><br><span class="line"></span><br><span class="line">一旦状态改变，就不会再变，任何时候都可以得到这个结果</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">其中resolve函数是将pending状态变为resolve即未完成到成功，异步操作成功时调用，并且将异步操作结果作为参数传递进去；reject函数是将<span class="title class_">Promise</span>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line"></span><br><span class="line">可以用.<span class="property">then</span>方法分别定义两个函数，都可选，不一定必须</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">    resolve函数</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">    reject函数</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="then方法"><a href="#then方法" class="headerlink" title=".then方法"></a>.then方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于then方法，上面讲过里面可以传递两种参数，但是一般只传一种参数，resolve参数</span><br><span class="line"></span><br><span class="line">then方法返回的是一个新的<span class="title class_">Promise</span>实例（注意，不是原来那个<span class="title class_">Promise</span>实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</span><br></pre></td></tr></table></figure><h3 id="catch方法"><a href="#catch方法" class="headerlink" title=".catch方法"></a>.catch方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">catch</span>()方法是.<span class="title function_">then</span>(<span class="literal">null</span>, rejection)或.<span class="title function_">then</span>(<span class="literal">undefined</span>, rejection)的别名，用于指定发生错误时的回调函数。</span><br><span class="line"></span><br><span class="line">对于下面的例子来讲，getJSON返回一个promise对象，如果运行完成状态为resolve那么运行.<span class="property">then</span>里面的回调函数，如果发生错误，那么会使用.<span class="property">catch</span>里面的函数，如果.<span class="property">then</span>里面发生错误，也可以被<span class="keyword">catch</span>捕捉</span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一般不会在.<span class="property">then</span>里面定义reject函数，都用<span class="keyword">catch</span>捕捉</span><br></pre></td></tr></table></figure><h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">看名字就可以发现，他是一个最终执行的函数，不管promise最后的状态，在执行完then或<span class="keyword">catch</span>指定的回调函数以后，都会执行<span class="keyword">finally</span>方法指定的回调函数。</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>函数不接受任何参数</span><br></pre></td></tr></table></figure><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>()方法用于将多个 <span class="title class_">Promise</span> 实例，包装成一个新的 <span class="title class_">Promise</span> 实例。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">接受一个数组作为参数，p1、p2、p3都是 <span class="title class_">Promise</span> 实例，如果不是，就会先调用下面讲到的<span class="title class_">Promise</span>.<span class="property">resolve</span>方法，将参数转为 <span class="title class_">Promise</span> 实例，再进一步处理。另外，<span class="title class_">Promise</span>.<span class="title function_">all</span>()方法的参数可以不是数组，但必须具有 <span class="title class_">Iterator</span> 接口，且返回的每个成员都是 <span class="title class_">Promise</span> 实例。</span><br><span class="line"></span><br><span class="line">p的状态由p1、p2、p3决定，分成两种情况。</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果作为参数的promise对象报错而且他自己有<span class="keyword">catch</span>方法，那么不会调用all.<span class="property">catch</span>的方法</span><br><span class="line">如果没有自己的<span class="keyword">catch</span>方法，那么就会调用<span class="title class_">Promise</span>.<span class="title function_">all</span>()的<span class="keyword">catch</span>方法。</span><br></pre></td></tr></table></figure><h3 id="race函数"><a href="#race函数" class="headerlink" title="race函数"></a>race函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 <span class="title class_">Promise</span> 实例的返回值，就传递给p的回调函数。</span><br></pre></td></tr></table></figure><h3 id="allsettled"><a href="#allsettled" class="headerlink" title="allsettled"></a>allsettled</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>()方法接受一个数组作为参数，数组的每个成员都是一个 <span class="title class_">Promise</span> 对象，并返回一个新的 <span class="title class_">Promise</span> 对象。只有等到参数数组的所有 <span class="title class_">Promise</span> 对象都发生状态变更（不管是fulfilled还是rejected），返回的 <span class="title class_">Promise</span> 对象才会发生状态变更。</span><br><span class="line"></span><br><span class="line">该方法返回的新的 <span class="title class_">Promise</span> 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 <span class="title class_">Promise</span> 对象。</span><br><span class="line"></span><br><span class="line">返回的数组值固定下面这种格式</span><br><span class="line"><span class="comment">// 异步操作成功时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作失败时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason&#125;</span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/blog&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;blog&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/docs&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;  <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用</span><br></pre></td></tr></table></figure><h4 id="参数形式"><a href="#参数形式" class="headerlink" title="参数形式"></a>参数形式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）参数是一个 <span class="title class_">Promise</span> 实例</span><br><span class="line">如果参数是 <span class="title class_">Promise</span> 实例，那么<span class="title class_">Promise</span>.<span class="property">resolve</span>将不做任何修改、原封不动地返回这个实例。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）参数是一个thenable对象</span><br><span class="line">thenable对象指的是具有then方法的对象，比如下面这个对象。</span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()方法会将这个对象转为 <span class="title class_">Promise</span> 对象，然后就立即执行thenable对象的<span class="title function_">then</span>()方法。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）参数不是具有<span class="title function_">then</span>()方法的对象，或根本就不是对象</span><br><span class="line">如果参数是一个原始值，或者是一个不具有<span class="title function_">then</span>()方法的对象，则<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()方法返回一个新的 <span class="title class_">Promise</span> 对象，状态为resolved</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）不带有任何参数</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()方法允许调用时不带参数，直接返回一个resolved状态的 <span class="title class_">Promise</span> 对象。</span><br></pre></td></tr></table></figure><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(reason)方法也会返回一个新的 <span class="title class_">Promise</span> 实例，该实例的状态为rejected。</span><br></pre></td></tr></table></figure><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于promise里面的函数来说，是同步栈函数，直接会运行，只有resolve和reject两个函数是异步函数</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于promise函数来说，如果里面发生错误，但是没有使用<span class="keyword">catch</span>方法指定错误的回调函数，那么这个错误不会传递到外层，即外层代码会继续执行，只不过promise会发生错误</span><br></pre></td></tr></table></figure><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">Generator</span>函数，首先可以把他理解成<span class="title class_">Generator</span>函数是一个状态机，封装了多个内部状态，执行<span class="title class_">Generator</span>函数，会返回一个可遍历对象，可以依次遍历<span class="title class_">Generator</span>里面的每一个状态</span><br><span class="line"><span class="title class_">Generator</span>函数有两个特征：</span><br><span class="line">一是，<span class="keyword">function</span>关键字与函数名之间有一个星号；</span><br><span class="line">二是，函数体内部使用<span class="keyword">yield</span>表达式，定义不同的内部状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用 <span class="title class_">Generator</span> 函数，返回一个遍历器对象，代表 <span class="title class_">Generator</span> 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是<span class="keyword">yield</span>表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</span><br></pre></td></tr></table></figure><h3 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>表达式相当于<span class="title class_">Generator</span>里面的暂停标志</span><br><span class="line">遍历器对象的next方法的运行逻辑如下。</span><br><span class="line">（<span class="number">1</span>）遇到<span class="keyword">yield</span>表达式，就暂停执行后面的操作，并将紧跟在<span class="keyword">yield</span>后面的那个表达式的值，作为返回的对象的value属性值。</span><br><span class="line">（<span class="number">2</span>）下一次调用next方法时，再继续往下执行，直到遇到下一个<span class="keyword">yield</span>表达式。</span><br><span class="line">（<span class="number">3</span>）如果没有再遇到新的<span class="keyword">yield</span>表达式，就一直运行到函数结束，直到<span class="keyword">return</span>语句为止，并将<span class="keyword">return</span>语句后面的表达式的值，作为返回的对象的value属性值。</span><br><span class="line">（<span class="number">4</span>）如果该函数没有<span class="keyword">return</span>语句，则返回的对象的value属性值为<span class="literal">undefined</span>。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>表达式如果用在另一个表达式之中，必须放在圆括号里面。</span><br><span class="line"><span class="attr">eg</span>:<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">               </span><br></pre></td></tr></table></figure><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>表达式本身没有返回值，或者说总是返回<span class="literal">undefined</span>。next方法可以带一个参数，该参数就会被当作上一个<span class="keyword">yield</span>表达式的返回值。</span><br></pre></td></tr></table></figure><h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">注意，由于next方法的参数表示上一个<span class="keyword">yield</span>表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</span><br></pre></td></tr></table></figure><h3 id="next和yield参数区别"><a href="#next和yield参数区别" class="headerlink" title="next和yield参数区别"></a>next和yield参数区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="keyword">yield</span>后面语句执行之后，会返回给next语句，next语句进行接收那么就可以接收到所运行的值</span><br><span class="line"></span><br><span class="line">对于next参数，会返回给<span class="keyword">yield</span>左侧的值，<span class="attr">eg</span>: <span class="keyword">let</span> x = <span class="keyword">yield</span> m;<span class="keyword">let</span> temp =  <span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line">对于这两个，x的值会是<span class="number">3</span>,temp的值为&#123; <span class="attr">value</span>: m, <span class="attr">done</span>: <span class="literal">false</span> &#125; 第一个参数是值，第二个参数是显示他是否运行结束</span><br></pre></td></tr></table></figure><h3 id="用for-of遍历"><a href="#用for-of遍历" class="headerlink" title="用for of遍历"></a>用for of遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>...<span class="keyword">of</span>循环可以自动遍历 <span class="title class_">Generator</span> 函数运行时生成的<span class="title class_">Iterator</span>对象，且此时不再需要调用next方法。</span><br><span class="line">一旦next方法的返回对象的done属性为<span class="literal">true</span>，<span class="keyword">for</span>...<span class="keyword">of</span>循环就会中止，且不包含该返回对象</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">所以上面的函数不会返回<span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="throw函数"><a href="#throw函数" class="headerlink" title="throw函数"></a>throw函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Generator</span>函数返回的遍历器对象，都有一个<span class="keyword">throw</span>方法，可以在函数体外抛出错误，然后在<span class="title class_">Generator</span>函数体内捕获。</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br><span class="line">对于上面的例子，第一个<span class="keyword">throw</span>后在内部被捕捉，但是第二个会被外部捕捉</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span>方法被捕获以后，会附带执行下一条<span class="keyword">yield</span>表达式。也就是说，会附带执行一次next方法。</span><br><span class="line"></span><br><span class="line">Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<span class="keyword">catch</span>捕获。</span><br><span class="line"></span><br><span class="line">一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于<span class="literal">true</span>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</span><br></pre></td></tr></table></figure><h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于混淆遍历器对象的<span class="keyword">throw</span>方法和全局的<span class="keyword">throw</span>命令。</span><br><span class="line">遍历器对象的<span class="keyword">throw</span>方法，可以由函数内部捕捉</span><br><span class="line">全局的<span class="keyword">throw</span>命令只能被函数体外的<span class="keyword">catch</span>语句捕获。</span><br></pre></td></tr></table></figure><h3 id="return函数"><a href="#return函数" class="headerlink" title="return函数"></a>return函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Generator</span> 函数返回的遍历器对象，还有一个<span class="keyword">return</span>()方法，可以返回给定的值，并且终结遍历 <span class="title class_">Generator</span> 函数。</span><br><span class="line"></span><br><span class="line">如果 <span class="title class_">Generator</span> 函数内部有<span class="keyword">try</span>...<span class="keyword">finally</span>代码块，且正在执行<span class="keyword">try</span>代码块，那么<span class="keyword">return</span>()方法会导致立刻进入<span class="keyword">finally</span>代码块，执行完以后，整个函数才会结束。</span><br></pre></td></tr></table></figure><h3 id="next-throw-return"><a href="#next-throw-return" class="headerlink" title="next() throw() return()"></a>next() throw() return()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">next</span>()是将<span class="keyword">yield</span>表达式替换成一个值。</span><br><span class="line"><span class="keyword">throw</span>()是将<span class="keyword">yield</span>表达式替换成一个<span class="keyword">throw</span>语句。</span><br><span class="line"><span class="keyword">return</span>()是将<span class="keyword">yield</span>表达式替换成一个<span class="keyword">return</span>语句。</span><br></pre></td></tr></table></figure><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a>yield*表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">用来在一个 <span class="title class_">Generator</span> 函数里面执行另一个 <span class="title class_">Generator</span> 函数。</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一句话，它就是 <span class="title class_">Generator</span> 函数的语法糖。</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>函数返回的是 <span class="title class_">Promise</span> 对象</span><br><span class="line"><span class="keyword">await</span>相当于yeild 当遇到<span class="keyword">await</span>后，会把后面的运行完成后自动暂停开一个异步线程进行运行</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>函数返回的 <span class="title class_">Promise</span> 对象，必须等到内部所有<span class="keyword">await</span>命令后面的 <span class="title class_">Promise</span> 对象执行完，才会发生状态改变，除非遇到<span class="keyword">return</span>语句或者抛出错误。也就是说，只有<span class="keyword">async</span>函数内部的异步操作执行完，才会执行then方法指定的回调函数。</span><br><span class="line">必须执行完成，如果没有返回一个可以用的值，那么函数到这里就停止</span><br></pre></td></tr></table></figure><h1 id="DOM语法"><a href="#DOM语法" class="headerlink" title="DOM语法"></a>DOM语法</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502145707321-c9495d.png" alt="image-20230502145707321"></p><h2 id="查找html元素"><a href="#查找html元素" class="headerlink" title="查找html元素"></a>查找html元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">通过 id 找到 <span class="variable constant_">HTML</span> 元素 <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">通过标签名找到 <span class="variable constant_">HTML</span> 元素 .<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;TagName&quot;</span>);</span><br><span class="line">通过类名找到 <span class="variable constant_">HTML</span> 元素 <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;calssName&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="改变HTML"><a href="#改变HTML" class="headerlink" title="改变HTML"></a>改变HTML</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">改变<span class="variable constant_">HTML</span>的输入流：<span class="variable language_">document</span>.<span class="title function_">write</span>();  向html里面输入数据，注意不可以在文档加载完成后输入，这样会覆盖内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改变<span class="variable constant_">HTML</span>文档内容：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">innerHTML</span>=新的 <span class="variable constant_">HTML</span> 会识别html标签和里面的空格换行会去掉</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">innerText</span>=text  不识别html标签，里面空格和换行也不会去掉</span><br><span class="line"></span><br><span class="line">改变<span class="variable constant_">HTML</span>属性：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">attribute</span>=新属性值</span><br><span class="line">attribute此处为属性，不是样式<span class="attr">eg</span>:如果要将一个P标签的字体颜色改成红色应该这样写：</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>).<span class="property">style</span> = <span class="string">&quot;color:red&quot;</span>;</span><br><span class="line">或者<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>).<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;#bfa&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="改变CSS"><a href="#改变CSS" class="headerlink" title="改变CSS"></a>改变CSS</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">改变样式：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">style</span>.<span class="property">property</span>=新样式</span><br><span class="line">产生的是行内样式，权重占比高</span><br><span class="line"><span class="attr">eg</span>:<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>).<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="DOM事件响应"><a href="#DOM事件响应" class="headerlink" title="DOM事件响应"></a>DOM事件响应</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">当用户点击鼠标时</span><br><span class="line">当网页已加载时</span><br><span class="line">当图像已加载时</span><br><span class="line">当鼠标移动到元素上时</span><br><span class="line">当输入字段被改变时</span><br><span class="line">当提交 <span class="variable constant_">HTML</span> 表单时</span><br><span class="line">当用户触发按键时</span><br><span class="line"></span><br><span class="line">onclick=<span class="title class_">JavaScript</span></span><br><span class="line">用dom来分配事件</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>).<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">displayDate</span>()&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onload 和 onunload 事件会在用户进入或离开页面时被触发。</span><br><span class="line">onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</span><br><span class="line">onload 和 onunload 事件可用于处理 cookie。</span><br><span class="line"></span><br><span class="line">onchange 事件常结合对输入字段的验证来使用。</span><br><span class="line">onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 <span class="variable constant_">HTML</span> 元素上方或移出元素时触发函数。</span><br><span class="line"></span><br><span class="line">onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</span><br><span class="line"></span><br><span class="line">onfocus  获得焦点时候进行事件</span><br></pre></td></tr></table></figure><h2 id="DOM事件对象的属性"><a href="#DOM事件对象的属性" class="headerlink" title="DOM事件对象的属性"></a>DOM事件对象的属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于每个操作，都是对对象的操作，事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。比如  </span><br><span class="line">谁绑定了这个事件</span><br><span class="line">鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置</span><br><span class="line">键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</span><br><span class="line"></span><br><span class="line">这个 event  是个形参，系统帮我们设定为事件对象，不需要传递实参过去。</span><br><span class="line">当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。</span><br><span class="line"></span><br><span class="line">相当于每一个操作其实函数都有一个默认参数event参数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502162221693-bb3caa.png" alt="image-20230502162221693"></p><h2 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 MouseEvent和键盘事件对象 KeyboardEvent。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502162311744-e3960e.png" alt="image-20230502162311744"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502162433971-a26d12.png" alt="image-20230502162433971"></p><h2 id="DOM-EventListener"><a href="#DOM-EventListener" class="headerlink" title="DOM EventListener()"></a>DOM EventListener()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>() 方法用于向指定元素添加事件句柄。</span><br><span class="line"><span class="title function_">addEventListener</span>() 方法添加的事件句柄不会覆盖已存在的事件句柄。</span><br><span class="line">你可以向一个元素添加多个事件句柄。</span><br><span class="line">你可以向同个元素添加多个同类型的事件句柄，如：两个 <span class="string">&quot;click&quot;</span> 事件，不会覆盖以前的事件</span><br><span class="line">你可以向任何 <span class="variable constant_">DOM</span> 对象添加事件监听，不仅仅是 <span class="variable constant_">HTML</span> 元素。如： <span class="variable language_">window</span> 对象。</span><br><span class="line"><span class="title function_">addEventListener</span>() 方法可以更简单的控制事件（冒泡与捕获）。</span><br><span class="line">对于参数传递的时候，可以使用匿名函数调用参数</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="title function_">myFunction</span>(p1, p2); &#125;);</span><br><span class="line"></span><br><span class="line">element.<span class="title function_">addEventListener</span>(event, <span class="keyword">function</span>, useCapture);</span><br><span class="line">第一个参数是事件的类型 (如 <span class="string">&quot;click&quot;</span> 或 <span class="string">&quot;mousedown&quot;</span>).注意不带on前缀</span><br><span class="line">第二个参数是事件触发后调用的函数。</span><br><span class="line">第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</span><br><span class="line"></span><br><span class="line">对于第三个参数来讲，事件传递有两种方式：冒泡与捕获。</span><br><span class="line">事件传递定义了元素事件触发的顺序。 如果你将 &lt;p&gt; 元素插入到 &lt;div&gt; 元素中，用户点击 &lt;p&gt; 元素, 哪个元素的 <span class="string">&quot;click&quot;</span> 事件先被触发呢？</span><br><span class="line">在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： &lt;p&gt; 元素的点击事件先触发，然后会触发 &lt;div&gt; 元素的点击事件。</span><br><span class="line">在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： &lt;div&gt; 元素的点击事件先触发 ，然后再触发 &lt;p&gt; 元素的点击事件。</span><br><span class="line"></span><br><span class="line">默认值为 <span class="literal">false</span>, 即冒泡传递，当值为 <span class="literal">true</span> 时, 事件使用捕获传递。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeEventListener</span>() 方法用来移除add方法添加的事件</span><br></pre></td></tr></table></figure><h2 id="事件委派原理"><a href="#事件委派原理" class="headerlink" title="事件委派原理"></a>事件委派原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不在每个子节点单独设置事件监听器，设置在其父节点上，然后利用冒泡原理影响设置每个子节点</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手4&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点</span><br><span class="line">  var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">  ul.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">    // alert(&#x27;知否知否，点我应有弹框在手！&#x27;);</span><br><span class="line">    // e.target 这个可以得到我们点击的对象</span><br><span class="line">    e.target.style.backgroundColor = &#x27;pink&#x27;;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">如上面的例子，要点击每一个li让他有一些操作，通常的做法是对每一个li设置方法，显然很麻烦，我们可以通过对ul设置方法，然后作用到li上</span><br></pre></td></tr></table></figure><h2 id="阻止默认事件执行"><a href="#阻止默认事件执行" class="headerlink" title="阻止默认事件执行"></a>阻止默认事件执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一个链接，你点击之后不希望跳转怎么实现呢？</span><br><span class="line">可以阻止默认事件发生</span><br><span class="line">  e.preventDefault();这个方法就可以阻止默认事件发生，具体看下面例子</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">禁止鼠标右键菜单</span><br><span class="line">contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</span><br><span class="line">document.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">禁止鼠标选中（selectstart开始选中）</span><br><span class="line">document.addEventListener(&#x27;selectstart&#x27;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="DOM元素（节点）操作"><a href="#DOM元素（节点）操作" class="headerlink" title="DOM元素（节点）操作"></a>DOM元素（节点）操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般地，节点至少拥有nodeType节点类型、nodeName节点名称和nodeValue节点值三个基本属性</span><br><span class="line">元素节点 nodeType 为 1</span><br><span class="line">属性节点 nodeType 为 2</span><br><span class="line">文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">appendChild</span>()在一个元素后排追加一个元素</span><br><span class="line"><span class="keyword">var</span> para = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);创建一个元素</span><br><span class="line"><span class="keyword">var</span> node =<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;创建节点文本&quot;</span>);</span><br><span class="line">para.<span class="title function_">appendChild</span>(node);文本节点加入para里面</span><br><span class="line">可以用setAttribute对para进行其他操作eg：  para.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;color:red&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertBefore</span>()加在方法的前面</span><br><span class="line">移除一个元素，需要知道他的父元素parent.<span class="title function_">removeChild</span>(child);</span><br><span class="line">不用刻意寻找父元素，可以这样操作child.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(child);</span><br><span class="line"></span><br><span class="line"><span class="title function_">replaceChild</span>(newChild,oldChild)       替换指定结点的子结点</span><br></pre></td></tr></table></figure><h2 id="DOM集合"><a href="#DOM集合" class="headerlink" title="DOM集合"></a>DOM集合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HTMLCollection</span> 对象类似包含 <span class="variable constant_">HTML</span> 元素的一个数组。</span><br><span class="line">集合中的元素可以通过索引(以 <span class="number">0</span> 为起始位置)来访问。</span><br><span class="line"> length 属性定义了集合中元素的数量。</span><br><span class="line"> <span class="title function_">item</span>() -&gt;获取第几个  也可以[]获取</span><br><span class="line"> <span class="title function_">namedItem</span>() -&gt;根据id获取，如果id不存在再在名字里面寻找</span><br><span class="line"> 注意他只是一个类似数组的方法，但本质上不是数组，不可以使用数组其他函数</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">HTMLCollection</span> 是一个动态的属性，对dom树进行增添会即时改变集合里面的元素</span><br></pre></td></tr></table></figure><h2 id="HTMLCollection-与-NodeList-的区别"><a href="#HTMLCollection-与-NodeList-的区别" class="headerlink" title="HTMLCollection 与 NodeList 的区别"></a>HTMLCollection 与 NodeList 的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HTMLCollection</span> 是 <span class="variable constant_">HTML</span> 元素的集合。</span><br><span class="line"><span class="title class_">NodeList</span> 是一个文档节点的集合。</span><br><span class="line"><span class="title class_">NodeList</span> 与 <span class="title class_">HTMLCollection</span> 有很多类似的地方。</span><br><span class="line"><span class="title class_">NodeList</span> 与 <span class="title class_">HTMLCollection</span> 都与数组对象有点类似，可以使用索引 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, ...) 来获取元素。</span><br><span class="line"><span class="title class_">NodeList</span> 与 <span class="title class_">HTMLCollection</span> 都有 length 属性。</span><br><span class="line"><span class="title class_">HTMLCollection</span> 元素可以通过 name，id 或索引来获取。</span><br><span class="line"><span class="title class_">NodeList</span> 只能通过索引来获取。</span><br><span class="line">只有 <span class="title class_">NodeList</span> 对象有包含属性节点和文本节点。</span><br></pre></td></tr></table></figure><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>方法：</span><br><span class="line"><span class="title function_">getElementById</span>(id) 返回指定结点的引用</span><br><span class="line"><span class="title function_">getElementsByTagName</span>(name)  返回文档中所有匹配的元素的集合</span><br><span class="line"><span class="title function_">createElement</span>(name) 创建指定类型的新结点</span><br><span class="line"><span class="title function_">createTextNode</span>(text) 创建一个纯文本结点</span><br><span class="line"></span><br><span class="line">element方法：</span><br><span class="line"><span class="title function_">getAttribute</span>(id) 返回指定属性的值</span><br><span class="line"><span class="title function_">setAttribute</span>(id,value)  给属性赋值，注意是属性不是style样式，</span><br><span class="line"><span class="title function_">removeAttribute</span>(id)  移除指定属性和它的值</span><br><span class="line"><span class="title function_">getElementsByTagName</span>(name)  返回结点内所有匹配的元素的集合</span><br><span class="line"></span><br><span class="line">node方法：</span><br><span class="line"><span class="title function_">appendChild</span>(child) 给指定结点添加一个新的子结点</span><br><span class="line"><span class="title function_">removeChild</span>(child) 移除指定结点的子结点</span><br><span class="line"><span class="title function_">replaceChild</span>(newChild,oldChild)  替换指定结点的子结点</span><br><span class="line"><span class="title function_">insertBefore</span>(newChild,refChild) 在同一层级的结点前面插入新结点</span><br><span class="line"><span class="title function_">hasChildNodes</span>()   如果结点有子结点则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">node属性：</span><br><span class="line">nodeName  以字符串的格式存放结点的名称</span><br><span class="line">nodeType   以整型数据格式存放结点的类型</span><br><span class="line">nodeValue   以可用的格式存放结点的值</span><br><span class="line">parentNode  指向结点的父结点的引用</span><br><span class="line">childNodes  指向子结点的引用的集合</span><br><span class="line">firstChild  指向子结点结合中的第一个子结点的引用</span><br><span class="line">lastChild  指向子结点结合中的最后一个子结点的引用</span><br><span class="line">node.<span class="property">nextSibling</span>返回下一个兄弟节点，找不到则返回<span class="literal">null</span>，包含所有的节点</span><br><span class="line">node.<span class="property">previousSibling</span>返回上一个兄弟节点，找不到则返回<span class="literal">null</span>，包含所有的节点</span><br><span class="line">node.<span class="property">nextElementSibling</span>返回下一个兄弟元素节点，找不到则返回<span class="literal">null</span>，有兼容问题</span><br><span class="line">node.<span class="property">previousElementSibling</span>返回上一个兄弟元素节点，找不到则返回<span class="literal">null</span>，有兼容问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node.<span class="title function_">cloneNode</span>() 返回调用该方法的节点的一个副本，也成为克隆节点</span><br></pre></td></tr></table></figure><h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">JavaScript</span>对象的创建，可以新建一个object对象，然后给他添加属性和方法</span><br><span class="line">person=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">firstname</span>=<span class="string">&quot;John&quot;</span>;</span><br><span class="line">person.<span class="property">lastname</span>=<span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> 构造函数，会根据给定的参数创建对象，具体有以下情况：</span><br><span class="line">如果给定值是 <span class="literal">null</span> 或 <span class="literal">undefined</span>，将会创建并返回一个空对象。</span><br><span class="line">如果传进去的是一个基本类型的值，则会构造其包装类型的对象。</span><br><span class="line">如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址。</span><br><span class="line">当以非构造函数形式被调用时，<span class="title class_">Object</span> 的行为等同于 <span class="keyword">new</span> <span class="title class_">Object</span>()。</span><br><span class="line"></span><br><span class="line">可以使用构造函数去进行自我创建 </span><br><span class="line"><span class="attr">eg</span>:<span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">firstname,lastname,age,eyecolor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstname</span>=firstname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastname</span>=lastname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eyecolor</span>=eyecolor;</span><br><span class="line">&#125;</span><br><span class="line">但对于上面的例子来讲，</span><br><span class="line"><span class="keyword">var</span> myFather=<span class="keyword">new</span> <span class="title function_">person</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Doe&quot;</span>,<span class="number">50</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myMother=<span class="title function_">person</span>(<span class="string">&quot;Sally&quot;</span>,<span class="string">&quot;Rally&quot;</span>,<span class="number">48</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line"> 如果 <span class="keyword">new</span> 了函数内的 <span class="variable language_">this</span> 会指向当前这个 person 并且就算函数内部不 <span class="keyword">return</span> 也会返回一个对象。</span><br><span class="line"> 如果不 <span class="keyword">new</span> 的话函数内的 <span class="variable language_">this</span> 指向的是 <span class="variable language_">window</span>。第二个就指向<span class="title class_">Window</span> 如果调用<span class="title class_">Window</span>.<span class="property">firstname</span> 也会返回<span class="title class_">Sally</span></span><br></pre></td></tr></table></figure><h2 id="prototype-继承"><a href="#prototype-继承" class="headerlink" title="prototype 继承"></a>prototype 继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于以及构建好的类，在下面进行操作时，一般不可以对他的构造函数和方法进行更改，有的时候我们想要在所有已经存在的对象添加新的属性或方法。另外，有时候我们想要在对象的构造函数中添加属性或方法。</span><br><span class="line"></span><br><span class="line">如下面的例子：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last, age, eyecolor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = first;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastName</span> = last;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eyeColor</span> = eyecolor;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">nationality</span> = <span class="string">&quot;English&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">所有的 <span class="title class_">JavaScript</span> 对象都会从一个 prototype（原型对象）中继承属性和方法</span><br><span class="line">所以对于一个对象进行访问的时候，不仅仅访问自己，还访问他原型对象，直到找到一个名字匹配的属性或到达原型链的末尾</span><br></pre></td></tr></table></figure><h2 id="最好的创建方法"><a href="#最好的创建方法" class="headerlink" title="最好的创建方法"></a>最好的创建方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">套路：自定义构造函数, 属性在函数中初始化，方法添加到原型上</span><br><span class="line">适用场景：需要创建多个类型确定的对象</span><br><span class="line">放在原型上可以节省空间（只需要加载一遍方法）,放在原型上方法由于是公用的，所以只需要加载一遍就好了，但是由于属性是独一无二的，所以需要在加载的时候创建</span><br><span class="line"></span><br><span class="line"><span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于组合继承来讲，利用原型链实现对父类型对象的方法继承，利用<span class="variable language_">super</span>()借用父类型构建函数初始化相同属性</span><br><span class="line"><span class="comment">//构造父类构造器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类构造器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, price</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)  <span class="comment">// 为了得到属性，用call改变this指向</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span> <span class="comment">// 修正constructor属性，使其指向子类</span></span><br><span class="line"><span class="comment">//定义子类特有方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setPrice</span> = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">24</span>, <span class="number">15000</span>)</span><br><span class="line">s.<span class="title function_">setName</span>(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.<span class="title function_">setPrice</span>(<span class="number">16000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">name</span>, s.<span class="property">age</span>, s.<span class="property">price</span>)</span><br></pre></td></tr></table></figure><h1 id="Window-浏览器对象模型"><a href="#Window-浏览器对象模型" class="headerlink" title="Window - 浏览器对象模型"></a>Window - 浏览器对象模型</h1><p><strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel (BOM)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于所有浏览器都支持 window 对象。它表示浏览器窗口。</span><br><span class="line">所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</span><br><span class="line">全局变量是 window 对象的属性。</span><br><span class="line">全局函数是 window 对象的方法。</span><br><span class="line">甚至 HTML DOM 的 document 也是 window 对象的属性之一</span><br><span class="line">window.open() - 打开新窗口</span><br><span class="line">window.close() - 关闭当前窗口</span><br><span class="line">window.moveTo() - 移动当前窗口</span><br><span class="line">window.resizeTo() - 调整当前窗口的尺寸</span><br></pre></td></tr></table></figure><h1 id="函数（API）"><a href="#函数（API）" class="headerlink" title="函数（API）"></a>函数（API）</h1><h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">这个函数可以用来简单判断一个变量是否为整数，如果需要具体进行判断的话，则需要用到正则表达式</span><br><span class="line">使用方法-&gt;            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(flag))</span><br><span class="line"><span class="literal">false</span>- 表示是数字</span><br><span class="line"><span class="literal">true</span> - 表示不是数字</span><br><span class="line"></span><br><span class="line">值得注意的是</span><br><span class="line">最大值<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>，比最大值大就是无穷大<span class="title class_">Infinty</span></span><br><span class="line">最小值<span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>，比最小值小就是无穷大-<span class="title class_">Infinty</span></span><br></pre></td></tr></table></figure><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">这个函数可以用来判断一个变量的类型  返回的是一个字符串</span><br><span class="line">不能判断: <span class="literal">null</span>与object object与array </span><br><span class="line">使用方法-&gt;             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> flag)</span><br></pre></td></tr></table></figure><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">constructor 属性可以返回变量的构造函数</span><br><span class="line"><span class="attr">eg</span>:<span class="string">&quot;John&quot;</span>.<span class="property">constructor</span>                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).<span class="property">constructor</span>                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.<span class="property">constructor</span>                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="property">constructor</span>              <span class="comment">// 返回函数 Array()   &#123; [native code] &#125;</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;.<span class="property">constructor</span>  <span class="comment">// 返回函数 Object()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="property">constructor</span>             <span class="comment">// 返回函数 Date()    &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;.<span class="property">constructor</span>         <span class="comment">// 返回函数 Function()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将类似数组结构的元素转化为数组</span><br><span class="line">let arrayLike = &#123; length: 2, 0: &#x27;a&#x27;, 1: &#x27;b&#x27; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="setInterval-方法"><a href="#setInterval-方法" class="headerlink" title="setInterval() 方法"></a>setInterval() 方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">间隔指定的毫秒数不停地执行指定的代码</span><br><span class="line">window.setInterval(&quot;javascript function&quot;,milliseconds);</span><br><span class="line">setInterval() 第一个参数是函数（function）。</span><br><span class="line">第二个参数间隔的毫秒数</span><br><span class="line"></span><br><span class="line">clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。</span><br></pre></td></tr></table></figure><h2 id="setTimeout-方法"><a href="#setTimeout-方法" class="headerlink" title="setTimeout() 方法"></a>setTimeout() 方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.setTimeout(&quot;javascript function&quot;, milliseconds);</span><br><span class="line">setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 &quot;alert(&#x27;5 seconds!&#x27;)&quot;，或者对函数的调用，诸如 alertMsg。</span><br><span class="line">第二个参数指示从当前起多少毫秒后执行第一个参数</span><br><span class="line"></span><br><span class="line">clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。</span><br><span class="line">语法</span><br><span class="line">window.clearTimeout(timeoutVariable)</span><br></pre></td></tr></table></figure><h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它用于把Array的某些元素过滤掉，然后返回剩下的元素。</span><br><span class="line"></span><br><span class="line">和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</span><br><span class="line"></span><br><span class="line">Array.filter(function(currentValue, indedx, arr), thisValue)</span><br><span class="line">  其中，函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；</span><br><span class="line">  函数的第一个参数 currentValue 也为必须，代表当前元素的值。</span><br></pre></td></tr></table></figure><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="在线网站—好用"><a href="#在线网站—好用" class="headerlink" title="在线网站—好用"></a>在线网站—好用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hemin.cn/jq/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载和安装官网地址 https://jquery.com/</span><br><span class="line">版本</span><br><span class="line">各个版本的下载 https://code.jquery.com/</span><br><span class="line">1x ：兼容 IE 678 等低版本浏览器， 官网不再更新</span><br><span class="line">2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新</span><br><span class="line">3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</span><br><span class="line"></span><br><span class="line">选择development版本的即可，保存本地即可</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table><thead><tr><th>基本选择器</th><th>描述</th></tr></thead><tbody><tr><td><code>#id</code></td><td>根据给定的ID匹配一个元素</td></tr><tr><td><code>element</code></td><td>根据给定的元素名匹配所有元素</td></tr><tr><td><code>.class</code></td><td>根据给定的类匹配元素</td></tr><tr><td><code>*</code></td><td>匹配所有元素</td></tr><tr><td><code>selector1,selector2,selectorN</code></td><td>将每一个选择器匹配到的元素合并后一起返回层级选择器</td></tr></tbody></table><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><table><thead><tr><th>层级选择器</th><th>描述</th></tr></thead><tbody><tr><td><code>ancestor descendant</code></td><td>在给定的祖先元素下匹配所有的后代元素</td></tr><tr><td><code>parent &gt; child</code></td><td>在给定的父元素下匹配所有的子元素</td></tr><tr><td><code>prev + next</code></td><td>匹配所有紧接在 prev 元素后的 next 元素</td></tr><tr><td><code>prev ~ siblings</code></td><td>匹配 prev 元素之后的所有 siblings 元素</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里需要强调一下父类选择器和祖先选择器，对于祖先选择器来讲，选择他里面的所有后代里面符合的元素，包括孙类元素，但是父类选择器只选择到儿子层面就停止，不会向下延伸</span><br><span class="line"></span><br><span class="line">`prev + next`只会选择下一个元素</span><br><span class="line">`prev ~ siblings` 会选择后续所有的元素</span><br></pre></td></tr></table></figure><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><table><thead><tr><th>分类</th><th>过滤选择器</th><th>描述</th></tr></thead><tbody><tr><td>基本</td><td><code>:first</code></td><td>获取第一个元素</td></tr><tr><td></td><td><code>:last</code></td><td>获取最后一个元素</td></tr><tr><td></td><td><code>:eq(index)</code></td><td>匹配一个给定索引值的元素</td></tr><tr><td></td><td><code>:gt(index)</code></td><td>匹配所有大于给定索引值的元素</td></tr><tr><td></td><td><code>:lt(index)</code></td><td>匹配所有小于给定索引值的元素</td></tr><tr><td></td><td><code>:even</code></td><td>匹配所有索引值为偶数的元素，从 0 开始计数</td></tr><tr><td></td><td><code>:odd</code></td><td>匹配所有索引值为奇数的元素，从 0 开始计数</td></tr><tr><td></td><td><code>:not(selector)</code></td><td>去除所有与给定选择器匹配的元素</td></tr><tr><td>内容</td><td><code>:contains(text)</code></td><td>匹配包含给定文本的元素</td></tr><tr><td></td><td><code>:has(selector)</code></td><td>匹配含有选择器所匹配的元素的元素</td></tr><tr><td></td><td><code>:empty</code></td><td>匹配所有不包含子元素或者文本的空元素</td></tr><tr><td></td><td><code>:parent</code></td><td>匹配含有子元素或者文本的元素</td></tr><tr><td>可见性</td><td><code>:hidden</code></td><td>匹配所有不可见元素，或者type为hidden的元素</td></tr><tr><td></td><td><code>:visible</code></td><td>匹配所有的可见元素</td></tr><tr><td>属性</td><td><code>[attribute]</code></td><td>匹配包含给定属性的元素</td></tr><tr><td></td><td><code>[attribute=value]</code></td><td>匹配给定的属性是某个特定值的元素</td></tr><tr><td></td><td><code>[attribute!=value]</code></td><td>匹配所有不含有指定的属性，或者属性不等于特定值的元素</td></tr><tr><td></td><td><code>[attribute*=value]</code></td><td>匹配给定的属性是以包含某些值的元素</td></tr><tr><td></td><td><code>[selector1][selector2][selectorN]</code></td><td>复合属性选择器，需要同时满足多个条件时使用</td></tr></tbody></table><h3 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h3><table><thead><tr><th>表单选择器</th><th>描述</th></tr></thead><tbody><tr><td><code>:input</code></td><td>匹配所有 input, textarea, select 和 button 元素</td></tr><tr><td><code>:text</code></td><td>匹配所有的单行文本框</td></tr><tr><td><code>:password</code></td><td>匹配所有密码框</td></tr><tr><td><code>:radio</code></td><td>匹配所有单选按钮</td></tr><tr><td><code>:checkbox</code></td><td>匹配所有复选框</td></tr><tr><td><code>:submit</code></td><td>匹配所有提交按钮</td></tr><tr><td><code>:reset</code></td><td>匹配所有重置按钮</td></tr><tr><td><code>:button</code></td><td>匹配所有按钮</td></tr><tr><td><strong>表单对象属性</strong></td><td><strong>描述</strong></td></tr><tr><td><code>:enabled</code></td><td>匹配所有可用元素</td></tr><tr><td><code>:disabled</code></td><td>匹配所有不可用元素</td></tr><tr><td><code>:checked</code></td><td>匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</td></tr><tr><td><code>:selected</code></td><td>匹配所有选中的option元素</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意可以同时使用，例如选择文本中不可用元素可以这样：</span><br><span class="line"> $(&#x27;:text:disabled&#x27;)</span><br></pre></td></tr></table></figure><h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><table><thead><tr><th>过滤方法</th><th>描述</th></tr></thead><tbody><tr><td>eq()</td><td>获取第N个元素</td></tr><tr><td>first()</td><td>获取第一个元素</td></tr><tr><td>last()</td><td>获取最后一个元素</td></tr><tr><td>hasClass()</td><td>检查当前的元素是否含有某个特定的类，如果有，则返回true</td></tr><tr><td>filter()</td><td>筛选出与指定表达式匹配的元素集合</td></tr><tr><td>not()</td><td>删除与指定表达式匹配的元素</td></tr><tr><td>is()</td><td>根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true</td></tr><tr><td>has()</td><td>保留包含特定后代的元素，去掉那些不含有指定后代的元素</td></tr></tbody></table><table><thead><tr><th>查找方法</th><th>描述</th></tr></thead><tbody><tr><td>children()</td><td>取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合</td></tr><tr><td>find()</td><td>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法</td></tr><tr><td>siblings()</td><td>取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合</td></tr><tr><td>next()</td><td>取得一个包含匹配的元素集合中每一个元素紧邻的后一个同辈元素的元素集合</td></tr><tr><td>nextAll()</td><td>查找当前元素之后所有的同辈元素</td></tr><tr><td>nextUntil()</td><td>查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止</td></tr><tr><td>prev()</td><td>取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合</td></tr><tr><td>prevAll()</td><td>查找当前元素之前所有的同辈元素</td></tr><tr><td>prevUntil()</td><td>查找当前元素之前所有的同辈元素，直到遇到匹配的那个元素为止</td></tr><tr><td>offsetParent()</td><td>返回第一个匹配元素用于定位的父节点</td></tr><tr><td>parent()</td><td>取得一个包含着所有匹配元素的唯一父元素的元素集合</td></tr><tr><td>parentsUntil()</td><td>查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止</td></tr></tbody></table><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502205541014-9f093e.png" alt="image-20230502205541014"></p><h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量内部DOM元素（伪数组形式存储）的过程就叫做隐式迭代，相当于选中元素后，自动会给匹配到元素进行循环遍历，执行相应的方法，而不用我们自己去进行循环遍历</span><br></pre></td></tr></table></figure><h2 id="基本工具方法"><a href="#基本工具方法" class="headerlink" title="基本工具方法"></a>基本工具方法</h2><table><thead><tr><th>工具方法</th><th>描述</th></tr></thead><tbody><tr><td>$.each(object,[callback])</td><td>通用例遍方法，可用于例遍对象和数组,callback是一个函数</td></tr><tr><td>$.type(obj)</td><td>检测obj的数据类型</td></tr><tr><td>$.isArray(obj)</td><td>测试对象是否为数组</td></tr><tr><td>$.isFunction(obj)</td><td>测试对象是否为函数</td></tr><tr><td>$.isNumeric(value)</td><td>测试对象是否为数字</td></tr><tr><td>$.parseJSON(json)</td><td>接受一个JSON字符串，返回解析后的对象</td></tr><tr><td>$.trim(str)</td><td>去除str旁边空格</td></tr></tbody></table><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>attr(name,value)</td><td>设置或返回被选元素的属性值，如果只传入第一个参数，那么返回这个对象属性的值，如果两个参数都输入，那么对这个对象的属性值进行修改</td></tr><tr><td>removeAttr(name)</td><td>从每一个匹配的元素中删除一个属性,传入为属性名称</td></tr><tr><td>prop()</td><td>获取在匹配的元素集中的第一个元素的属性值</td></tr><tr><td>removeProp()</td><td>用来删除由.prop()方法设置的属性集</td></tr><tr><td>addClass(value)</td><td>为每个匹配的元素添加指定的类名</td></tr><tr><td>removeClass(value)</td><td>从所有匹配的元素中删除全部或者指定的类</td></tr><tr><td>toggleClass(value)</td><td>如果存在（不存在）就删除（添加）一个类，相当于获取一个元素，如果元素有value这个类，那么就删除这个类，如果不存在这个类，那么就把这个类加上</td></tr><tr><td>html(value)参数可选</td><td>取得第一个匹配元素的html内容，如果不传递参数，那么返回选中的元素里面的html内容，包括标签，如果传入参数，相当于把选中的元素里面的html内容替换为传递的参数</td></tr><tr><td>text()</td><td>取得所有匹配元素的内容</td></tr><tr><td>val(value)参数可选</td><td>获得匹配元素的当前值,不传递参数获取到value属性的值，传递参数进行替换</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于prop和attr的区别：</span><br><span class="line">对于自定义属性的操作，使用attr方法，</span><br><span class="line">对于固有属性两者看情况使用，固有属性是dom自带的属性，一般推荐使用prop，因为比较快</span><br><span class="line">对于属性值是Boolean的方法，使用prop方法</span><br></pre></td></tr></table></figure><h2 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h2><table><thead><tr><th>CSS</th><th>描述</th></tr></thead><tbody><tr><td>css()</td><td>访问匹配元素的样式属性，详细看下面例子</td></tr><tr><td>offset()</td><td>获取匹配元素在当前视口的相对偏移，获取完成后可以用top,left等方位具体查看</td></tr><tr><td>position()</td><td>获取匹配元素相对父元素的偏移，获取完成后可以用top,left等方位具体查看</td></tr><tr><td>scrollTop()</td><td>获取匹配元素相对滚动条顶部的偏移</td></tr><tr><td>scrollLeft()</td><td>获取匹配元素相对滚动条左侧的偏移</td></tr><tr><td>height()</td><td>取得匹配元素当前计算的高度值（px）height值</td></tr><tr><td>width()</td><td>取得第一个匹配元素当前计算的宽度值（px）width值</td></tr><tr><td>innerHeight()</td><td>获取第一个匹配元素内部区域高度（包括补白、不包括边框）height + padding</td></tr><tr><td>innerWidth()</td><td>获取第一个匹配元素内部区域宽度（包括补白、不包括边框）width + padding</td></tr><tr><td>outerHeight(false&#x2F;true)</td><td>获取第一个匹配元素外部高度（默认包括补白和边框）height + padding + border<code> 如果是</code>true<code>，加上</code>margin</td></tr><tr><td>outerWidth(false&#x2F;true)</td><td>获取第一个匹配元素外部宽度（默认包括补白和边框）width + padding + border<code> 如果是</code>true<code>，加上</code>margin</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">CSS</span>()函数来讲</span><br><span class="line">一般有三种用法：</span><br><span class="line">$(<span class="string">&#x27;ul&gt;li:first&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>) =&gt;返回这个样式的值</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;ul&gt;li:first&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>，<span class="string">&#x27;red&#x27;</span>)=&gt; 对样式进行修改</span><br><span class="line">$(<span class="string">&#x27;ul&gt;li:first&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span></span><br><span class="line"> &#125;)  =&gt;也是对样式进行修改，不过用大括号进行多样式修改</span><br></pre></td></tr></table></figure><h2 id="JS文档操作"><a href="#JS文档操作" class="headerlink" title="JS文档操作"></a>JS文档操作</h2><table><thead><tr><th>文档处理方法</th><th>描述</th></tr></thead><tbody><tr><td>内部插入</td><td></td></tr><tr><td>append()</td><td>向每个匹配的元素内部追加内容</td></tr><tr><td>appendTo()</td><td>把所有匹配的元素追加到另一个指定的元素元素集合中</td></tr><tr><td>prepend()</td><td>向每个匹配的元素内部前置内容</td></tr><tr><td>prependTo()</td><td>把所有匹配的元素前置到另一个、指定的元素元素集合中</td></tr><tr><td>外部插入</td><td></td></tr><tr><td>after()</td><td>在每个匹配的元素之后插入内容</td></tr><tr><td>before()</td><td>在每个匹配的元素之前插入内容</td></tr><tr><td>insertAfter()</td><td>把所有匹配的元素插入到另一个、指定的元素元素集合的后面</td></tr><tr><td>insertBefore()</td><td>把所有匹配的元素插入到另一个、指定的元素元素集合的前面</td></tr><tr><td>包裹</td><td></td></tr><tr><td>wrap()</td><td>把所有匹配的元素用其他元素的结构化标记包裹起来</td></tr><tr><td>unwrap()</td><td>这个方法将移出元素的父元素</td></tr><tr><td>wrapAll()</td><td>将所有匹配的元素用单个元素包裹起来</td></tr><tr><td>wrapInner()</td><td>将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来</td></tr><tr><td>替换</td><td></td></tr><tr><td>replaceWith()</td><td>将所有匹配的元素替换成指定的HTML或DOM元素</td></tr><tr><td>replaceAll()</td><td>用匹配的元素替换掉所有 selector匹配到的元素</td></tr><tr><td>删除</td><td></td></tr><tr><td>empty()</td><td>删除匹配的元素集合中所有的子节点</td></tr><tr><td>remove()</td><td>从DOM中删除所有匹配的元素</td></tr><tr><td>detach()</td><td>从DOM中删除所有匹配的元素</td></tr><tr><td>克隆</td><td></td></tr><tr><td>clone()</td><td>克隆匹配的DOM元素并且选中这些克隆的副本</td></tr></tbody></table><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.1&#x27;</span>).<span class="title function_">append</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line"> $(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">appendTo</span>($(<span class="string">&#x27;.2&#x27;</span>))</span><br><span class="line">一个是将内容插入到选中的元素中，一个是将选中的内容插入到后面集合中，</span><br><span class="line">注意是添加在原有集合的最后</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.1 span&#x27;</span>).<span class="title function_">prepend</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line"> $(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">prependTo</span>($(<span class="string">&#x27;.2 span&#x27;</span>))</span><br><span class="line">用法和上面方法类似，但是是插入到原有集合的前面</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.1&#x27;</span>).<span class="title function_">before</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line">$(<span class="string">&#x27;.1&#x27;</span>).<span class="title function_">after</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line">$(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">insertBefore</span>($(<span class="string">&#x27;.2&#x27;</span>))</span><br><span class="line">$(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">insertAfter</span>($(<span class="string">&#x27;.2&#x27;</span>))</span><br><span class="line">用法类似于上面的内部插入</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.1 span&#x27;</span>).<span class="title function_">replaceWith</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>)</span><br><span class="line"> $(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">replaceAll</span>($(<span class="string">&#x27;.2 span&#x27;</span>))</span><br><span class="line">对于替换来讲，方法和上面几种方法大差不大，但是也是要注意什么时候前面替换后面，什么时候后面替换前面</span><br></pre></td></tr></table></figure><h3 id="empty-remove-detach区别"><a href="#empty-remove-detach区别" class="headerlink" title="empty remove detach区别"></a>empty remove detach区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于empty，他只是清除选中的元素里面的子节点元素，本来的节点元素不进行处理，换句话讲，是将选中的节点元素里面赋值为空</span><br><span class="line">remove,删除元素，包括绑定的事件，附加数据</span><br><span class="line">detach 删除被选元素，包括所有文本和子节点。<span class="title function_">detach</span>() 会保留所有绑定的事件、附加的数据</span><br><span class="line"></span><br><span class="line">看下面的例子：</span><br><span class="line">   &lt;p&gt;区别&lt;/p&gt;</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="string">&quot;remove与detach的区别&quot;</span>) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=$(<span class="string">&quot;p&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">删除的p元素的jquery对象， 当重新将保留下来的p元素塞回到body中,当再点击p元素的时候并没有触发click事件，即事件已经被remove事件移除掉。</span><br><span class="line"><span class="keyword">var</span> a=$(<span class="string">&quot;p&quot;</span>).<span class="title function_">detach</span>()</span><br><span class="line">删除的p元素的jquery对象， 当重新将保留下来的p元素塞回到body中,当再点击p元素的时候触发click事件，即事件依然保留在元素上，detach事件并没有移除掉p元素的事件。</span><br><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).<span class="title function_">after</span>(a)</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><table><thead><tr><th>事件方法</th><th>描述</th></tr></thead><tbody><tr><td>页面载入</td><td></td></tr><tr><td>ready()</td><td>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数</td></tr><tr><td>事件处理</td><td></td></tr><tr><td>on()</td><td>在选择元素上绑定一个或多个事件的事件处理函数</td></tr><tr><td>off()</td><td>在选择元素上移除一个或多个事件的事件处理函数</td></tr><tr><td>bind()</td><td>为每个匹配元素的特定事件绑定事件处理函数</td></tr><tr><td>unbind()</td><td>bind()的反向操作，从每一个匹配的元素中删除绑定的事件</td></tr><tr><td>one()</td><td>为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数，这个事件只会触发一次</td></tr><tr><td>trigger()</td><td>在每一个匹配的元素上触发某类事件</td></tr><tr><td>triggerHandler()</td><td>这个特别的方法将会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认动作，也不会产生事件冒泡</td></tr><tr><td>事件委派</td><td></td></tr><tr><td>delegate()</td><td>指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数</td></tr><tr><td>undelegate()</td><td>删除由 delegate() 方法添加的一个或多个事件处理程序</td></tr><tr><td>事件切换</td><td></td></tr><tr><td>hover()</td><td>一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法</td></tr><tr><td>toggle()</td><td>用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件</td></tr><tr><td>事件</td><td></td></tr><tr><td>focus()、focusin()</td><td>当元素获得焦点时，触发 focus、focusin 事件</td></tr><tr><td>blur()、focusout()</td><td>当元素失去焦点时，触发 blur、focusout 事件</td></tr><tr><td>change()</td><td>当元素的值发生改变时，会发生 change 事件</td></tr><tr><td>click()</td><td>触发每一个匹配元素的click事件</td></tr><tr><td>dblclick()</td><td>当双击元素时，会发生 dblclick 事件</td></tr><tr><td>error()</td><td>当元素遇到错误（没有正确载入）时，发生 error 事件</td></tr><tr><td>mousedown()</td><td>当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件</td></tr><tr><td>mouseup()</td><td>当在元素上放松鼠标按钮时，会发生 mouseup 事件</td></tr><tr><td>mouseenter()</td><td>当鼠标指针穿过元素时，会发生 mouseenter 事件</td></tr><tr><td>mouseleave()</td><td>当鼠标指针离开元素时，会发生 mouseleave 事件</td></tr><tr><td>mouseover()</td><td>当鼠标指针位于元素上方时，会发生 mouseover 事件</td></tr><tr><td>mouseout()</td><td>当鼠标指针从元素上移开时，发生 mouseout 事件</td></tr><tr><td>mousemove()</td><td>当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件</td></tr><tr><td>keypress()</td><td>当键盘或按钮被按下时，发生 keypress 事件</td></tr><tr><td>keydown()</td><td>当键盘或按钮被按下时，发生 keydown 事件</td></tr><tr><td>keyup()</td><td>当按钮被松开时，发生 keyup 事件</td></tr><tr><td>resize()</td><td>当调整浏览器窗口的大小时，发生 resize 事件</td></tr><tr><td>scroll()</td><td>当用户滚动指定的元素时，会发生 scroll 事件</td></tr><tr><td>select()</td><td>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件</td></tr><tr><td>submit()</td><td>当提交表单时，会发生 submit 事件</td></tr><tr><td>unload()</td><td>在当用户离开页面时，会发生 unload 事件</td></tr></tbody></table><h3 id="on和bind的区别"><a href="#on和bind的区别" class="headerlink" title="on和bind的区别"></a>on和bind的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于on事件，有四个参数$(selector).on(event,childSelector,data,function)</span><br><span class="line">event必需。规定要从被选元素移除的一个或多个事件或命名空间。由空格分隔多个事件值，也可以是数组。必须是有效的事件。</span><br><span class="line">childSelector可选。规定只能添加到指定的子元素上的事件处理程序（且不是选择器本身，比如已废弃的 delegate() 方法）。</span><br><span class="line">data可选。规定传递到函数的额外数据。</span><br><span class="line">function可选。规定当事件发生时运行的函数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于bind事件 $(selector).bind(event,data,function,map)</span><br><span class="line">event必需。规定添加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。</span><br><span class="line">data可选。规定传递到函数的额外数据。</span><br><span class="line">function必需。规定当事件发生时运行的函数。</span><br><span class="line">map规定事件映射 (&#123;event:function, event:function, ...&#125;)，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于两者的区别在于：</span><br><span class="line">bind只能给符合条件的元素本身添加事件 </span><br><span class="line">on可以将子元素的事件委托给父元素进行处理,而且可以给动态添加的元素加上绑定事件</span><br><span class="line"></span><br><span class="line">举个简单的例子：比如下例:</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;第一个子元素&lt;li/&gt;</span><br><span class="line">    &lt;li&gt;第二个子元素&lt;li/&gt;</span><br><span class="line">    &lt;li&gt;第三个子元素&lt;li/&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">我们想给所有li添加click事件,可以用on:我们想给所有li添加click事件,可以用on:</span><br><span class="line"> $(&#x27;ul&#x27;).on(&#x27;click&#x27;,&#x27;li&#x27;, function () &#123;   </span><br><span class="line">        console.log($(this).text());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">也可以用bind:</span><br><span class="line"> $(&#x27;ul li&#x27;).bind(&#x27;click&#x27;, function () &#123; </span><br><span class="line">        console.log($(this).text());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">有什么区别呢?</span><br><span class="line">第一用on绑定实际上是委托给了父级ul,也就是只给 一个元素绑定了事件</span><br><span class="line">第二个是用选择器选择了ul下的所有li元素 依次绑定了事件</span><br><span class="line">假如有很多很多子元素区别就很大了, bind会严重影响性能!</span><br><span class="line"></span><br><span class="line">假如这时候新添一个li:</span><br><span class="line">$(&#x27;ul&#x27;).append(&#x27;&lt;li&gt;第四个子元素&lt;li&gt;&#x27;)；</span><br><span class="line">如果是on绑定则这个li也会有点击事件</span><br><span class="line">如果是bind则没有</span><br><span class="line"></span><br><span class="line">所以一般推荐使用on，on在对子元素的绑定中，类似事件委派的效果</span><br></pre></td></tr></table></figure><h3 id="mouseover-mouseout与mouseenter-mouseleave的区别"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别" class="headerlink" title="mouseover&#x2F;mouseout与mouseenter&#x2F;mouseleave的区别"></a><code>mouseover</code>&#x2F;<code>mouseout</code>与<code>mouseenter</code>&#x2F;<code>mouseleave</code>的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mouseover/mouseout进入和离开子元素会再次触发函数，相当于从父元素跨到子元素的阶段，会执行mouseout再接着执行mouseover函数，</span><br><span class="line">mouseenter/mouseleave进入和离开子元素不会再次触发</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><table><thead><tr><th>动画</th><th>描述</th></tr></thead><tbody><tr><td>基本</td><td></td></tr><tr><td>show()</td><td>显示隐藏的匹配元素</td></tr><tr><td>hide()</td><td>隐藏显示的元素</td></tr><tr><td>toggle()</td><td>用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件</td></tr><tr><td>滑动</td><td>无参数默认缓慢，有参数可以分为数字参数和文字参数</td></tr><tr><td>slideDown()</td><td>通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数</td></tr><tr><td>slideUp()</td><td>通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数</td></tr><tr><td>slideToggle()</td><td>通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数</td></tr><tr><td>淡入淡出</td><td></td></tr><tr><td>fadeIn()</td><td>通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数</td></tr><tr><td>fadeOut()</td><td>通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数</td></tr><tr><td>fadeTo()</td><td>把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数</td></tr><tr><td>fadeToggle()</td><td>通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数</td></tr><tr><td>自定义</td><td></td></tr><tr><td>animate()</td><td>用于创建自定义动画的函数</td></tr><tr><td>stop()</td><td>停止所有在指定元素上正在运行的动画</td></tr><tr><td>finish()</td><td>停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画</td></tr><tr><td>delay()</td><td>设置一个延时来推迟执行队列中之后的项目</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数([speed,[easing],[fn]])</span><br><span class="line">参数都可以省略， 无动画直接显示</span><br><span class="line">speed 三种预定速度之一的字符串（&#x27;slow&#x27;, &#x27;normal&#x27;, &#x27;fast&#x27;）或表示动画时长的毫秒数值（如：1000）</span><br><span class="line">easing (Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”</span><br><span class="line">fn 回调函数，在动画完成时执行的函数，每个元素执行一次</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hover([over,] out)</span><br><span class="line">over 鼠标移到元素上要触发的函数（相当于mouseenter）</span><br><span class="line">out 鼠标移出元素要触发的函数（相当于mouseleave）</span><br><span class="line">如果只写一个函数，则鼠标经过和离开都会触发它</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animate(params, [speed], [easing], [fn])</span><br><span class="line">params 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号， 如果是复合属性则需要采取驼峰命名法 borderLeft。其余参数都可以省略</span><br></pre></td></tr></table></figure><h2 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h2><h4 id="this使用"><a href="#this使用" class="headerlink" title="this使用"></a>this使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于jQuery来讲，进行遍历的时候，this变成了DOM对象，可以打印查看，如果要用Jquery里面方法，那么先要转化为jQuery对象来进行处理$(this)</span><br></pre></td></tr></table></figure><h2 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a><a href="https://so.csdn.net/so/search?q=jQuery&spm=1001.2101.3001.7020">jQuery</a>插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于 jQuery 编写的扩展库</span><br><span class="line">http://plugins.jquery.com/</span><br><span class="line">validation--验证库</span><br><span class="line">https://github.com/jquery-validation/jquery-validation/releases</span><br><span class="line">ui库</span><br><span class="line">http://jqueryui.com/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery 插件常用的网站</span><br><span class="line">jQuery 插件库 http://www.jq22.com/ 懒加载 </span><br><span class="line">jQuery 之家 http://www.htmleaf.com/</span><br><span class="line">jQuery 插件使用步骤</span><br><span class="line">引入相关文件（jQuery 文件 和 插件文件）    </span><br><span class="line">复制相关html、css、js (调用插件)</span><br><span class="line">jQuery 插件演示</span><br><span class="line"></span><br><span class="line">瀑布流</span><br><span class="line">图片懒加载（图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载）</span><br><span class="line">当我们页面滑动到可视区域，再显示图片。</span><br><span class="line">我们使用jquery插件库  EasyLazyload。</span><br><span class="line">注意，此时的js引入文件和js调用必须写到 DOM元素（图片）最后面</span><br><span class="line">EasyLazyload.js</span><br><span class="line">(3 KB)</span><br><span class="line">EasyLazyload.min.js</span><br><span class="line">(2 KB)</span><br><span class="line">全屏滚动（fullpage.js）</span><br><span class="line">gitHub https://github.com/alvarotrigo/fullPage.js</span><br><span class="line">中文翻译网站 http://www.dowebok.com/demo/2014/77/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bootstrap JS 插件</span><br><span class="line">bootstrap 框架也是依赖于 jQuery 开发的，因此里面的 js插件使用 ，也必须引入 jQuery 文件</span><br><span class="line">https://v3.bootcss.com/</span><br></pre></td></tr></table></figure><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">请求报文</span><br><span class="line">请求行</span><br><span class="line">请求类型：<span class="variable constant_">GET</span>/<span class="variable constant_">POST</span>/<span class="variable constant_">PUT</span>/<span class="variable constant_">DELETE</span>/<span class="variable constant_">PATCH</span></span><br><span class="line"><span class="variable constant_">URL</span> 路径：s?ie=utf-<span class="number">8</span></span><br><span class="line"><span class="variable constant_">HTTP</span> 协议版本：<span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line">请求头</span><br><span class="line"><span class="title class_">Host</span>: atguigu.<span class="property">com</span></span><br><span class="line"><span class="title class_">Cookie</span>: name=guigu</span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: chrome <span class="number">83</span></span><br><span class="line">…</span><br><span class="line">空行：固定格式，必须有</span><br><span class="line">请求体：<span class="variable constant_">GET</span>请求，请求体为空；<span class="variable constant_">POST</span>请求，请求体可以不为空</span><br><span class="line">username=admin&amp;password=admin</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">响应报文</span><br><span class="line">响应行</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span> 协议版本：<span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line">响应状态码：<span class="number">200</span>/<span class="number">404</span>/<span class="number">500</span></span><br><span class="line">响应状态字符串：<span class="variable constant_">OK</span>/<span class="title class_">Not</span> <span class="title class_">Found</span>/<span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span>，与响应状态码对应</span><br><span class="line">响应头</span><br><span class="line"></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">length</span>: <span class="number">2048</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">encoding</span>: gzip</span><br><span class="line">…</span><br><span class="line">空行：固定格式，必须有</span><br><span class="line"></span><br><span class="line">响应体，一般可以用json格式返回</span><br></pre></td></tr></table></figure><h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><table><thead><tr><th></th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client error(客户端错误)</td><td>客户端请求出错</td></tr><tr><td>5xx</td><td>Server Error(服务器错误)</td><td>服务器处理请求出错</td></tr></tbody></table><table><thead><tr><th>状态码</th><th>状态字符串</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>302</td><td>Found</td><td>请求资源的 URL 被暂时修改到 Location 提供的 URL</td></tr><tr><td>304</td><td>Not Modified</td><td>资源未变更</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>永久重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>请求语法有问题，服务器无法识别</td></tr><tr><td>401</td><td>UnAuthorized</td><td>客户端未授权该请求</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器拒绝响应</td></tr><tr><td>404</td><td>Not Found</td><td>URL 无效或者 URL 有效但是没有资源</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误</td></tr><tr><td>502</td><td>Bad Gateway</td><td>服务器作为网关使用时，收到上游服务器返回的无效响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>无法服务。一般发生在因维护而停机或者服务过载</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr><tr><td>505</td><td>Http Version Not Supported</td><td>发出的请求http版本服务器不支持</td></tr></tbody></table><h2 id="AJAX发生get请求"><a href="#AJAX发生get请求" class="headerlink" title="AJAX发生get请求"></a>AJAX发生get请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、创建对象</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="number">2</span>、初始化</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//127.0.0.1:8080/demo?a=100&amp;b=200&amp;c=300当然也可以像这样传递数据，后端springboot要用@RequestParam注解去进行接收注入</span></span><br><span class="line"><span class="number">3</span>、发送</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="number">4</span>、事件绑定，处理服务器端返回的结果</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">对于xhr的一些参数</span><br><span class="line">readeyState</span><br><span class="line"><span class="number">0</span>：未初始化</span><br><span class="line"><span class="number">1</span>：open 方法调用完毕</span><br><span class="line"><span class="number">2</span>：send 方法调用完毕</span><br><span class="line"><span class="number">3</span>：服务端返回部分结果</span><br><span class="line"><span class="number">4</span>：服务端返回所有结果</span><br><span class="line"></span><br><span class="line">status：状态码</span><br><span class="line"></span><br><span class="line">statusText：状态字符串</span><br><span class="line"></span><br><span class="line"><span class="title function_">getAllResponseHeaders</span>()：响应头</span><br><span class="line"></span><br><span class="line">response：响应体</span><br></pre></td></tr></table></figure><h2 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、创建对象</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="number">2</span>、初始化</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8080/demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、发送</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="number">4</span>、事件绑定，处理服务器端返回的结果</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">如果要发送数据向后端，用@<span class="title class_">RequestBody</span>接收的话，那么就需要进行下面修改</span><br><span class="line"> xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"><span class="comment">//修改传递参数格式，因为后端接收为JSON格式，所以前段得修改为JSON格式才可以</span></span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            <span class="string">&quot;account&quot;</span>: <span class="string">&quot;22222222222220&quot;</span>,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//JSON对象转化为字符串传递，当然也可以简单传递，a=100&amp;b=200&amp;c=300这样，但是一般推荐下面的方法</span></span><br><span class="line"> xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用jQuery发送"><a href="#用jQuery发送" class="headerlink" title="用jQuery发送"></a>用jQuery发送</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="comment">// 请求地址</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8080/demo&#x27;</span>,</span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;),</span><br><span class="line">    <span class="comment">// 请求类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">contentType</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="comment">// 响应体类型-----------不推荐</span></span><br><span class="line">    <span class="comment">// dataType: &#x27;json&#x27;,</span></span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">        <span class="comment">// console.log(typeof data, data); // string &#123;name: &quot;Hello jquery&quot;&#125;  开启dataType后：object &#123;name: &quot;Hello jquery&quot;&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="attr">error</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// // 头信息</span></span><br><span class="line">    <span class="comment">// headers: &#123;</span></span><br><span class="line">    <span class="comment">//     c: 300,</span></span><br><span class="line">    <span class="comment">//     d: 400</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="JSONP解决跨域问题—感觉没用-没看"><a href="#JSONP解决跨域问题—感觉没用-没看" class="headerlink" title="JSONP解决跨域问题—感觉没用 没看"></a>JSONP解决跨域问题—感觉没用 没看</h2><h1 id="layui-的layer弹出层"><a href="#layui-的layer弹出层" class="headerlink" title="layui 的layer弹出层"></a>layui 的layer弹出层</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20250105234257017-0fb210.png" alt="image-20250105234257017"></p><h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p><a href="https://blog.csdn.net/qq_38490457/article/details/109257751?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168183199316800186596889%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168183199316800186596889&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109257751-null-null.142%5Ev84%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=js%E5%AD%A6%E4%B9%A0&spm=1018.2226.3001.4187">学习JavaScript这一篇就够了</a></p><p><a href="https://www.yuque.com/cessstudy/kak11d/fg5v84">鱼雀笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用</title>
      <link href="/posts/63612.html"/>
      <url>/posts/63612.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>C++里面单引号表示单个字符，双引号表示两个字节</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eg:<span class="string">&#x27;a&#x27;</span> 表示一个字符a，“a”表示a\<span class="number">0</span>   a加上结束符号</span><br></pre></td></tr></table></figure><p>c++表示八进制和十六进制都是一个字节</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\ddd表示八进制 &gt; \<span class="number">234</span></span><br><span class="line">\xdd表示十六进制 &gt;\x232</span><br></pre></td></tr></table></figure><p><code>strlen</code> 和 <code>sizeof</code>区别</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">strlen计算长度时候，当碰到\<span class="number">0</span>后终止，后面的字符不进行长度的计算</span><br><span class="line">而<span class="keyword">sizeof</span>在进行计算的时候，计算所有的字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意“”  有个\<span class="number">0</span>结束字符在<span class="keyword">sizeof</span>的时候也会计算</span><br></pre></td></tr></table></figure><p>指数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对于C++来说，指数是E或者e来表示</span><br><span class="line"><span class="number">2e-6</span> <span class="number">-1.5E2</span>  如果结尾加个<span class="built_in">F</span>(f)表示结果为<span class="type">float</span>类型的数据</span><br><span class="line"><span class="built_in">e</span>(E)后(即指数)必须是整数</span><br></pre></td></tr></table></figure><p><code>const</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span>表示常量，这个变量值不可以发生变化</span><br></pre></td></tr></table></figure><p>运算符优先级</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">逻辑运算符的先后：非&gt;与&gt;或</span><br><span class="line">逻辑运算符 &gt; 条件运算符&gt;值运算符</span><br></pre></td></tr></table></figure><p>预处理指令 ——感觉不重要</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  #<span class="keyword">ifdef</span> #<span class="keyword">ifndef</span> 可以防止双重定义</span></span><br></pre></td></tr></table></figure><p>#define</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">宏定义，简单宏的定义以及带参数宏定义</span><br></pre></td></tr></table></figure><p>特定的命名空间&#x2F;库吧</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">使用标准库文件iostream时，要写上std;使用非标准库文件iostream.h</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     #<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std</span><br><span class="line"></span><br><span class="line">里面包括输出cin和输出cout</span><br></pre></td></tr></table></figure><p>数组</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">类型 名称[大小]  eg:<span class="type">int</span> a[<span class="number">10</span>]</span><br><span class="line">对于C++来说，如果数组定义完了没有给元素赋值，那么元素值随机，如果赋值部分元素，那么剩余元素就是<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;   数组元素全是零</span><br><span class="line"><span class="type">int</span> d[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>&#125; 数组只有第一个元素有值</span><br></pre></td></tr></table></figure><p>指针</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* 取内容   &amp;取指针所放的地址</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>动态内存分配</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在C语言中<span class="built_in">malloc</span>()  和 <span class="built_in">free</span>()函数用来动态的申请内存和释放内存</span><br><span class="line"></span><br><span class="line">而c++中是<span class="keyword">new</span>和<span class="keyword">delete</span>进行操作</span><br></pre></td></tr></table></figure><p>vector</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">是动态数组，即数组的长度可以发生改变</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>      #<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  万能公式</span></span><br><span class="line"></span><br><span class="line">vector &lt;/*数据类型*/&gt; &lt;/*名称*/&gt;    eg:vector &lt;<span class="type">int</span>&gt; <span class="function">vec</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">push_back</span><span class="params">()</span>  在最后加入一个新的元素</span></span><br><span class="line"><span class="function">用<span class="title">pop_back</span><span class="params">()</span>  删除最后一个元素</span></span><br><span class="line"><span class="function">.<span class="title">size</span><span class="params">()</span> 求长度</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">vector &lt;<span class="comment">/*数据类型*/</span>&gt;<span class="params">()</span>.<span class="title">swap</span><span class="params">(<span class="comment">/*名称*/</span>)</span>  清空所有数据且释放内存</span></span><br><span class="line"><span class="function">eg:vector&lt;int&gt;().swap(vec)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">名称.empty()检测数组大小是否为零</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">动态数组的排序：sort(vec.begin(),vec.end())  </span></span><br><span class="line"><span class="function">排序部分sort(vec.begin()+x,vec.begin()+y)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">也可以自己定义结构体，来使得vector里面是结构体</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">动态数组初始化一个数或者数组大小</span></span><br><span class="line"><span class="function">vector&lt;/*数组类型*/&gt; /*s*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂学自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂学自学 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模方法</title>
      <link href="/posts/19057.html"/>
      <url>/posts/19057.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性规划模型（LP算法问题）"><a href="#线性规划模型（LP算法问题）" class="headerlink" title="线性规划模型（LP算法问题）"></a>线性规划模型（LP算法问题）</h1><p>利用现有资源来安排生产，从而取得最大经济利益问题</p><p>其中设置变量为决策变量，决策变量构成的函数被称为问题的目标函数，通过题目要求列举出来的不等式叫做约束条件</p><p>目标函数和约束条件都为线性函数时候为线性规划</p><p>下面为<code>matlab</code>里面的基本描述，<strong>其中求解最小值，如果求最大值则要加上负号</strong><strong><strong>，计算出来的最优解也需要加上负号</strong></strong></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220724154722175-b57d9b.png" alt="image-20220724154722175"></p><h2 id="matlab求解线性规划的函数：linprog"><a href="#matlab求解线性规划的函数：linprog" class="headerlink" title="matlab求解线性规划的函数：linprog"></a><code>matlab</code>求解线性规划的函数：<code>linprog</code></h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220724154839467-1337ce.png" alt="image-20220724154839467"></p><p>其中的x返回值是取得最优解的时候决策变量的取值，<code>fval</code>为最优值的计算结果</p><p>可行解，可行域，最优解</p><h2 id="可以转化为线性规划的问题"><a href="#可以转化为线性规划的问题" class="headerlink" title="可以转化为线性规划的问题"></a>可以转化为线性规划的问题</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220724160857536-bee2ac.png" alt="image-20220724160857536"></p><p>例如上面的例子可以进行转化为线性函数</p><h2 id="多目标规划转化为线性规划"><a href="#多目标规划转化为线性规划" class="headerlink" title="多目标规划转化为线性规划"></a>多目标规划转化为线性规划</h2><h3 id="模型一：固定其他目标，计算一个"><a href="#模型一：固定其他目标，计算一个" class="headerlink" title="模型一：固定其他目标，计算一个"></a>模型一：固定其他目标，计算一个</h3><h3 id="模型二：将两个按照概率进行计算如下图中的模型三"><a href="#模型二：将两个按照概率进行计算如下图中的模型三" class="headerlink" title="模型二：将两个按照概率进行计算如下图中的模型三"></a>模型二：将两个按照概率进行计算如下图中的模型三</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220724165652340-f3ebac.png" alt="image-20220724165652340"></p><h1 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h1><p>数学规划中的变量限制为整数，就叫做整数线性规划，变量全限制为整数时候，为纯整数规划，变量部分限制为整数的，为混合整数规划，对于整数规划可能没有可行解， </p><h3 id="整数规划的一般数学模型："><a href="#整数规划的一般数学模型：" class="headerlink" title="整数规划的一般数学模型："></a>整数规划的一般数学模型：</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220724191913176-5b04af.png" alt="image-20220724191913176"></p><h3 id="整数规划的分类："><a href="#整数规划的分类：" class="headerlink" title="整数规划的分类："></a>整数规划的分类：</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220724192039608-66501b.png" alt="image-20220724192039608"></p><p>松弛变量：添加一个变量使得一个不等式变成一个等式，这个不等式一般是小于等于不等式，变量值一般大于0</p><p>剩余变量：添加一个变量使得一个不等式变成一个等式，这个不等式一般是大于等于不等式，变量值一般小于0</p><p>对于0-1整数规划：一般是工作安排，运动员安排，一般适用于流程安排，也叫做指派问题</p><h3 id="整数规划与线性规划关系："><a href="#整数规划与线性规划关系：" class="headerlink" title="整数规划与线性规划关系："></a>整数规划与线性规划关系：</h3><p>整数规划是线性规划（松弛问题）的可行解</p><p>线性规划无可行解，整数规划也没有</p><p>整数规划的最优值小于等于松弛问题最优值</p><h2 id="整数规划的求解：——可以使用matlab中的intlinporg函数"><a href="#整数规划的求解：——可以使用matlab中的intlinporg函数" class="headerlink" title="整数规划的求解：——可以使用matlab中的intlinporg函数"></a>整数规划的求解：——可以使用<code>matlab</code>中的<code>intlinporg</code>函数</h2><h3 id="穷举法："><a href="#穷举法：" class="headerlink" title="穷举法："></a>穷举法：</h3><p>线性规划中的可行解数量较少，逐个尝试，不建议使用</p><h3 id="分支限界法："><a href="#分支限界法：" class="headerlink" title="分支限界法："></a>分支限界法：</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>首先不考虑整数限制先求出松弛问题最优解；</p><p>如果松弛问题无可行解，则<code>ILP</code>无可行解；如果松弛问题可行解刚好是整数，那么就为<code>ILP</code>最优解；如果不满足，那么选择某个非整数变量分支，添加约束，将某个非整数变量进行取整，然后进行计算，直到所有值都为整数，而且最后得到的值最大即可；（需要考虑所有情况，上届取整和下届取整）</p><h3 id="割平面法："><a href="#割平面法：" class="headerlink" title="割平面法："></a>割平面法：</h3><p>如果松弛问题无可行解，则割平面无可行解；如果松弛问题可行解刚好是整数，那么就为割平面最优解；如果不为整数，那么对于约束条件构成的平面，如果一个平面中所有取值都为小数，那么将取值都为小数的平面割掉，之后用松弛问题进行求解；</p><p>实现方法：需要加上一个松弛变量，使得不等式变成等式，之后将松弛变量的系数转化为整数部分加上小数部分，将所有的系数都这样转换，之后整数部分放一块等式左边，小数部分放在等式右边。考虑整数部分计算结果为整数，而等式右边一个小数减去一个正数要为整数，那么等式右边一定小于等于0；如下图，fi为一个小数（0-1）</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726145946506-83dc67.png" alt="image-20220726145946506"></p><p>计算过程：其中单纯形法可以用<code>matlab</code>中的<code>linprog</code>方法计算<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726150134186-189144.png" alt="image-20220726150134186"></p><h3 id="隐枚举法（主要解决0-1规划）："><a href="#隐枚举法（主要解决0-1规划）：" class="headerlink" title="隐枚举法（主要解决0-1规划）："></a>隐枚举法（主要解决0-1规划）：</h3><h3 id="匈牙利法（主要解决0-1规划）："><a href="#匈牙利法（主要解决0-1规划）：" class="headerlink" title="匈牙利法（主要解决0-1规划）："></a>匈牙利法（主要解决0-1规划）：</h3><p>对于01互斥问题，对于互斥约束的推广，其中M为inf无穷大的一个值，当y为1那么小于一个无穷大的值，相当于不存在。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726174545428-9ab951.png" alt="image-20220726174545428"></p><h4 id="对于指派工作的一般形式"><a href="#对于指派工作的一般形式" class="headerlink" title="对于指派工作的一般形式"></a>对于指派工作的一般形式</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726180006646-1e838d.png" alt="image-20220726180006646"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726180033217-938e6d.png" alt="image-20220726180033217"></p><h4 id="对于一些非标准的指派问题，对于其中的最大化指派问题再进行计算的时候可以将矩阵加上负号进行计算。"><a href="#对于一些非标准的指派问题，对于其中的最大化指派问题再进行计算的时候可以将矩阵加上负号进行计算。" class="headerlink" title="对于一些非标准的指派问题，对于其中的最大化指派问题再进行计算的时候可以将矩阵加上负号进行计算。"></a>对于一些非标准的指派问题，对于其中的最大化指派问题再进行计算的时候可以将矩阵加上负号进行计算。<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726180319319-211462.png" alt="image-20220726180319319"></h4><h4 id="匈牙利解法一般步骤："><a href="#匈牙利解法一般步骤：" class="headerlink" title="匈牙利解法一般步骤："></a>匈牙利解法一般步骤：</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726180503587-fdaf9e.png" alt="image-20220726180503587"></p><p>在生产的元素中Cij矩阵每一行和每一列只能有一个1</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726180749883-6a864f.png" alt="image-20220726180749883"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726181038154-40872f.png" alt="image-20220726181038154"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726181313888-314937.png" alt="image-20220726181313888"></p><p>一般可以用<code>matlab</code>算法进行求解，列出来最优方程，约束条件为列出来每一行加上或者每一列加上为1，最大值一最小值0，用<code>intlinprog</code>函数进行求解即可。</p><h1 id="非线性规划问题"><a href="#非线性规划问题" class="headerlink" title="非线性规划问题"></a>非线性规划问题</h1><p>如果目标函数或约束条件中包含非线性函数，就称为非线性规划问题</p><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726192149017-24c8cf.png" alt="image-20220726192149017"></p><p> 基本上还是求解最小值</p><h3 id="matlab求解方法"><a href="#matlab求解方法" class="headerlink" title="matlab求解方法"></a><code>matlab</code>求解方法</h3><p>在进行求解最大值的时候也是加上负号就好了，对于cx和ceq是非线性函数。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726192434178-e3681f.png" alt="image-20220726192434178"></p><h3 id="matlab中求解方法是fmincon"><a href="#matlab中求解方法是fmincon" class="headerlink" title="matlab中求解方法是fmincon"></a><code>matlab</code>中求解方法是<code>fmincon</code></h3><p><code>fun</code>为函数，<code>x0</code>为函数初值，<code>nonlcon</code>非线性函数，</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726192706281-e7cf7e.png" alt="image-20220726192706281"></p><p>下面是<code>nonlcon</code>的一个例子，在下面中，g返回是c，h返回的是<code>ceq</code></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726193107227-d8ede8.png" alt="image-20220726193107227"></p><h2 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h2><p>其中目标函数为自变量的二次函数，约束条件全是线性的</p><h3 id="matlab求解方法-1"><a href="#matlab求解方法-1" class="headerlink" title="matlab求解方法"></a><code>matlab</code>求解方法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726193830845-16588355128871-1ddead.png" alt="image-20220726193830845"></p><h3 id="使用的方法用quadprog"><a href="#使用的方法用quadprog" class="headerlink" title="使用的方法用quadprog"></a>使用的方法用<code>quadprog</code></h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726195627730-a652e7.png" alt="image-20220726195627730"></p><h1 id="层次分析法AHP模型"><a href="#层次分析法AHP模型" class="headerlink" title="层次分析法AHP模型"></a>层次分析法AHP模型</h1><p>特点是在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法，是对难于完全定量的复杂系统做出决策的模型和方法。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>是一种解决多目标的复杂问题的<strong>定性与定量相结合</strong>的决策分析方法，将定量分析与定性分析结合起来，用决策者的经验判断各衡量目标能否实现的标准之间的相对重要的程度，并合理的给出每个决策方案的每个标准的权数，利用权数求出各个方案的优劣次序。 </p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>最佳方案选取</p><p>用于评价类问题</p><p>用于指标体系的优选 </p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726210215959-416996.png" alt="image-20220726210215959"></p><h2 id="步骤和方法"><a href="#步骤和方法" class="headerlink" title="步骤和方法"></a>步骤和方法</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726210405733-3bc93d.png" alt="image-20220726210405733"></p><h2 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h2><p>最高层：解决问题的目的</p><p>中间层：准则层，指标层</p><p>最底层：备选，选用解决方案的各种措施</p><p>层与层之间用直线连接</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220726210531658-530c7e.png" alt="image-20220726210531658"></p><h2 id="判断矩阵"><a href="#判断矩阵" class="headerlink" title="判断矩阵"></a>判断矩阵</h2><p>在进行比较的时候，两两进行比较，而且有相对尺度</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727140713594-279396.png" alt="image-20220727140713594"></p><p>对于两个指标进行比较，一到九的指标含义如下</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727140804489-c39dbf.png" alt="image-20220727140804489"></p><p>对于判断矩阵中的元素，在进行矩阵构建的时候，允许不一致，即1比3是二分之一，1比2是4，那么2比3不一定是8，可以是7，允许不一致，但是不一致要给定范围。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727141030903-91c20c.png" alt="image-20220727141030903"></p><h3 id="不一致情况"><a href="#不一致情况" class="headerlink" title="不一致情况"></a>不一致情况</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727141342807-8a2847.png" alt="image-20220727141342807"></p><h3 id="判断是否一致，层次单排序一致性检验"><a href="#判断是否一致，层次单排序一致性检验" class="headerlink" title="判断是否一致，层次单排序一致性检验"></a>判断是否一致，层次单排序一致性检验</h3><p><strong><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727143202059-24d365.png" alt="image-20220727143202059"></strong></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727143304212-01718f.png" alt="image-20220727143304212"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727143541297-5beaae.png" alt="image-20220727143541297"></p><p><strong><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727143526063-656be6.png" alt="image-20220727143526063"></strong></p><p>一般用来进行查表计算：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727145945352-83ea40.png" alt="image-20220727145945352"></p><h3 id="层次总排序一致性检验"><a href="#层次总排序一致性检验" class="headerlink" title="层次总排序一致性检验"></a>层次总排序一致性检验</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727150114118-5edecd.png" alt="image-20220727150114118"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727150128094-6bf60f.png" alt="image-20220727150128094"></p><h2 id="层次分析法的步骤"><a href="#层次分析法的步骤" class="headerlink" title="层次分析法的步骤"></a>层次分析法的步骤</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727145746848-f332eb.png" alt="image-20220727145746848"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727145810756-33634e.png" alt="image-20220727145810756"></p><h1 id="灰色关联分析与预测模型"><a href="#灰色关联分析与预测模型" class="headerlink" title="灰色关联分析与预测模型"></a>灰色关联分析与预测模型</h1><p>解决相关性问题和预测性问题，对于一些问题一些已知的数据以及未知规律进行预测。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>灰色关联分析，哪些指标有关联</p><p>灰色预测：人口预测；灾难预测</p><p>灰色决策</p><p>灰色预测控制</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>灰色系统内的一部分信息是已知的，另一部分信息是未知的，系统内各因素间有不确定的关系</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727172844570-194c9d.png" alt="image-20220727172844570"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727172930423-e00d57.png" alt="image-20220727172930423"></p><p>在时间测试上要进行等距测试</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727173106214-afda96.png" alt="image-20220727173106214"></p><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727173137402-882e4a.png" alt="image-20220727173137402"></p><p>对于畸变预测：对于一些异常天气的预测，零部件或者一些工件坏的预测</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727173308349-2ba7f7.png" alt="image-20220727173308349"></p><p>系统预测不常用</p><h2 id="灰色关联度与优势分析"><a href="#灰色关联度与优势分析" class="headerlink" title="灰色关联度与优势分析"></a>灰色关联度与优势分析</h2><p>判断哪些因素重要，哪些因素有一定作用，当得到数据后要进行处理，使得在一个量纲内</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727173604189-eceefd.png" alt="image-20220727173604189"></p><p>根据比较数列对于参考数列的进行比较</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727173752090-43b046.png" alt="image-20220727173752090"></p><p>其中的每个元素都是一个数列，其中ρ是关联系数，一般取得0.5</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727174050527-9790a4.png" alt="image-20220727174050527"></p><p>这里用来计算整个的关联度</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727174104320-277696.png" alt="image-20220727174104320"></p><p>这里面<code>sign</code>是符号函数</p><h2 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727175726213-6b5fcf.png" alt="image-20220727175726213"></p><h3 id="累加生成"><a href="#累加生成" class="headerlink" title="累加生成"></a>累加生成</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727175752994-aa8a37.png" alt="image-20220727175752994"></p><p>前几个数据加起来，eg:（1，3，5，7）累加数列为（1，4，9，16）</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727180508217-71f025.png" alt="image-20220727180508217"></p><h3 id="累减生成"><a href="#累减生成" class="headerlink" title="累减生成"></a>累减生成</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727175954523-ed3596.png" alt="image-20220727175954523"></p><p>前几个数据减去起来，eg:（1，2，3，4）累减数列为（1，1，1，1）</p><h3 id="加权邻值生成"><a href="#加权邻值生成" class="headerlink" title="加权邻值生成"></a>加权邻值生成</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727180150274-886763.png" alt="image-20220727180150274"></p><h2 id="灰色模型"><a href="#灰色模型" class="headerlink" title="灰色模型"></a>灰色模型</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727180902914-e11d02.png" alt="image-20220727180902914"></p><p>经过数据处理，找出来规律，然后建立起来微分方程</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727181010784-fb3ece.png" alt="image-20220727181010784"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727181232891-fa5264.png" alt="image-20220727181232891"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727181459930-a59af1.png" alt="image-20220727181459930"></p><h4 id="灰色建模的步骤"><a href="#灰色建模的步骤" class="headerlink" title="灰色建模的步骤"></a>灰色建模的步骤</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727183719081-035535.png" alt="image-20220727183719081"></p><p>后面的是e的n+2分之二次方</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727183959545-16589184014271-0460c2.png" alt="image-20220727183959545"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727184128814-1bf4ee.png" alt="image-20220727184128814"></p><h1 id="插值与拟合的基本原理与编程实践"><a href="#插值与拟合的基本原理与编程实践" class="headerlink" title="插值与拟合的基本原理与编程实践"></a>插值与拟合的基本原理与编程实践</h1><p>拉格朗日插值</p><p>龙格现象：不应当使用七次以上的插值</p><p>分段线性插值</p><p>牛顿插值</p><h2 id="matlab插值"><a href="#matlab插值" class="headerlink" title="matlab插值"></a><code>matlab</code>插值</h2><p>推荐一维插值用样条，二维用立方</p><h3 id="一维插值"><a href="#一维插值" class="headerlink" title="一维插值"></a>一维插值</h3><p>一般是<code>interp1</code>，基本格式为<code>yi=interp1(x,y,xi,&#39;method&#39;)</code><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727211033980-b09de4.png" alt="image-20220727211033980"></p><h3 id="二维插值"><a href="#二维插值" class="headerlink" title="二维插值"></a>二维插值</h3><p>基本格式为<code>zi=interp2(x,y,z,xi,yi,&#39;method&#39;)</code></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727211639746-21ce6c.png" alt="image-20220727211639746"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727211700613-27f8b2.png" alt="image-20220727211700613"></p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727212224411-d056e9.png" alt="image-20220727212224411"></p><h3 id="散乱点插值"><a href="#散乱点插值" class="headerlink" title="散乱点插值"></a>散乱点插值</h3><p>可用<code>griddata(x,y,z,xi,yi,&#39;method&#39;)</code></p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727215257881-59d13e.png" alt="image-20220727215257881"></p><h3 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h3><p>常用的命令<code>【a,S】=polyfit(x,y,n)</code></p><p><code>yp=polyval(a,xp)</code>拟合完成后带入x值求y值</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727215342177-86776b.png" alt="image-20220727215342177"></p><h3 id="非线性拟合"><a href="#非线性拟合" class="headerlink" title="非线性拟合"></a>非线性拟合</h3><p><code>[b,r]=polyfit(x,y,fun,b0,option)</code></p><p><code>nlinfit</code>也可以使用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727215702633-65475f.png" alt="image-20220727215702633"></p><h3 id="matlab工具箱cftool"><a href="#matlab工具箱cftool" class="headerlink" title="matlab工具箱cftool"></a><code>matlab</code>工具箱<code>cftool</code></h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220727220130197-60e3b0.png" alt="image-20220727220130197"></p><h1 id="模糊综合评价模型原理与案例"><a href="#模糊综合评价模型原理与案例" class="headerlink" title="模糊综合评价模型原理与案例"></a>模糊综合评价模型原理与案例</h1><p>现实世界中许多现象和关系有不确定性，如随机性，粗糙性质。</p><h2 id="模糊集"><a href="#模糊集" class="headerlink" title="模糊集"></a>模糊集</h2><p>现实生活中，需对现象以及关系比较模糊，例如高和矮，长和短。不满足非此即彼的排中律，具有亦此亦彼的模糊性</p><p>随机不确定是因果律破损造成的不确定，模糊不确定是排中律破损造成的不确定</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730150732963-af16ef.png" alt="image-20220730150732963"></p><h2 id="模糊集的运算"><a href="#模糊集的运算" class="headerlink" title="模糊集的运算"></a>模糊集的运算</h2><p>通过隶属函数完成</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730150917068-79f657.png" alt="image-20220730150917068"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730150939021-6dc09d.png" alt="image-20220730150939021"></p><h2 id="隶属度函数的确定"><a href="#隶属度函数的确定" class="headerlink" title="隶属度函数的确定"></a>隶属度函数的确定</h2><p>常用的方法是模糊分布法</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151036211-e90a0f.png" alt="image-20220730151036211"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151045391-3d9306.png" alt="image-20220730151045391"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151055767-4a6f63.png" alt="image-20220730151055767"></p><h2 id="模糊综合评价"><a href="#模糊综合评价" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h2><p> 常用的有灰色评价法、层次分析法、模糊综合评价法、数据包络分析法、人工神经网络评价法、理想解法。</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151257834-42d269.png" alt="image-20220730151257834"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151402550-af77d5.png" alt="image-20220730151402550"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151426068-dfdffe.png" alt="image-20220730151426068"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151436821-e8aa8c.png" alt="image-20220730151436821"></p><p>称为各个指标的模糊综合评价矩阵</p><p>通常采用频率法确定隶属度rij</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151547055-d36405.png" alt="image-20220730151547055"></p><h3 id="指标权重的确定"><a href="#指标权重的确定" class="headerlink" title="指标权重的确定"></a>指标权重的确定</h3><p>有主观和客观两种方法，主观法代表的是层次分析法，客观发有质量分数法，变异系数法</p><h3 id="变异系数法"><a href="#变异系数法" class="headerlink" title="变异系数法"></a>变异系数法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151756793-cef319.png" alt="image-20220730151756793"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151828015-64ec77.png" alt="image-20220730151828015"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151842147-0d3477.png" alt="image-20220730151842147"></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><code>matlab</code>计算平均值mean计算方差std</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730151909156-136e51.png" alt="image-20220730151909156"></p><p>变异系数法仅仅知道哪些指标分辨能力更强，不能确定哪些指标重要。</p><h2 id="模糊合成与综合评价"><a href="#模糊合成与综合评价" class="headerlink" title="模糊合成与综合评价"></a>模糊合成与综合评价</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152115595-3309a4.png" alt="image-20220730152115595"></p><p>B的计算方法——模糊算子的计算方法</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152147433-f61ea6.png" alt="image-20220730152147433"></p><p>利用R的信息为不充分、比较充分、比较充分、充分</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152335718-a74fbb.png" alt="image-20220730152335718"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152449532-434d48.png" alt="image-20220730152449532"></p><h4 id="对B向量的处理方法"><a href="#对B向量的处理方法" class="headerlink" title="对B向量的处理方法"></a>对B向量的处理方法</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152530839-b99c18.png" alt="image-20220730152530839"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152605363-16591659662461-424f41.png" alt="image-20220730152605363"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152640288-e7720e.png"></p><h2 id="评价矩阵的计算方法"><a href="#评价矩阵的计算方法" class="headerlink" title="评价矩阵的计算方法"></a>评价矩阵的计算方法</h2><h3 id="相对偏差法"><a href="#相对偏差法" class="headerlink" title="相对偏差法"></a>相对偏差法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152907272-eb8ffb.png" alt="image-20220730152907272"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152918020-3a1d39.png" alt="image-20220730152918020"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152940444-d2b3bb.png" alt="image-20220730152940444"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730152951977-45f2ee.png" alt="image-20220730152951977"></p><p>F是越小越好</p><h3 id="相对优属度"><a href="#相对优属度" class="headerlink" title="相对优属度"></a>相对优属度</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730153103860-6a8877.png" alt="image-20220730153103860"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730153112737-cb161a.png" alt="image-20220730153112737"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730153130132-dc76a5.png" alt="image-20220730153130132"></p><p>F是越大越好</p><h2 id="灰色关联分析与相对偏差法和相对优属度区别"><a href="#灰色关联分析与相对偏差法和相对优属度区别" class="headerlink" title="灰色关联分析与相对偏差法和相对优属度区别"></a>灰色关联分析与相对偏差法和相对优属度区别</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730153256755-45e21d.png" alt="image-20220730153256755"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730153319665-1f79c8.png" alt="image-20220730153319665"></p><h1 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730155022235-b61332.png" alt="image-20220730155022235"></p><h2 id="变量关系强度"><a href="#变量关系强度" class="headerlink" title="变量关系强度"></a>变量关系强度</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730155039484-a03335.png" alt="image-20220730155039484"></p><h2 id="四种基本变量"><a href="#四种基本变量" class="headerlink" title="四种基本变量"></a>四种基本变量</h2><p>做相关性分析前首先要进行变量类型的分析，下面四种变量依次上升</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730155110283-b0c332.png" alt="image-20220730155110283"></p><p>定距变量和定比变量的区别是定距变量没有零点，意味着定距变量只能做加减不能做乘除，定比变量都可用，有零点。</p><h2 id="两变量的相关性分析"><a href="#两变量的相关性分析" class="headerlink" title="两变量的相关性分析"></a>两变量的相关性分析</h2><p> 主要功能：相关分析的基本概念，相关系数及其检验</p><h3 id="pearson-皮尔逊-相关系数"><a href="#pearson-皮尔逊-相关系数" class="headerlink" title="pearson(皮尔逊)相关系数"></a><code>pearson</code>(皮尔逊)相关系数</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730155912606-64353a.png"></p><p>统计结果存在偶然性，对于计算结果要进行t检验，如果通过t检验，那么说不存在偶然性，显著性水平高</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160240931-dcf1ae.png" alt="image-20220730160240931"></p><p>判断通过检验用0.05的如下面表格的数据</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730162031540-6ac733.png" alt="image-20220730162031540"></p><p>这个t是进行n-2进行分布</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160335049-b5264d.png" alt="image-20220730160335049"></p><p>对于r若为正那么正相关，如果负那么负相关</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160458324-f591e4.png" alt="image-20220730160458324"></p><h3 id="spearman等级相关系数"><a href="#spearman等级相关系数" class="headerlink" title="spearman等级相关系数"></a><code>spearman</code>等级相关系数</h3><p>书用于定序变量与定序变量之间的关系</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160634792-4230f3.png" alt="image-20220730160634792"></p><p>对于计算的时候要进行等级排序，例如<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160730415-145e5e.png" alt="image-20220730160730415"></p><p>排序为12345等级</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160802447-399874.png" alt="image-20220730160802447"></p><p>对于t检验如上图</p><h3 id="Kendall-tua-b等级相关系数"><a href="#Kendall-tua-b等级相关系数" class="headerlink" title="Kendall tua-b等级相关系数"></a>Kendall tua-b等级相关系数</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160830753-94f013.png" alt="image-20220730160830753"></p><h3 id="ETA系数检验"><a href="#ETA系数检验" class="headerlink" title="ETA系数检验"></a>ETA系数检验</h3><p>ETA&#x3D;组间方差除以组内方差然后取开平方</p><p>ETA越高，表示变量影响越大，通常使用非线性</p><h3 id="变量关系强度测量主要指标"><a href="#变量关系强度测量主要指标" class="headerlink" title="变量关系强度测量主要指标"></a>变量关系强度测量主要指标</h3><p>其中定距和定比放在一块</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730160853545-822753.png" alt="image-20220730160853545"></p><h1 id="数据降维主成分分析"><a href="#数据降维主成分分析" class="headerlink" title="数据降维主成分分析"></a>数据降维主成分分析</h1><p>解决数据冗余，用指标代替所有数据</p><h2 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730181125009-021346.png" alt="image-20220730181125009"></p><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>数据压缩，数据解释</p><p>对于数据的压缩是选取一个指标可用代替原来数据的多个指标，并不是从原来的指标中选取几个典型，即对原来数据的分类以及综合</p><p>数据解释是整合好的数据，这些数据代表着以前数据的什么含义，对综合指标的解释说明</p><p>差距越小，方差越小，信息量越少</p><p>差距越大，方差越大，信息量越多</p><p>对于主成分分析，新数据（综合数据）&#x3D;原来数据的线性变换，所以主成分分析最重要的是找到线性关系</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730183257095-2e312d.png" alt="image-20220730183257095"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730183320697-233006.png" alt="image-20220730183320697"></p><p>统计出来新的无关综合变量是相互独立的，彼此之间没有关系</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730183503802-0fb354.png" alt="image-20220730183503802"></p><p>尽量选择少的主成分</p><h3 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730183746314-748fb1.png" alt="image-20220730183746314"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730183945280-cd415f.png" alt="image-20220730183945280"></p><p>其中VAR是为方差的计算</p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730184112939-1fe3a1.png" alt="image-20220730184112939"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730184645638-71391d.png" alt="image-20220730184645638"></p><p>方差越大越好，var方差</p><p>当a是特征向量的时候就最大，是矩阵的特征向量</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730185725379-e1c56e.png" alt="image-20220730185725379"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730190310480-094911.png" alt="image-20220730190310480"></p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730190332586-a5aa92.png" alt="image-20220730190332586"></p><h4 id="做不做主成分分析的检验"><a href="#做不做主成分分析的检验" class="headerlink" title="做不做主成分分析的检验"></a>做不做主成分分析的检验</h4><p>寻找相关性，<code>Bartlets</code>大于0.59，相关性高可用所</p><p><code>KMO</code>检验</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730184429978-13718b.png" alt="image-20220730184429978"></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220730190441905-5221ef.png" alt="image-20220730190441905"></p><h1 id="回归分析算法基本原理以及编程实现"><a href="#回归分析算法基本原理以及编程实现" class="headerlink" title="回归分析算法基本原理以及编程实现"></a>回归分析算法基本原理以及编程实现</h1><p>回归分析——构建数据之间的关系，构建变量与变量之间具体的关系式，用函数或者方程去拟合这个关系式</p><p>相关分析——判断变量与变量之间有无关联，关联程度是多少</p><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731124706915-2ce148.png" alt="image-20220731124706915"></p><p>注意要进行检验</p><h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731124935821-16592429764801-2621f8.png" alt="image-20220731124935821"></p><p>去求解出来B0和B1的方法进行求解：</p><h4 id="连续的函数进行求解"><a href="#连续的函数进行求解" class="headerlink" title="连续的函数进行求解"></a>连续的函数进行求解</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731125204488-f1cb21.png" alt="image-20220731125204488"></p><h4 id="离散型的进行求解"><a href="#离散型的进行求解" class="headerlink" title="离散型的进行求解"></a>离散型的进行求解</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731125331511-19270d.png" alt="image-20220731125331511"></p><h4 id="误差的估计量"><a href="#误差的估计量" class="headerlink" title="误差的估计量"></a>误差的估计量</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731125406018-f0443a.png" alt="image-20220731125406018"></p><h3 id="回归方程的显著性检验"><a href="#回归方程的显著性检验" class="headerlink" title="回归方程的显著性检验"></a>回归方程的显著性检验</h3><p>显著性水平：估计总体参数落在某一个区间可能犯错的概率，显著性水平一般取0.05，犯错的概率越小越好</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731125956798-ad8d3c.png" alt="image-20220731125956798"></p><h4 id="假设检验——假设H0成立"><a href="#假设检验——假设H0成立" class="headerlink" title="假设检验——假设H0成立"></a>假设检验——假设H0成立</h4><h5 id="F检验"><a href="#F检验" class="headerlink" title="F检验"></a>F检验</h5><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731130634888-3c5ad4.png" alt="image-20220731130634888"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731130824809-672dfc.png" alt="image-20220731130824809"></p><h5 id="T检验"><a href="#T检验" class="headerlink" title="T检验"></a>T检验</h5><p>适合较小样本检验，一般样本小于三十个</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731130911114-b1b813.png" alt="image-20220731130911114"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731130928789-f8ccef.png" alt="image-20220731130928789"></p><h5 id="R检验"><a href="#R检验" class="headerlink" title="R检验"></a>R检验</h5><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731131105278-82adae.png"></p><h3 id="回归系数的置信区间"><a href="#回归系数的置信区间" class="headerlink" title="回归系数的置信区间"></a>回归系数的置信区间</h3><p>对于计算出来的<code>B0</code>、<code>B1</code>有一个区间范围</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731131400085-b6d48f.png" alt="image-20220731131400085"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731131539449-11e8dd.png" alt="image-20220731131539449"></p><h3 id="预测与控制"><a href="#预测与控制" class="headerlink" title="预测与控制"></a>预测与控制</h3><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731131721986-bd7702.png" alt="image-20220731131721986"></p><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132011588-02096c.png" alt="image-20220731132011588"></p><h3 id="常用的目标函数及其线性方法"><a href="#常用的目标函数及其线性方法" class="headerlink" title="常用的目标函数及其线性方法"></a>常用的目标函数及其线性方法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132401460-7899ff.png" alt="image-20220731132401460"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132411863-6c07cc.png" alt="image-20220731132411863"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132554559-3bd981.png" alt="image-20220731132554559"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132608613-275c5c.png" alt="image-20220731132608613"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132630110-caa488.png" alt="image-20220731132630110"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132648652-bd4f8b.png" alt="image-20220731132648652"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132726891-93f028.png" alt="image-20220731132726891"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132742748-3395bb.png" alt="image-20220731132742748"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731132808143-b3a492.png" alt="image-20220731132808143"></p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h3 id="数学模型-1"><a href="#数学模型-1" class="headerlink" title="数学模型"></a>数学模型</h3><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731135550111-8976b7.png" alt="image-20220731135550111"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731135557408-b82a41.png" alt="image-20220731135557408"></p><h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731135641805-d25ecf.png" alt="image-20220731135641805"></p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731135815313-bd43d1.png" alt="image-20220731135815313"></p><h2 id="多元线性回归检验与预测"><a href="#多元线性回归检验与预测" class="headerlink" title="多元线性回归检验与预测"></a>多元线性回归检验与预测</h2><h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731135903261-3945d7.png" alt="image-20220731135903261"></p><h4 id="F检验-1"><a href="#F检验-1" class="headerlink" title="F检验"></a>F检验</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731135923401-ed3083.png" alt="image-20220731135923401"></p><h4 id="R检验-1"><a href="#R检验-1" class="headerlink" title="R检验"></a>R检验</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140020264-1a4f45.png" alt="image-20220731140020264"></p><h3 id="预测-1"><a href="#预测-1" class="headerlink" title="预测"></a>预测</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140118786-961f31.png" alt="image-20220731140118786"></p><h2 id="逐步回归分析"><a href="#逐步回归分析" class="headerlink" title="逐步回归分析"></a>逐步回归分析</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140210454-64b850.png" alt="image-20220731140210454"></p><p>所有的指标都对目标有影响</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140413812-4638ed.png" alt="image-20220731140413812"></p><h3 id="逐步分析回归法思想"><a href="#逐步分析回归法思想" class="headerlink" title="逐步分析回归法思想"></a>逐步分析回归法思想</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140516114-d307b4.png" alt="image-20220731140516114"></p><p>计算出来重要性将一个指标引入，之后将这个指标与其他的指标组合进行计算重要性，如果重要性提高，那么就可再次引入，若重要性不再提高，那么就不再引入</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="多元线性回归-1"><a href="#多元线性回归-1" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140743473-9cabc8.png" alt="image-20220731140743473"></p><p>对于一元线性回归，让p&#x3D;1即可</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140913226-fbdf7e.png" alt="image-20220731140913226"></p><p>其中<code>alpha</code>一般取得0.05</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731140934882-8ddcf3.png" alt="image-20220731140934882"></p><h3 id="一元多项式回归"><a href="#一元多项式回归" class="headerlink" title="一元多项式回归"></a>一元多项式回归</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731141309298-fe94aa.png" alt="image-20220731141309298"></p><h3 id="多元二项式回归"><a href="#多元二项式回归" class="headerlink" title="多元二项式回归"></a>多元二项式回归</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731141816049-bf3ea0.png" alt="image-20220731141816049"></p><h3 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731142335053-035d22.png" alt="image-20220731142335053"></p><h3 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h3><p><code>inmodel</code>和<code>alpha</code>一般缺省</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731142543439-2b3c40.png" alt="image-20220731142543439"></p><p>逐步分析用来确定哪些指标可用，逐步分析完成之后用上面的四个回归进行分析即可</p><p>运行上述函数会生成如下图</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731143358446-729866.png" alt="image-20220731143358446"></p><p>可进行手动加入指标以及删除指标</p><h1 id="TOPSIS模型基础以及入门实践"><a href="#TOPSIS模型基础以及入门实践" class="headerlink" title="TOPSIS模型基础以及入门实践"></a><code>TOPSIS</code>模型基础以及入门实践</h1><p>理想解法，是一种有效的多指标评价方法 </p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803160759335-f057e3.png" alt="image-20220803160759335"></p><p>核心就是构建最优解和最劣解</p><p>注意量纲化</p><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161348120-fb1b53.png" alt="image-20220803161348120"></p><p>可进行消除量纲</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161433273-86522d.png" alt="image-20220803161433273"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161446854-21fd1c.png" alt="image-20220803161446854"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161551806-8b0b7c.png" alt="image-20220803161551806"></p><p>越大越优</p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161808030-024e25.png" alt="image-20220803161808030"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161822563-70f478.png" alt="image-20220803161822563"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803162544966-700d28.png" alt="image-20220803162544966"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803162602446-27d985.png" alt="image-20220803162602446"></p><h3 id="matlab的标准化处理函数zscore-X"><a href="#matlab的标准化处理函数zscore-X" class="headerlink" title="matlab的标准化处理函数zscore(X)"></a><code>matlab</code>的标准化处理函数<code>zscore</code>(X)</h3><h3 id="matlab排序算法"><a href="#matlab排序算法" class="headerlink" title="matlab排序算法"></a><code>matlab</code>排序算法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803163244188-c24a64.png" alt="image-20220803163244188"></p><p>f是要排序的东西，<code>desecend</code>是降序</p><p>一般使用规范化，对于上面的四和五选一个就可用</p><h3 id="常见的数学规范化方法"><a href="#常见的数学规范化方法" class="headerlink" title="常见的数学规范化方法"></a>常见的数学规范化方法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803161932901-67b87d.png" alt="image-20220803161932901"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803162003520-93b5c3.png" alt="image-20220803162003520"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803162036579-20b188.png" alt="image-20220803162036579"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803162121155-ffb0f1.png" alt="image-20220803162121155"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803162133031-981b5b.png" alt="image-20220803162133031"></p><h1 id="数学建模常见的综合评价类算法"><a href="#数学建模常见的综合评价类算法" class="headerlink" title="数学建模常见的综合评价类算法"></a>数学建模常见的综合评价类算法</h1><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731151633659-7dbf4e.png" alt="image-20220731151633659"></p><p>也是进行排序</p><h2 id="综合评价的目的"><a href="#综合评价的目的" class="headerlink" title="综合评价的目的"></a>综合评价的目的</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731152114863-1d4b73.png" alt="image-20220731152114863"></p><h2 id="构成评价问题的五个要素"><a href="#构成评价问题的五个要素" class="headerlink" title="构成评价问题的五个要素"></a>构成评价问题的五个要素</h2><p>被评价对象、评价指标、权重系数、综合评价模型、评价者</p><p>综合评价模型：构成综合评价函数</p><h2 id="综合评价的一般步骤"><a href="#综合评价的一般步骤" class="headerlink" title="综合评价的一般步骤"></a>综合评价的一般步骤</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731152928417-9661e6.png"></p><p>指标一致化处理：例如一个变量越大越好，另一个变量越小越好，要进行一致化处理，使得变量都超一个方向变好</p><h2 id="评价指标权重的计算"><a href="#评价指标权重的计算" class="headerlink" title="评价指标权重的计算"></a>评价指标权重的计算</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153018793-586bcb.png" alt="image-20220731153018793"></p><p>成对比较法：层次分析法</p><h2 id="指标规范化处理"><a href="#指标规范化处理" class="headerlink" title="指标规范化处理"></a>指标规范化处理</h2><h3 id="指标类型与量化"><a href="#指标类型与量化" class="headerlink" title="指标类型与量化"></a>指标类型与量化</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153253102-c61c3b.png" alt="image-20220731153253102"></p><h3 id="定量指标的一致化处理"><a href="#定量指标的一致化处理" class="headerlink" title="定量指标的一致化处理"></a>定量指标的一致化处理</h3><p>一般都往正向转化</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153442897-572ab7.png" alt="image-20220731153442897"></p><h4 id="对于极小型指标"><a href="#对于极小型指标" class="headerlink" title="对于极小型指标"></a>对于极小型指标</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153601080-457684.png" alt="image-20220731153601080"></p><h4 id="对于居中型指标"><a href="#对于居中型指标" class="headerlink" title="对于居中型指标"></a>对于居中型指标</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153743048-fed64d.png" alt="image-20220731153743048"></p><p>m是最小值，M是最大值</p><h3 id="指标无量纲处理"><a href="#指标无量纲处理" class="headerlink" title="指标无量纲处理"></a>指标无量纲处理</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153855687-6cb55b.png" alt="image-20220731153855687"></p><h4 id="向量归一化"><a href="#向量归一化" class="headerlink" title="向量归一化"></a>向量归一化</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731153915306-92e9b3.png" alt="image-20220731153915306"></p><p>最后数据都处于0-1中</p><h4 id="极差变换法"><a href="#极差变换法" class="headerlink" title="极差变换法"></a>极差变换法</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154043053-581762.png" alt="image-20220731154043053"></p><p>分布均衡</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154152584-83e0bd.png" alt="image-20220731154152584"></p><p><strong>当逆向指标这样转化之后，就转化为正向指标</strong></p><h4 id="线性比例变换"><a href="#线性比例变换" class="headerlink" title="线性比例变换"></a>线性比例变换</h4><h2 id="常用的综合评价方法"><a href="#常用的综合评价方法" class="headerlink" title="常用的综合评价方法"></a><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154437259-e866ec.png" alt="image-20220731154437259">常用的综合评价方法</h2><h3 id="线性加权综合法"><a href="#线性加权综合法" class="headerlink" title="线性加权综合法"></a>线性加权综合法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154707348-2d853f.png" alt="image-20220731154707348"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154724346-9f5c2d.png" alt="image-20220731154724346"></p><h3 id="非线性加权综合法"><a href="#非线性加权综合法" class="headerlink" title="非线性加权综合法"></a>非线性加权综合法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154829834-c7564f.png" alt="image-20220731154829834"></p><p>指标之间有关联性</p><h3 id="逼近理想点TOPSIS方法"><a href="#逼近理想点TOPSIS方法" class="headerlink" title="逼近理想点TOPSIS方法"></a>逼近理想点<code>TOPSIS</code>方法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731154939135-2f03c2.png" alt="image-20220731154939135"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731155034871-2fbe7b.png" alt="image-20220731155034871"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731155211783-d6aff3.png" alt="image-20220731155211783"></p><p>致命问题：理想值的取值</p><p>理想值一般取得每一个指标的最大值（最优值）</p><h2 id="模糊综合评价-1"><a href="#模糊综合评价-1" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731155532795-5b2882.png" alt="image-20220731155532795"></p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731160825975-5bba92.png" alt="image-20220731160825975"></p><p>对于多级模糊评价，可用分级，先将下级进行模糊评价，然后再进行总的评价</p><h2 id="灰色关联分析"><a href="#灰色关联分析" class="headerlink" title="灰色关联分析"></a>灰色关联分析</h2><p>小样本，样本一般少于20个</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175108831-61bd18.png" alt="image-20220731175108831"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175404718-346ca5.png" alt="image-20220731175404718"></p><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175739466-74c076.png" alt="image-20220731175739466"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175810803-203c34.png" alt="image-20220731175810803"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175818417-b3317b.png" alt="image-20220731175818417"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175849188-867d49.png" alt="image-20220731175849188"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175858296-8adccd.png" alt="image-20220731175858296"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731175905317-0edb02.png" alt="image-20220731175905317"></p><h1 id="元胞自动机模型及其应用"><a href="#元胞自动机模型及其应用" class="headerlink" title="元胞自动机模型及其应用"></a>元胞自动机模型及其应用</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731184206077-0551c4.png" alt="image-20220731184206077"></p><p>适合空间复杂的系统</p><p>是一种方法框架</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731184517994-8ec5a2.png" alt="image-20220731184517994"></p><h2 id="元胞自动机的构成"><a href="#元胞自动机的构成" class="headerlink" title="元胞自动机的构成"></a>元胞自动机的构成</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731185543389-3d8c2f.png" alt="image-20220731185543389"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731185757742-fdbba0.png" alt="image-20220731185757742"></p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731190957312-0d5390.png" alt="image-20220731190957312"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731191343966-35caf7.png" alt="image-20220731191343966"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731191448392-4fad76.png" alt="image-20220731191448392"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731191555114-f0c127.png" alt="image-20220731191555114"></p><h3 id="对于元胞空间的划分"><a href="#对于元胞空间的划分" class="headerlink" title="对于元胞空间的划分"></a>对于元胞空间的划分</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731191152061-95644f.png" alt="image-20220731191152061"></p><h2 id="元胞自动机的特性"><a href="#元胞自动机的特性" class="headerlink" title="元胞自动机的特性"></a>元胞自动机的特性</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731191640838-8d9eab.png" alt="image-20220731191640838"></p><h2 id="应用的思想"><a href="#应用的思想" class="headerlink" title="应用的思想"></a>应用的思想</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731191737825-098a21.png" alt="image-20220731191737825"></p><h2 id="初等元胞自动机"><a href="#初等元胞自动机" class="headerlink" title="初等元胞自动机"></a>初等元胞自动机</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731192049923-fec65c.png" alt="image-20220731192049923"></p><h2 id="元胞自动机的演化行为的统计特征"><a href="#元胞自动机的演化行为的统计特征" class="headerlink" title="元胞自动机的演化行为的统计特征"></a>元胞自动机的演化行为的统计特征</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220731193021938-ee62f3.png" alt="image-20220731193021938"></p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a><code>Dijkstra</code>算法</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803143919000-8527e9.png" alt="image-20220803143919000"></p><h2 id="Flod算法"><a href="#Flod算法" class="headerlink" title="Flod算法"></a><code>Flod</code>算法</h2><p>求任意两顶点之间的最短</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803145004874-2bf55a.png" alt="image-20220803145004874"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803145147473-e88a12.png" alt="image-20220803145147473"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803145527686-93adc2.png" alt="image-20220803145527686"></p><p>基本思想就是插入点然后求最短路径</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803150737646-162b69.png" alt="image-20220803150737646"></p><h2 id="旅行售货员问题"><a href="#旅行售货员问题" class="headerlink" title="旅行售货员问题"></a>旅行售货员问题</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220803154410862-14f9eb.png" alt="image-20220803154410862"></p><p>去寻找一个最优圈</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>异常值</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805190519703-9f1342.png" alt="image-20220805190519703"></p><p>缺失值</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805190535133-419f81.png" alt="image-20220805190535133"></p><h2 id="对数据进行规范化"><a href="#对数据进行规范化" class="headerlink" title="对数据进行规范化"></a>对数据进行规范化</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805191641470-283ae0.png" alt="image-20220805191641470"></p><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>主要处理缺失值以及异常值的处理</p><h3 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805192000285-1d6ba6.png" alt="image-20220805192000285"></p><p>对于最近临插法可以使用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805192206291-201eff.png" alt="image-20220805192206291"></p><p>在这里面，回归方法过于繁琐，不推荐使用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805192338374-de1081.png" alt="image-20220805192338374"></p><p>推荐使用插值法，</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805192435636-206b7b.png" alt="image-20220805192435636"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805192551794-fb2717.png" alt="image-20220805192551794"></p><h2 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805192736585-7b3eba.png" alt="image-20220805192736585"></p><h4 id="可以用箱形图的方式进行判断"><a href="#可以用箱形图的方式进行判断" class="headerlink" title="可以用箱形图的方式进行判断"></a>可以用箱形图的方式进行判断</h4><p>在<code>matlab</code>中的函数为<code>boxpolt</code></p><h4 id="离群值的计算方法"><a href="#离群值的计算方法" class="headerlink" title="离群值的计算方法"></a>离群值的计算方法</h4><p>可以画出来二维图观察</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805193326087-1560af.png" alt="image-20220805193326087"></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>对于特征维度的剔除</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805193918395-180c31.png" alt="image-20220805193918395"></p><p>一般国赛中常用的方法是过滤法</p><p>在进行分析的时候可以使用协方差</p><p>协方差是展示两个变量的关联程度</p><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805194524672-e278dc.png" alt="image-20220805194524672"></p><p> 在协方差变大的时候，接近一或者负一，那么可以将两个变量对一个变量进行替换</p><p>首先得出数据的协方差矩阵，然后利用主成分分析法进行计算，将数据压缩成几个数据，并且要对数据进行解释</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805195140083-a1fe5e.png" alt="image-20220805195140083"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220805195149512-ec52cb.png" alt="image-20220805195149512"></p><h4 id="matlab主成分分析的时候，首先需要求出来协方差矩阵，然后利用函数pcacov来进行处理"><a href="#matlab主成分分析的时候，首先需要求出来协方差矩阵，然后利用函数pcacov来进行处理" class="headerlink" title="matlab主成分分析的时候，首先需要求出来协方差矩阵，然后利用函数pcacov来进行处理"></a><code>matlab</code>主成分分析的时候，首先需要求出来协方差矩阵，然后利用函数pcacov来进行处理</h4><p>然后生成的数<code>explained</code>是数据的贡献率，一般累计贡献率大于85即可</p><h1 id="聚类分析基础入门与实践"><a href="#聚类分析基础入门与实践" class="headerlink" title="聚类分析基础入门与实践"></a>聚类分析基础入门与实践</h1><p>将相同的数据集或者将一个数据集分成若干组的一个过程，分完后组内的数据相似性是比较大的，相似与不相似是基于数据描述属性的取值来确定的，通常利用各数据对象间的距离来表示 <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131157569-69c1e4.png" alt="image-20220806131157569"></p><p>聚类是没有标准的，分类往往是有一个标准</p><h2 id="聚类分析的应用"><a href="#聚类分析的应用" class="headerlink" title="聚类分析的应用"></a>聚类分析的应用</h2><p> <img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131245768-eaafab.png" alt="image-20220806131245768"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131320850-ef3cb2.png" alt="image-20220806131320850"></p><h2 id="相似度的度量——样本间"><a href="#相似度的度量——样本间" class="headerlink" title="相似度的度量——样本间"></a>相似度的度量——样本间</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131552976-74c401.png" alt="image-20220806131552976"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131640880-5587d2.png" alt="image-20220806131640880"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131725598-f1d36b.png" alt="image-20220806131725598"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131740649-ffcaed.png" alt="image-20220806131740649"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806131746040-c0407c.png" alt="image-20220806131746040"></p><p>算出来的距离是每个样本之间的距离，</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806132220287-977c13.png" alt="image-20220806132220287"></p><h2 id="相似度度量——指标之间的距离"><a href="#相似度度量——指标之间的距离" class="headerlink" title="相似度度量——指标之间的距离"></a>相似度度量——指标之间的距离</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806132450576-01e483.png" alt="image-20220806132450576"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806132503102-205518.png" alt="image-20220806132503102"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806132740642-6ba27e.png" alt="image-20220806132740642"></p><p>对于<code>matlab</code>计算</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806132833138-de7945.png" alt="image-20220806132833138"></p><h2 id="样本分完之后的类，对于类之间的距离"><a href="#样本分完之后的类，对于类之间的距离" class="headerlink" title="样本分完之后的类，对于类之间的距离"></a>样本分完之后的类，对于类之间的距离</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806133101154-f4f9f7.png" alt="image-20220806133101154"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806133236852-928d84.png" alt="image-20220806133236852"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806133200895-2219e6.png" alt="image-20220806133200895"></p><h2 id="聚类谱系图的步骤"><a href="#聚类谱系图的步骤" class="headerlink" title="聚类谱系图的步骤"></a>聚类谱系图的步骤</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806133356871-4267d2.png" alt="image-20220806133356871"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806133504754-17506e.png" alt="image-20220806133504754"></p><p>当两个样本合成一个后，要计算合成的样本和其他样本的距离，分别计算着两个样本和其他样本的距离，然后取得最小值</p><h3 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a><code>Matlab</code>实现</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806134244831-97481d.png" alt="image-20220806134244831"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806134256277-4c2c80.png" alt="image-20220806134256277"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806134332339-cd9ea2.png" alt="image-20220806134332339"></p><h2 id="K-平均聚类算法"><a href="#K-平均聚类算法" class="headerlink" title="K-平均聚类算法"></a>K-平均聚类算法</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806135610184-25f46a.png" alt="image-20220806135610184"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806135754040-a1e426.png" alt="image-20220806135754040"></p><h1 id="BP神经网络基本原理间接"><a href="#BP神经网络基本原理间接" class="headerlink" title="BP神经网络基本原理间接"></a><code>BP</code>神经网络基本原理间接</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806140633102-20a8f3.png" alt="image-20220806140633102"></p><p>输入——处理——输出</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806142859300-3c4c9a.png" alt="image-20220806142859300"></p><h2 id="建立和应用神经网络的步骤"><a href="#建立和应用神经网络的步骤" class="headerlink" title="建立和应用神经网络的步骤"></a>建立和应用神经网络的步骤</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806143008613-ac63d1.png" alt="image-20220806143008613"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806144033608-c46bb4.png" alt="image-20220806144033608"></p><p> 不用考虑x与ｙ的关系，用权来进行表示，不知道数据之间的构建关系　</p><p>阈值：神经网络能产生刺激的一个临界值</p><h2 id="人工神经元的模型"><a href="#人工神经元的模型" class="headerlink" title="人工神经元的模型"></a>人工神经元的模型</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806144702965-177754.png" alt="image-20220806144702965"></p><p>一般ｎｅｔ大于０才可以进行激活</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806144936250-d2b45d.png" alt="image-20220806144936250"></p><p>阈值函数很少用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806145001455-30c85c.png" alt="image-20220806145001455"></p><p>　　</p><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806154348948-571588.png" alt="image-20220806154348948"></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806154423232-9e4429.png" alt="image-20220806154423232"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806154516076-30b176.png" alt="image-20220806154516076"></p><p>有导师：给你数据有输入以及输出</p><p>无导师：只给了输入，没有给输出</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806154707067-951335.png" alt="image-20220806154707067"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806154839840-7a41df.png"></p><h3 id="BP算法"><a href="#BP算法" class="headerlink" title="BP算法"></a>BP算法</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806154911120-116760.png" alt="image-20220806154911120"></p><p>线与线之间连接是表示权值</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806155027051-4ae87e.png" alt="image-20220806155027051"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806155131020-0f5730.png" alt="image-20220806155131020"></p><p>对于权值的修正</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806160008648-2d24e5.png" alt="image-20220806160008648"></p><h3 id="预测、评价、分类的问题"><a href="#预测、评价、分类的问题" class="headerlink" title="预测、评价、分类的问题"></a>预测、评价、分类的问题</h3><h3 id="matlab使用函数"><a href="#matlab使用函数" class="headerlink" title="ｍａｔｌａｂ使用函数"></a><code>ｍａｔｌａｂ</code>使用函数</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806163601203-b0007f.png" alt="image-20220806163601203"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806163740580-1352ce.png" alt="image-20220806163740580"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806164514701-e60be3.png" alt="image-20220806164514701"></p><p>在这个里面ｍ是输入的参数维度</p><p>ｃ参数是输出评价的参数维度</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806164657124-0cf0ce.png" alt="image-20220806164657124"></p><h1 id="马尔可夫算法原理——预测"><a href="#马尔可夫算法原理——预测" class="headerlink" title="马尔可夫算法原理——预测"></a>马尔可夫算法原理——预测</h1><p>随机序列过程</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806183140608-356377.png" alt="image-20220806183140608"></p><p>已知现在，且来与过去无关，描述这类随机现象的数学模型称为马尔可夫模型</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806183302665-16597819830581-6516cf.png" alt="image-20220806183302665"></p><p>即无记忆性，独立的</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806183635107-16597821954682-ecf00e.png" alt="image-20220806183635107"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806183759697-b9049d.png" alt="image-20220806183759697"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806183814361-aec2a4.png" alt="image-20220806183814361"></p><p> 时齐性：概率跟时间没有关系</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806184750889-16597828713953-a3c99e.png" alt="image-20220806184750889"></p><h2 id="马氏链的基本方程"><a href="#马氏链的基本方程" class="headerlink" title="马氏链的基本方程"></a>马氏链的基本方程</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806185211689-18c0c6.png"></p><h3 id="马氏链两个重要类型"><a href="#马氏链两个重要类型" class="headerlink" title="马氏链两个重要类型"></a>马氏链两个重要类型</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806185244606-683c07.png" alt="image-20220806185244606"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220806185500880-20d43b.png" alt="image-20220806185500880"></p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模论文</title>
      <link href="/posts/30795.html"/>
      <url>/posts/30795.html</url>
      
        <content type="html"><![CDATA[<p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811094519943-412b31.png" alt="image-20220811094519943"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811094707637-beaf27.png" alt="image-20220811094707637"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811094838397-16601825191741-a33557.png" alt="image-20220811094838397"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811095829316-65a07d.png" alt="image-20220811095829316"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811100027370-1b62cf.png" alt="image-20220811100027370"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811100237560-09bee9.png" alt="image-20220811100237560"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811100829739-d2b8b4.png" alt="image-20220811100829739"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811101032969-47f96f.png" alt="image-20220811101032969"></p><h1 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811101354928-94efa2.png" alt="image-2022081101354928"></h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811101608750-23cb54.png" alt="image-20220811101608750"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811101624904-8f1563.png" alt="image-20220811101624904"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811101735291-e5bc81.png" alt="image-20220811101735291"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811101809273-6ce180.png" alt="image-20220811101809273"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811102000459-220857.png" alt="image-20220811102000459"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811102120021-79ff8b.png" alt="image-20220811102120021"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811102238230-f67292.png" alt="image-20220811102238230"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811102335310-30c27d.png" alt="image-20220811102335310"></p><h1 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811102427851-e70cfa.png" alt="image-20220811102427851"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811103137436-83d6a5.png" alt="image-20220811103137436"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811103827371-abea4c.png" alt="image-20220811103827371"></p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811103927266-8578c5.png" alt="image-20220811103927266"></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811104044390-57e1b1.png" alt="image-20220811104044390"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811104208706-9a0c12.png" alt="image-20220811104208706"></p><h3 id="不足一般都不写"><a href="#不足一般都不写" class="headerlink" title="不足一般都不写"></a>不足一般都不写</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811104312999-16601857933692-223af7.png" alt="image-20220811104312999"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811104335221-4ceabe.png" alt="image-20220811104335221"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811115445999-d33e2b.png" alt="image-20220811115445999"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811115453381-25f57e.png" alt="image-20220811115453381"></p><p>摘要一般最后写，整个团队参与</p><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811115654384-3bc539.png" alt="image-20220811115654384"></p><h1 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811115805041-fcd1ed.png" alt="image-20220811115805041"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120004961-4f2de5.png" alt="image-20220811120004961"></p><h1 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120050797-11ee71.png" alt="image-20220811120050797"></p><h1 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120121699-5dead6.png" alt="image-20220811120121699"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120202700-ba3e70.png" alt="image-20220811120202700"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120249839-16601905704403-3ffc99.png" alt="image-20220811120249839"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120330244-4cccba.png" alt="image-20220811120330244"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811120342886-7f1d28.png" alt="image-20220811120342886"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811105858389-235695.png" alt="image-20220811105858389"></p><h1 id="建立模型的方法"><a href="#建立模型的方法" class="headerlink" title="建立模型的方法"></a>建立模型的方法</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811105919192-cff761.png" alt="image-20220811105919192"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811110033804-1fe6e5.png" alt="image-20220811110033804"></p><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811110225803-3fba6a.png" alt="image-20220811110225803"></p><h1 id="结果表示"><a href="#结果表示" class="headerlink" title="结果表示"></a>结果表示</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811110256459-314b74.png" alt="image-20220811110256459"></p><h1 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811110531109-31204e.png" alt="image-20220811110531109"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811110659399-fbd2c6.png" alt="image-20220811110659399"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811110912258-c0da05.png" alt="image-20220811110912258"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811111134264-0a789c.png" alt="image-20220811111134264"></p><h1 id="后面的短文回复"><a href="#后面的短文回复" class="headerlink" title="后面的短文回复"></a>后面的短文回复</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811111424150-fe1194.png" alt="image-20220811111424150"></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811111716195-b03a13.png" alt="image-20220811111716195"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220811114335913-201d85.png" alt="image-20220811114335913"></p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex使用</title>
      <link href="/posts/23163.html"/>
      <url>/posts/23163.html</url>
      
        <content type="html"><![CDATA[<h1 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809135121833-d922af.png" alt="image-20220809135121833"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809135154892-3e54c2.png" alt="image-20220809135154892"></p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;   中文包导入</span><br><span class="line"><span class="keyword">\title</span>&#123;title&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;names&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;2022.8.9&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="基本结构——在begin中添加"><a href="#基本结构——在begin中添加" class="headerlink" title="基本结构——在begin中添加"></a>基本结构——在begin中添加</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809135316708-ed69ba.png" alt="image-20220809135316708"></p><p>对于一个文件只有一个begin和end</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\maketitle</span> 标题显示 </span><br><span class="line"><span class="keyword">\tableofcontents</span>   目录生成</span><br><span class="line"><span class="keyword">\newpage</span>新页</span><br><span class="line"><span class="keyword">\par</span>新段落</span><br></pre></td></tr></table></figure><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\underline</span>&#123;&#125; 为其中的内容添加下划线</span><br><span class="line"><span class="keyword">\emph</span>&#123;&#125; 文字变成斜体表示强调</span><br></pre></td></tr></table></figure><h2 id="分页与断行"><a href="#分页与断行" class="headerlink" title="分页与断行"></a>分页与断行</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">~ 用来表示一个不断行的空格，通常使用在英文人名等</span><br><span class="line"><span class="keyword">\\</span>   or  <span class="keyword">\newline</span>    这两个命令都可以用来表示断行，开辟一个新行，顶格写，新段落会空出来两个字符</span><br><span class="line"><span class="keyword">\par</span>  开辟一个新段落</span><br><span class="line"><span class="keyword">\newpage</span>   or  <span class="keyword">\claerpage</span>  新页</span><br><span class="line">若双栏排版时候，<span class="keyword">\newpage</span>只起到另起一栏的作用</span><br></pre></td></tr></table></figure><h2 id="分小节和章节"><a href="#分小节和章节" class="headerlink" title="分小节和章节"></a>分小节和章节</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809150717573-29ed16.png" alt="image-20220809150717573"></p><h2 id="对于标题"><a href="#对于标题" class="headerlink" title="对于标题"></a>对于标题</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809150857153-83087f.png" alt="image-20220809150857153"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">enumerate   有序列表</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"> <span class="keyword">\item</span> </span><br><span class="line"> <span class="keyword">\item</span></span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">itemize   无序列表</span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"> <span class="keyword">\item</span> </span><br><span class="line"> <span class="keyword">\item</span></span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line">列表项目展示：</span><br><span class="line"> <span class="keyword">\item</span> </span><br><span class="line"> <span class="keyword">\item</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;verbatim&#125;<span class="string"></span></span><br><span class="line"><span class="string">代码块 </span></span><br><span class="line"><span class="string"></span><span class="keyword">\end</span>&#123;verbatim&#125;</span><br></pre></td></tr></table></figure><h2 id="图片放置"><a href="#图片放置" class="headerlink" title="图片放置"></a>图片放置</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809165059018-abec7d.png" alt="image-20220809165059018"></p><p>其中【h】放置最多</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[h]</span><br><span class="line"><span class="keyword">\centering</span>  表格居中</span><br><span class="line"><span class="keyword">\caption</span>&#123;table&#125; 表格标题</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 对于表格设置：l表示左 c居中  r靠右</span><br><span class="line"> |表示竖线 <span class="keyword">\hline</span> 表示横线</span><br><span class="line"> ||双竖线 <span class="keyword">\hline</span><span class="keyword">\hline</span>双横线</span><br><span class="line"> 对于表格中数据填写用<span class="built_in">&amp;</span>隔开</span><br><span class="line"> <span class="keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|&#125;</span><br><span class="line">     <span class="keyword">\hline</span></span><br><span class="line">     a<span class="built_in">&amp;</span>b<span class="keyword">\\</span><span class="keyword">\hline</span></span><br><span class="line">     对于<span class="keyword">\\</span><span class="keyword">\hline</span> 表示的是换行然后加横线</span><br><span class="line">     <span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure><p>对于网站可以直接生成代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.tablesgenerator.com/</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>本身不支持插图功能，需要有<code>graphicx</code>宏包导入辅助支持</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line">导言引入这个包</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[h]</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125;  调整图片大小以及位置</span><br><span class="line"><span class="keyword">\caption</span>&#123;名字&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><h3 id="两个图片并排放"><a href="#两个图片并排放" class="headerlink" title="两个图片并排放"></a>两个图片并排放</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[h]</span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.5<span class="keyword">\linewidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125;  调整图片大小以及位置</span><br><span class="line">        <span class="keyword">\caption</span>&#123;名字&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.5<span class="keyword">\linewidth</span>&#125; 这里面参数显示图片用一行的一半</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125;  调整图片大小以及位置</span><br><span class="line">        <span class="keyword">\caption</span>&#123;名字&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><h3 id="对于四个图片分开放置"><a href="#对于四个图片分开放置" class="headerlink" title="对于四个图片分开放置"></a>对于四个图片分开放置</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">首先导入包 <span class="keyword">\usepackage</span>&#123;subfigure&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\subfigure</span>[name]&#123;</span><br><span class="line"> <span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125; <span class="keyword">\label</span>&#123;1&#125; 调整图片大小以及位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\quad</span>  一个空格</span><br><span class="line"><span class="keyword">\subfigure</span>[name]&#123;</span><br><span class="line"> <span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125; <span class="keyword">\label</span>&#123;2&#125; 调整图片大小以及位置</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\quad</span>  一个空格</span><br><span class="line"><span class="keyword">\subfigure</span>[name]&#123;</span><br><span class="line"> <span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125; <span class="keyword">\label</span>&#123;3&#125; 调整图片大小以及位置</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\quad</span>  一个空格</span><br><span class="line"><span class="keyword">\subfigure</span>[name]&#123;</span><br><span class="line"> <span class="keyword">\includegraphics</span>[width=10cm,height=8cm]&#123;图片位置&#125; <span class="keyword">\label</span>&#123;4&#125; 调整图片大小以及位置</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">\caption</span>&#123;名字&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><h3 id="图片缩放命令"><a href="#图片缩放命令" class="headerlink" title="图片缩放命令"></a>图片缩放命令</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[scale=0.03]&#123;位置&#125;</span><br><span class="line">变成原来的图片的多少倍</span><br></pre></td></tr></table></figure><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="行内公式，使用-符号"><a href="#行内公式，使用-符号" class="headerlink" title="行内公式，使用$符号"></a>行内公式，使用$符号</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="built_in">$</span>f(t)=cos(<span class="keyword">\omega</span> t + <span class="keyword">\varphi</span>)<span class="built_in">$</span></span><br><span class="line">没必要去背，编译器自带</span><br></pre></td></tr></table></figure><h3 id="公式环境包裹——自动编号"><a href="#公式环境包裹——自动编号" class="headerlink" title="公式环境包裹——自动编号"></a>公式环境包裹——自动编号</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">f(x)=ax+b</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h3 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">引入包</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a<span class="built_in">&amp;</span>=b+c<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>=d+e</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line">公式用<span class="built_in">&amp;</span>来进行对齐</span><br></pre></td></tr></table></figure><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810142352777-0a1899.png" alt="image-20220810142352777"></p><h3 id="也可用来写分段函数"><a href="#也可用来写分段函数" class="headerlink" title="也可用来写分段函数"></a>也可用来写分段函数</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810142510492-e95680.png" alt="image-20220810142510492"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810143026039-81f3c2.png" alt="image-20220810143026039"></p><h1 id="Latex宏包"><a href="#Latex宏包" class="headerlink" title="Latex宏包"></a>Latex宏包</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809141744729-e932d2.png" alt="image-20220809141744729"></p><h1 id="对于团队合作"><a href="#对于团队合作" class="headerlink" title="对于团队合作"></a>对于团队合作</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809142213471-b645a1.png" alt="image-20220809142213471"></p><h1 id="对于中文排版"><a href="#对于中文排版" class="headerlink" title="对于中文排版"></a>对于中文排版</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220809142240940-e0a7e6.png" alt="image-20220809142240940"></p><h1 id="字符排版"><a href="#字符排版" class="headerlink" title="字符排版"></a>字符排版</h1><p>对于latex中的字符，行末的回车视为一个空格，但是连续两个回车就是一个空行，多个空行被认识为一个空行</p><p>也可以使用\par命令</p><p>对于%表示注释</p><p>$^_用于排版数学公式</p><p>&amp;用于排班表格</p><p>如果要输入以上字符，需要带上反斜线</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">eg：<span class="keyword">\#</span><span class="keyword">\%</span><span class="keyword">\$</span></span><br><span class="line"></span><br><span class="line">对于要输入一个字符串<span class="keyword">\text</span>&#123;string&#125;</span><br></pre></td></tr></table></figure><h1 id="字体改变"><a href="#字体改变" class="headerlink" title="字体改变"></a>字体改变</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810143120623-b1a6dd.png" alt="image-20220810143120623"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810143240915-32d562.png" alt="image-20220810143240915"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810143308242-9d4259.png" alt="image-20220810143308242"></p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">首先需要导入包</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125;</span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;fancy&#125;</span><br><span class="line"><span class="keyword">\lhead</span>&#123;&#125; 页眉的左边</span><br><span class="line"><span class="keyword">\chead</span>&#123;&#125; 页眉的中边</span><br><span class="line"><span class="keyword">\rhead</span>&#123;&#125; 页眉的右边</span><br><span class="line"><span class="keyword">\lfoot</span>&#123;&#125; 页脚</span><br><span class="line"><span class="keyword">\cfoot</span>&#123;<span class="keyword">\thepage</span>&#125; 页脚中间显示页数</span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\headrulewidth</span>&#125;&#123;0.4pt&#125; 设置页眉上有一条横线</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><code>BIBTEX</code></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810143949736-daf198.png" alt="image-20220810143949736"></p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>首先进行引用</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810144047498-3b91af.png" alt="image-20220810144047498"></p><p>然后保存到bib文件中</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810144107353-351e03.png" alt="image-20220810144107353"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810144131085-0dfadc.png" alt="image-20220810144131085"></p><p>之后再导言区引入样式</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810144327278-17b5ec.png" alt="image-20220810144327278"></p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\bibliographystyle</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220810144425764-d85a90.png" alt="image-20220810144425764"></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端遗忘</title>
      <link href="/posts/29954.html"/>
      <url>/posts/29954.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端遗忘"><a href="#前端遗忘" class="headerlink" title="前端遗忘"></a>前端遗忘</h1><h2 id="字体居中"><a href="#字体居中" class="headerlink" title="字体居中"></a>字体居中</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于对于一个块元素，都可以试试，整个占据一整行</span><br><span class="line">对于字体的居中，ul和h1在进行居中的时候，块元素居中，即包裹不仅仅包括自己，可以采用这种方法</span><br><span class="line">  text-align: center;</span><br></pre></td></tr></table></figure><h2 id="表格线条合并"><a href="#表格线条合并" class="headerlink" title="表格线条合并"></a>表格线条合并</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对每一个单元格和表格，都有边框，对他们的边框进行重合</span><br><span class="line">  border-collapse: collapse;</span><br></pre></td></tr></table></figure><h2 id="利用Jquery对集合遍历"><a href="#利用Jquery对集合遍历" class="headerlink" title="利用Jquery对集合遍历"></a>利用Jquery对集合遍历</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(rowData).each(function (index, Student) &#123;&#125;）</span><br></pre></td></tr></table></figure><h2 id="表单参数获取"><a href="#表单参数获取" class="headerlink" title="表单参数获取"></a>表单参数获取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let params = $(&quot;#stuAddForm&quot;).serialize();</span><br></pre></td></tr></table></figure><h2 id="清空表单"><a href="#清空表单" class="headerlink" title="清空表单"></a>清空表单</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#stuAddForm&quot;)[0].reset();</span><br></pre></td></tr></table></figure><h2 id="ajax设置"><a href="#ajax设置" class="headerlink" title="ajax设置"></a>ajax设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contentType: &#x27;application/json&#x27;,设置传递的对象是JSON对象</span><br><span class="line">JSON.stringify() JSON对象转化为字符串</span><br></pre></td></tr></table></figure><h2 id="获取表格的值"><a href="#获取表格的值" class="headerlink" title="获取表格的值"></a>获取表格的值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;#stuAddForm input[name=&#x27;sname&#x27;]&quot;).val();</span><br></pre></td></tr></table></figure><h2 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据点击删除按钮得到任务的id值。</span><br><span class="line">//在集合中匹配id，从集合中删除</span><br><span class="line">this.todoList = this.todoList.filter(obj =&gt; &#123;</span><br><span class="line">    //其中obj是集合中的每一个元素</span><br><span class="line">    if (obj.id !== id) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">对一个list进行遍历，用filter,其中obj指的是每一个对象，如果return了obj,相当于这个数据被保存下来，没被返回，那么就相当于没有保存下来</span><br></pre></td></tr></table></figure><h2 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //遍历集合，看哪一项的done属性为true</span><br><span class="line"> return this.todoList.reduce((pre, obj) =&gt; &#123;</span><br><span class="line"> return obj.done ? pre + 1 : pre;</span><br><span class="line"> &#125;, 0)</span><br><span class="line">//第二个参数是pre的初始值，初始值是0,然后进行下一次循环，每次都会对pre值进行更新，然后带入到下一次循环当中</span><br><span class="line">//里面的return 会当做下一次循环的传入值，直到最后一次循环，得到一个pre最终值，进行返回</span><br><span class="line"></span><br><span class="line">上面函数相当于计算obj.done中true的个数</span><br></pre></td></tr></table></figure><p>对象复制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作</title>
      <link href="/posts/2030.html"/>
      <url>/posts/2030.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>去网上搜索安装教程- -</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>去修改虚拟机的默认位置</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604113037232-80ef71.png" alt="image-20230604113037232"></p><h2 id="虚拟机操作"><a href="#虚拟机操作" class="headerlink" title="虚拟机操作"></a>虚拟机操作</h2><ol><li>创建虚拟机</li></ol><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps13-e6f9d5.jpg" alt="img"> </p><ol start="2"><li>导入、导出：可以把已经安装好的虚拟机导出，以后需要时再导入</li></ol><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps14-196ee0.jpg" alt="img"> </p><ol start="3"><li>备份、还原</li></ol><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps15-8eb6dc.jpg" alt="img"> </p><p>注意：初学者配置快照非常重要，如果linux中软件安装失败了，可以恢复到指定的快照版本再来一次，否则删除不干净需要重新安装lunux，非常麻烦；</p><h1 id="CentOs安装"><a href="#CentOs安装" class="headerlink" title="CentOs安装"></a>CentOs安装</h1><h2 id="初始一个虚拟机"><a href="#初始一个虚拟机" class="headerlink" title="初始一个虚拟机"></a>初始一个虚拟机<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142457508-eaf395.png" alt="image-20230604142457508"></h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142521643-7d966c.png" alt="image-20230604142521643"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142601171-d2bbe5.png" alt="image-20230604142601171"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142630474-8fd6f0.png" alt="image-20230604142630474"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142721715-542561.png" alt="image-20230604142721715"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142811272-88cd3e.png" alt="image-20230604142811272"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142913812-a83e6b.png" alt="image-20230604142913812"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604142935890-e2963f.png" alt="image-20230604142935890"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143000913-3efbcb.png" alt="image-20230604143000913"></p><p>采用推荐的来</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143034617-d534c6.png" alt="image-20230604143034617"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143051004-26d3c2.png" alt="image-20230604143051004"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143110961-5b4868.png" alt="image-20230604143110961"></p><p>注意这里的磁盘大小最小为9GB，不可以小于9GB</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143154153-5e15aa.png" alt="image-20230604143154153"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143224037-f3619a.png" alt="image-20230604143224037"></p><p>这样就创建完成一个虚拟机了</p><h2 id="配置操作系统镜像文件"><a href="#配置操作系统镜像文件" class="headerlink" title="配置操作系统镜像文件"></a>配置操作系统镜像文件</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143637114-d88bc5.png" alt="image-20230604143637114"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143722558-812065.png" alt="image-20230604143722558"></p><h2 id="Centos7系统安装过程"><a href="#Centos7系统安装过程" class="headerlink" title="Centos7系统安装过程"></a>Centos7系统安装过程</h2><h3 id="打开后会先显示是否装配Centos7-直接回车即可"><a href="#打开后会先显示是否装配Centos7-直接回车即可" class="headerlink" title="打开后会先显示是否装配Centos7 直接回车即可"></a>打开后会先显示是否装配Centos7 直接回车即可</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604143907996-65a88b.png" alt="image-20230604143907996"> </p><p>注意：点击会进入Linux系统（鼠标消失），按住Ctrl+Alt退出（鼠标出现）</p><h3 id="选择中文"><a href="#选择中文" class="headerlink" title="选择中文"></a>选择中文</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144114062-a3818b.png" alt="image-20230604144114062"></p><h3 id="最小安装"><a href="#最小安装" class="headerlink" title="最小安装"></a>最小安装</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144503591-f9c75a.png" alt="image-20230604144503591"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144521102-e7c040.png" alt="image-20230604144521102"></p><h3 id="安装源"><a href="#安装源" class="headerlink" title="安装源"></a>安装源</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144536799-f31420.png" alt="image-20230604144536799"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144613832-f4a499.png" alt="image-20230604144613832"></p><h3 id="安装位置"><a href="#安装位置" class="headerlink" title="安装位置"></a>安装位置</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144654151-3d53be.png" alt="image-20230604144654151"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144705891-ff06df.png" alt="image-20230604144705891"></p><h3 id="网络和主机名称"><a href="#网络和主机名称" class="headerlink" title="网络和主机名称"></a>网络和主机名称</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144749092-d4a23c.png" alt="image-20230604144749092"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604144918849-e2de89.png" alt="image-20230604144918849"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果忘记开启，或者开启了但是系统执行ip addr看不到ip地址或者 ping www.baidu.com 不通该怎么办</span><br><span class="line"><span class="number">1.</span>进入网络配置文件    </span><br><span class="line">cd /etc/sysconfig/network-scripts/</span><br><span class="line"><span class="number">2.</span>打开文件编辑   vi ifcfg-ens33 </span><br><span class="line"> ONBOOT=<span class="string">&quot;yes&quot;</span>   ----如果是no那么就是没有开启</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>输入i 进行编辑</span><br><span class="line"><span class="number">4.</span>改成yes后  Esc 完成后输入:wq</span><br><span class="line"><span class="number">5.</span>重启网络 </span><br><span class="line">    systemctl restart network.service</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604193431105-7554c9.png" alt="image-20230604193431105"></p><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604145000357-8eaff3.png" alt="image-20230604145000357"></p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604145021745-c81b3a.png" alt="image-20230604145021745"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604145052449-186d8a.png" alt="image-20230604145052449"></p><p>如果提示密码太弱，点完成没用，就点两次，点一次可能没用</p><h3 id="创建用户–可以创建也可以不用，是别人来进行访问的"><a href="#创建用户–可以创建也可以不用，是别人来进行访问的" class="headerlink" title="创建用户–可以创建也可以不用，是别人来进行访问的"></a>创建用户–可以创建也可以不用，是别人来进行访问的</h3><p>注意：这里建议还是新建一个自己定义的用户，如果不新建，在进入系统时还是会进入欢迎页面【gnome-initial-setup】新建用户，步骤反而繁琐；</p><p>注意：密码设置太简单，会有警告，可以忽略，点两次完成即可忽略警告，继续执行；</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604145249681-04436d.png" alt="image-20230604145249681"></p><h2 id="安装后配置"><a href="#安装后配置" class="headerlink" title="安装后配置"></a>安装后配置</h2><h3 id="登录—输入密码的时候没有框框"><a href="#登录—输入密码的时候没有框框" class="headerlink" title="登录—输入密码的时候没有框框"></a>登录—输入密码的时候没有框框</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604145856363-f79b9e.png" alt="image-20230604145856363"></p><h3 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h3><p>ifconfig——-不可用</p><p>ip addr—进行查询</p><p>出现错误上面可以进行解决，打开网络net</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604150159259-704350.png" alt="image-20230604150159259"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604150337091-b15a75.png" alt="image-20230604150337091"></p><p>点击上面的也可以对网络进行设置，但一般不修改</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604150414791-765eb4.png" alt="image-20230604150414791"></p><h3 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h3><p>ping 网络地址</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604150527303-921cbf.png" alt="image-20230604150527303"></p><h3 id="查看虚拟机网卡"><a href="#查看虚拟机网卡" class="headerlink" title="查看虚拟机网卡"></a>查看虚拟机网卡</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604153003756-7b9c0a.png" alt="image-20230604153003756"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604153020327-2f4a0b.png" alt="image-20230604153020327"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604153031349-c07bae.png" alt="image-20230604153031349"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604153107314-48e515.png" alt="image-20230604153107314"></p><h3 id="安装网络工具"><a href="#安装网络工具" class="headerlink" title="安装网络工具"></a>安装网络工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install net-tools</span><br><span class="line"></span><br><span class="line">IS this ok 都是两个y</span><br><span class="line"></span><br><span class="line">之后就可以使用ifconfig了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于SSH连接，一般默认有防火墙进行拦截，所以要么将防火墙关闭，要么开放22号端口进行连接</span><br><span class="line"></span><br><span class="line">查看防火墙状态： systemctl status firewalld.service（绿的running表示防火墙开启）</span><br><span class="line"></span><br><span class="line">执行关闭命令（立即关闭 - 立即生效）： systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line">再次执行查看防火墙命令：systemctl status firewalld.service</span><br><span class="line"></span><br><span class="line">执行开机禁用防火墙自启命令（永久关闭 - 重启生效）： systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line">开启防火墙：systemctl start firewalld.service</span><br></pre></td></tr></table></figure><h3 id="虚拟机网段在同一网段（虚拟机连不上网这样做）"><a href="#虚拟机网段在同一网段（虚拟机连不上网这样做）" class="headerlink" title="虚拟机网段在同一网段（虚拟机连不上网这样做）"></a>虚拟机网段在同一网段（虚拟机连不上网这样做）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于在电脑上的IP网关，虚拟机IP在连接外网后可能会变，如果和虚拟机自己的网不在一个网段上，虚拟机里面的系统可能连不上网，为了防止这个问题，所以将网关IP设置和虚拟机一个段内就可以</span><br><span class="line"></span><br><span class="line">保证linux的ip地址网段和宿主机的虚拟网卡的网段一致；</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604170436777-5dbe3e.png" alt="image-20230604170436777"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604170449352-ddf142.png" alt="image-20230604170449352"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604170837678-d26735.png" alt="image-20230604170837678"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这样就把IP地址设置成固定的192.168.153.5 了</span><br></pre></td></tr></table></figure><h3 id="虚拟机IP地址固定"><a href="#虚拟机IP地址固定" class="headerlink" title="虚拟机IP地址固定"></a>虚拟机IP地址固定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于虚拟机的ip地址是随机给定的，虽然大部分时候是一致的，但是会存在不一致的情况，为了防止这种情况发生，将IP地址设置固定比较好</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先去进行上面虚拟机网段配置，就上面这个问题，将虚拟机和本地宿主机的虚拟网关配置一致，之后进行下面的操作</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">操作上面这个文件夹</span><br><span class="line">进行下面的操作，修改成如下图所示即可</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605194234190-1da950.png" alt="image-20230605194234190"></p><h2 id="SSH客户端连接"><a href="#SSH客户端连接" class="headerlink" title="SSH客户端连接"></a>SSH客户端连接</h2><h3 id="测试ssh是否打开"><a href="#测试ssh是否打开" class="headerlink" title="测试ssh是否打开"></a>测试ssh是否打开</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep ssh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="新建连接"><a href="#新建连接" class="headerlink" title="新建连接"></a>新建连接</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604191705520-9fe6c2.png" alt="image-20230604191705520"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604191843667-d72b2d.png" alt="image-20230604191843667"></p><p>点击确定，即创建成功，就可以连接了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.ip地址是否生成 -----ifconfig  /ip addr</span><br><span class="line">2.ssh连接是否生成----一般是自动生成</span><br><span class="line">3.防火墙是否关闭或者22端口是否开放</span><br><span class="line">4.（如果连接失败，虚拟机没网- -）查看虚拟机网段和系统网段是否在一个段 ---如果上面三个正常，那么就不需要设置这个</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查看当前所在目录（用处：拷贝目录到一些配置文件）：pwd</span><br><span class="line"><span class="number">2.</span>切换目录（需要到特定的目录执行命令）:cd 目录名</span><br><span class="line"><span class="number">3.</span>文件名和目录名称补全：Tab</span><br><span class="line"><span class="number">4.</span>查看目录文件信息：</span><br><span class="line">(<span class="number">1</span>) ls <span class="comment">//列出文件信息</span></span><br><span class="line">(<span class="number">2</span>) ls -l <span class="comment">//以详细信息方式列出文件信息</span></span><br><span class="line">(<span class="number">3</span>) ls –a <span class="comment">//列出所有文件和文件夹，包含隐藏文件</span></span><br><span class="line">(<span class="number">4</span>) ls -al <span class="comment">//以详细信息方式列出所有文件信息，包含隐藏文件</span></span><br><span class="line">(<span class="number">5</span>) ls 目录名  <span class="comment">//查看该目录的文件信息</span></span><br><span class="line">(<span class="number">6</span>) ll <span class="comment">//等于ls -l</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>查看当前用户：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) whoami   <span class="comment">//查看当前操作用户</span></span><br><span class="line">(<span class="number">2</span>) who am i  <span class="comment">//查看当前登录用户(有可能是有多个的)的信息</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查找命令：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 最强大的搜索命令：find 查找各种文件的命令　</span><br><span class="line">(<span class="number">2</span>) 在文件资料中查找文件：locate　　</span><br><span class="line">(<span class="number">3</span>) 搜索命令所在的目录及别名信息：which　</span><br><span class="line">(<span class="number">4</span>) 搜索命令所在的目录及帮助文档路径：whereis </span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>切换用户：</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>) su 用户名:切换用户</span><br><span class="line">(<span class="number">6</span>) su root:普通用户切到root用户，需要输入密码;</span><br><span class="line">(<span class="number">7</span>) su hxj:切换到hxj的用户</span><br><span class="line">(<span class="number">8</span>) exit  <span class="comment">//注销当前用户，返回前一用户</span></span><br></pre></td></tr></table></figure><h2 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.系统目录介绍</span><br><span class="line">/bin 存放二进制可执行文件（命令），所有用户都可以使用</span><br><span class="line">/sbin 存放二进制可执行文件，只有root用户可以使用</span><br><span class="line">/boot 系统启动需要的核心文件</span><br><span class="line">/dev 设备文件</span><br><span class="line">/home 用户的主目录，每一个非root用户都会在home有一个为用户名的文件夹</span><br><span class="line">/lib 系统共享动态链接库</span><br><span class="line">/mnt 挂载目录，通常挂载到该目录下</span><br><span class="line">/etc 存放系统配置文件目录</span><br><span class="line">​/etc/passswd 用户信息文件</span><br><span class="line">​/etc/group 用户组信息文件</span><br><span class="line">/<span class="keyword">var</span> 用来存放常态性变动的文件，经常发生变化的文件。比如缓存、登录文件，mysql数据库文件等</span><br><span class="line">/tmp  临时目录，用来存放临时文件</span><br><span class="line">/proc 虚拟目录，是内存的映射，可以访问到内存中的系统信息</span><br><span class="line">/sys 和proc类似，存放和内核相关的信息和数据</span><br><span class="line">/root root用户的主目录</span><br><span class="line">/usr 存放应用程序和文件（类似于windows的system32、program files目录）</span><br><span class="line">​/usr/local/src  所有应用程序包都放这儿</span><br><span class="line">​/usr/local/ 所有的应用程序都安装在这个目录。</span><br><span class="line">​/usr/bin、/usr/sbin：这是对/bin、/sbin的一个补充 </span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">​/usr：系统级的目录，可以理解为C:/Windows/，/usr/lib理解为C:/Windows/System32</span><br><span class="line">​/usr/local：用户级的程序目录，可以理解为C:/Program Files/，用户自己编译的软件默认会安装到这个目录下；</span><br><span class="line">​/opt：用户级的程序目录，可以理解为D:/Program Files/，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可</span><br><span class="line"><span class="number">1.</span>一般跟系统有关的程序或软件或需要进行配置的程序安装到/usr/local中（jdk，tomcat等），安装包可以放在/usr/local/src中；</span><br><span class="line"><span class="number">2.</span>一般第三方与系统不是很挂钩的软件放在/opt中，安装包也可以放在这里；</span><br></pre></td></tr></table></figure><h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>相对路径和绝对路径:</span><br><span class="line">(<span class="number">1</span>) 绝对路径：以/（根目录）开头的路径（例如：/home、/etc/passwd）</span><br><span class="line">(<span class="number">2</span>) 相对路径：以./开头的路径，很多时候./可以省略（指相对于当前路径）：</span><br><span class="line">① ./ 表示当前目录（可以省略）./usr/loccal/=usr/local</span><br><span class="line">② ../ 表示上一级目录</span><br><span class="line">注：路径的最后一个斜杠可以省略</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建目录：</span><br><span class="line">(<span class="number">1</span>) mkdir 目录名  <span class="comment">//创建一个目录</span></span><br><span class="line">(<span class="number">2</span>) mkdir -p 目录<span class="number">1</span>/目录<span class="number">2</span>/目录<span class="number">3</span>  <span class="comment">//递归创建目录</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>删除目录：rm -rf 路径  <span class="comment">//可以删除文件和目录   -r(递归) -f(暴力)</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>移动目录/修改文件名：mv dir1 dir2 如果dir2不存在，将dir1目录名修改为dir2（重命名），否则将dir1目录移动到dir2中；</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>复制目录：</span><br><span class="line">(<span class="number">1</span>) cp -rf dir1 dir2 <span class="comment">//将dir1复制一份到dir2目录（包含目录内容一起复制）</span></span><br><span class="line">(<span class="number">2</span>) cp -rf dir1<span class="comment">/* dir2 //直接复制内容（非常重要）*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建文件：touch 文件路径 <span class="comment">//创建一个空白文件</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>查看文件内容：cat  <span class="comment">//将文件内容直接显示出来，不进行编辑</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>打开文件、保存、关闭文件（vi命令模式下使用）</span><br><span class="line">​vi filename     <span class="comment">//打开filename文件 </span></span><br><span class="line">​:w     <span class="comment">//保存文件 </span></span><br><span class="line">​:w vpser.net  <span class="comment">//保存至vpser.net文件 </span></span><br><span class="line">​:q       <span class="comment">//退出编辑器，如果文件已修改请使用下面的命令 ，q（quit）</span></span><br><span class="line">​:q!     <span class="comment">//退出编辑器，且不保存 </span></span><br><span class="line">​:wq      <span class="comment">//退出编辑器，且保存文件 </span></span><br><span class="line">注意：按i（insert）进入编辑，按Ctrl + C 退出编辑，退出编辑输入:wq退出编辑器</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>打包和解压：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) tar -czvf tom.tar.gz tom--打包</span><br><span class="line">(<span class="number">2</span>) tar -xzvf tom.tar.gz -C /usr/local--解包</span><br><span class="line">(<span class="number">3</span>) 参数：</span><br><span class="line">​-c创建一个新的tar文件      -t参看压缩文件内容</span><br><span class="line">​-v显示运行过程信息-j调用bzip2压缩命令执行压缩</span><br><span class="line">​-f指定文件名称-C 指定需要解压到的目录</span><br><span class="line">​-z调用gzip压缩命令执行解压缩  </span><br><span class="line">​-x解开tar文件</span><br></pre></td></tr></table></figure><h2 id="Vi编辑"><a href="#Vi编辑" class="headerlink" title="Vi编辑"></a>Vi编辑</h2><h3 id="命令行模式常用命令"><a href="#命令行模式常用命令" class="headerlink" title="命令行模式常用命令"></a>命令行模式常用命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>o</td><td>在当前行后面插入一空行</td></tr><tr><td>O</td><td>在当前行前面插入一空行</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd  比如 ：2dd</td><td>从光标位置向下连续删除 n 行</td></tr><tr><td>yy</td><td>复制光标所在行</td></tr><tr><td>nyy</td><td>从光标位置向下连续复制n行</td></tr><tr><td>p</td><td>粘贴</td></tr><tr><td>u</td><td>撤销上一次命令</td></tr><tr><td>gg</td><td>回到文件顶部</td></tr><tr><td>G</td><td>回到文件末尾</td></tr><tr><td>&#x2F;str</td><td>查找str</td></tr></tbody></table><h3 id="底行模式常用命令"><a href="#底行模式常用命令" class="headerlink" title="底行模式常用命令"></a>底行模式常用命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>:w 文件</td><td>另存为</td></tr><tr><td>:w</td><td>保存(ctrl + s)</td></tr><tr><td>:q</td><td>退出, 如果没有保存,不允许退出</td></tr><tr><td>:q!</td><td>强行退出, 不保存退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:set nu</td><td>设置行号</td></tr><tr><td>:%s&#x2F;旧文本&#x2F;新文本&#x2F;g</td><td>文本替换</td></tr></tbody></table><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户创建和密码设置"><a href="#用户创建和密码设置" class="headerlink" title="用户创建和密码设置"></a>用户创建和密码设置</h3><p>useradd 用户名</p><p>passwd  用户名</p><p>useradd hxj #创建新用户hxjpasswd  hxj #设置用户hxj密码</p><h3 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h3><p>userdel -r 用户名</p><p>userdel -r hxj#删除用户hxj</p><h3 id="切换用户登录"><a href="#切换用户登录" class="headerlink" title="切换用户登录"></a>切换用户登录</h3><p>exit su -user  退出切换</p><p>su 用户名  切换</p><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><h3 id="文件权限解读"><a href="#文件权限解读" class="headerlink" title="文件权限解读"></a>文件权限解读</h3><table><thead><tr><th><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604195207060-173614688614867-f8f4e0.png" alt="image-20230604195207060"></th><th>文件目录列查看权限，每一个文件打开前面都会有这样一个字符串</th></tr></thead><tbody><tr><td><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604195210921-173614690538368-918643.png" alt="image-20230604195210921"></td><td>权限说明</td></tr></tbody></table><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230601231458324-173614691807669-c5fe01.png" alt="image-20230601231458324"></p><p>r: 对文件是指可读取内容 对目录是可以ls</p><p>w: 对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</p><p>x: 对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</p><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><p>chmod命令用来变更文件或目录的权限。—都是对a.txt文件操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 666 a.txt  //将三个用户都设置为rw  因为r+w =6 所以对三个用户都是</span><br><span class="line">chmod u+x a.txt//给u用户增加x权限</span><br><span class="line">chmod u=rwx,g=rw,o=x a.txt  //给u用户rwx权限 o=x权限</span><br></pre></td></tr></table></figure><h1 id="Centos7安装软件"><a href="#Centos7安装软件" class="headerlink" title="Centos7安装软件"></a>Centos7安装软件</h1><p>安装软件有三种方式</p><h2 id="解压源码包文件安装"><a href="#解压源码包文件安装" class="headerlink" title="解压源码包文件安装"></a>解压源码包文件安装</h2><p>特点：这种安装方式解压即安装，有的软件需要配置下环境变量（例如JDK的安装需要配置环境变量），卸载时只需要将解压包删除即可；</p><p>命令：tar -zxvf 压缩包名（后缀为.tar.gz）</p><p>例如：将jdk的tar.gz包解压到指定文件夹：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps66-ff5c34.jpg" alt="img"> </p><h2 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h2><p>特点：这种安装方式，软件包会自动配置jdk的环境变量，不用手动配置。也是最方便快捷的一种方式</p><p>命令：</p><p>rpm -qa 软件名称 ：查询软件是否被安装</p><p>rpm -ivh 软件包路径 需要安装的包文件 ： rpm –ivh xxx.rpm</p><p>rpm -e –nodeps 需要卸载的软件包 ： 卸载软件（–nodeps 忽略依赖关系并继续操作）</p><p>rpm  -qa | grep  查询名称 ：利用管道模糊查询软件安装情况：</p><p>​例如： rpm -qa | grep java检测系统自带的jdk安装包</p><p> 参数说明：rpm [选项] [参数]</p><p>  -a：查询所有软件包</p><p>  -e：删除指定的软件包</p><p>  -f&lt;文件&gt;：查询拥有指定文件的套件； </p><p>  -h或–hash：显示进度信息 ，以#显示进度</p><p>  -i：显示包的详细信息</p><p>  -i&lt;软件包&gt;或–install&lt;软件包&gt;：安装指定的软件包 </p><p>  -l：显示包的文件列表</p><p>  -p：查询指定的RPM包 </p><p>  -q：使用询问模式</p><p>  -U&lt;软件包&gt;或–upgrade&lt;软件包&gt;：升级指定的程序包</p><p>  -v：显示指令执行详细过程</p><p>-vv：详细显示指令执行过程，便于排错</p><p>例子：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps67-5f7fe6.jpg" alt="img"> </p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps68-28a23d.jpg" alt="img"> </p><p>注：rpm命令 功能类似于Windows里面的“添加&#x2F;删除程序”，但是功能又比“添加&#x2F;删除程序”强很多，它就是Red Hat Package Manager(简称RPM)。此工具包最先是由Red Hat公司推出的，后来被其他Linux开发商所借用。由于它为Linux使用者省去了很多时间，所以被广泛应用于在Linux下安装、删除软件。</p><p>ivh都是rpm命令的参数，可以从rpm –help里找到说明。 意思是安装显示安装进度–install–verbose–hash</p><p>-i：表示安装（install）</p><p>-v：显示详细过程  </p><p>-h： 以#显示进度</p><h2 id="yum在线安装"><a href="#yum在线安装" class="headerlink" title="yum在线安装"></a>yum在线安装</h2><p>特点：将所有软件包放到官方服务器上，当进行yum在线安装时，可以自动解决依赖性问题；</p><p>缺点：安装过程中，rpm包依赖性太强；</p><p>yum命令：</p><p>1.查询：</p><p>(1) yum list –查询所有可用软件包列表</p><p>(2) yum search 关键字 –搜索服务器上所有和关键字相关的包</p><p>2.安装：</p><p>(1) yum -y install 包名 (-y 自动回答yes)</p><p>(2) yum安装只写包名即可！ eg:yum -y install gcc –c语言编译器</p><p>3.升级&#x2F;卸载</p><p>(1) 升级：yum -y update 包名</p><p>① update：升级；</p><p>② -y：自动回答yes；</p><p>(2) 卸载：yum -y remove 包名</p><p>① remove：卸载；</p><p>② -y：自动回答yes；</p><h1 id="Linux本地部署"><a href="#Linux本地部署" class="headerlink" title="Linux本地部署"></a>Linux本地部署</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将jdk包复制到/usr/local/src位置</span><br></pre></td></tr></table></figure><p>首先保证系统不自带jdk</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检测系统自带的jdk安装包</span><br><span class="line">[root@localhost ~]# rpm -qa|grep java或者[root@localhost ~]# rpm -qa|grep jdk</span><br></pre></td></tr></table></figure><p>删除自带JDK</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rpm -e --nodeps opeanjdk的包名</span><br><span class="line">参数说明:-e：删除包  --nodeps： 忽略软件包的依赖关系强行安装</span><br></pre></td></tr></table></figure><h3 id="自己安装"><a href="#自己安装" class="headerlink" title="自己安装"></a>自己安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.由于linux中安装程序一般安装在/user/local下：</span><br><span class="line">[root@localhost ~]# cd /usr/local</span><br><span class="line"></span><br><span class="line">2.将安装包 jdk-8u151-linux-x64.tar.gz解压解压到/usr/local/目录中：</span><br><span class="line">[...]# tar -zxvf /usr/local/src/jdk-8u151-linux-x64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">3.配置环境变量 vi /etc/profile，在export语句下面添加：</span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">4.按键盘上的i（input）键进入编辑模式，按住Ctrl+C退出编辑模式，然后输入:wq!保存并退出</span><br><span class="line"> //注意路径是否一致以及jdk版本</span><br><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_151</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">5.配置环境变量生效：</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h2><h3 id="查看mysql是否安装"><a href="#查看mysql是否安装" class="headerlink" title="查看mysql是否安装"></a>查看mysql是否安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa|grep -i mysql</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">rpm：RedHat Package Manager（RedHat软件包管理工具）类似Windows里面的“添加/删除程序</span><br><span class="line">-qa：[搜索指定rpm包是否安装] -all搜索mysql           </span><br><span class="line">-q就是 --query ，-a就是--all，           </span><br><span class="line">    |grep mysql就是查含有mysql的包名（grep正则表达式）           </span><br><span class="line">    -i, --install  install package(s) -- 可以省略</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">如果存在那么就需要进行删除，下面是删除命令</span><br><span class="line">[root@localhost ~]# rpm -e --noscripts 包名 --nodeps</span><br><span class="line">参数说明:-e：删除包--noscripts： 忽略RPM包的脚本执行</span><br><span class="line"></span><br><span class="line">查找之前老版本mysql的目录、并且删除老版本mysql的文件和库：</span><br><span class="line">[root@localhost ~]# find / -name mysql</span><br><span class="line">删除对应的mysql目录：</span><br><span class="line">[root@localhost ~]# rm -rf 上面的目录</span><br><span class="line">再次查找机器是否安装mysql，如果没有就说明卸载干净了：</span><br><span class="line">[root@localhost ~]# find / -name mysql</span><br></pre></td></tr></table></figure><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以直接进行解压，这里尝试下载</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先测试wget是否存在  wget直接输入</span><br><span class="line">不存在那么就需要安装 yum install wget -y</span><br><span class="line"></span><br><span class="line">之后就可以开始下载</span><br><span class="line">1.切换目录</span><br><span class="line">[root@localhost ~]# cd /usr/local</span><br><span class="line">2.开始下载</span><br><span class="line">[root@localhost local]# wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm </span><br><span class="line">注意：在什么地方下载就要在那个目录中执行安装，否则提示找不到rpm包，安装完后将rpm包删除</span><br><span class="line"></span><br><span class="line">3.安装mysql-community-release-el7-5.noarch.rpm包</span><br><span class="line">[root@localhost local]# rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"></span><br><span class="line">参数说明：－ivh：安装显示安装进度--install--verbose--hash</span><br><span class="line"></span><br><span class="line">第四步：安装mysql --- 注意安装在上一级目录</span><br><span class="line">[root@localhost local]# yum install mysql-server</span><br></pre></td></tr></table></figure><p>安装完成后就可以启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost local]# systemctl start mysqld</span><br><span class="line"></span><br><span class="line">查看Mysql状态：systemctl status mysqld  或者 service mysqld status</span><br><span class="line">开启mysql服务：systemctl start mysqld  或者service mysqld start</span><br><span class="line">关闭mysql服务：systemctl stop mysqld  或者service mysqld stop</span><br><span class="line">重启mysql服务：systemctl restart mysqld 或者service mysqld restart</span><br></pre></td></tr></table></figure><p>Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来设置root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost local]# mysqladmin -u root password &quot;你自己想设置的数据库密码&quot;</span><br><span class="line"></span><br><span class="line">完成后就可以连接了</span><br><span class="line">[root@localhost local]# mysql -uroot -p你刚刚设置的密码</span><br></pre></td></tr></table></figure><h3 id="Mysql编码集设置"><a href="#Mysql编码集设置" class="headerlink" title="Mysql编码集设置"></a>Mysql编码集设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装完的MySQL的默认字符集为 latin1 ，那么如果此时创建表和数据库，或者导入外部带中文的数据，mysql是不支持的。为了要将其字符集改为用户所需要的(比如utf8)，就必须改其相关的配置文件；</span><br><span class="line"></span><br><span class="line">查看默认字符集</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;character_set%&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改字符集，修改 /etc/my.cnf文件</span><br><span class="line">vi /etc/my.cnf（没有就自己创建一个，vi会自动创建）</span><br><span class="line">注意：如果my.cnf存在，那么就在[mysqld]处将下面的配置拷贝进去，并删除原来的[mysqld]，因为配置中存在一个，不能有两个；</span><br><span class="line"></span><br><span class="line">进行编辑：直接粘进去</span><br><span class="line">[client]default-character-set=utf8</span><br><span class="line">[mysql]default-character-set=utf8</span><br><span class="line"></span><br><span class="line">//这个找到相应的[mysqld]模块，将后面的配置粘贴进去</span><br><span class="line">[mysqld]character-set-server=utf8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重启mysql</span><br><span class="line">[root@localhost local]# systemctl restart mysqld </span><br><span class="line">注意：如果重启卡住，很有可能是你my.cnf中出问题了，重新编辑，或者从其他人那里拷贝一个；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再次连接mysql，查看字符集编码</span><br><span class="line">[root@localhost local]# mysql -uroot -p你刚刚设置的密码</span><br><span class="line">mysql&gt; show variables like &#x27;character_set%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="mysql远程登录"><a href="#mysql远程登录" class="headerlink" title="mysql远程登录"></a>mysql远程登录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入mysql，授权远程连接</span><br><span class="line"> grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> *.* 代表所有的权限</span><br><span class="line"> root@&#x27;%&#x27;  百分号里面代表主机</span><br><span class="line"> root@&#x27;%&#x27; identified by &#x27;root&#x27;; 第一个是root用户 第二个是密码</span><br><span class="line"> 这句话的意思是：任意用户使用root用户使用root密码访问，可以设置成mysql的密码</span><br><span class="line"> </span><br><span class="line"> 刷新授权</span><br><span class="line"> mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h2 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先得确保有这个依赖</span><br><span class="line">&lt;!-- SpringBoot打包插件 --&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>注意CORD开启端口IP</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604200153618-17230a.png" alt="image-20230604200153618"></p><p>然后执行Maven的打包工具</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604200338496-5ee2f3.png" alt="image-20230604200338496"></p><p>在完成打包会出现这个JAR包</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604200316299-6fe500.png" alt="image-20230604200316299"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 打好的jar包拖入到/usr/local/src下面</span><br><span class="line"></span><br><span class="line">执行jar包  java -jar  包名</span><br></pre></td></tr></table></figure><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载Nginx --/usr/local/src 地址</span><br><span class="line">wget -c https://nginx.org/download/nginx-1.18.0.tar.gz</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">tar -zxvf nginx-1.18.0.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">进入安装目录</span><br><span class="line">cd..</span><br><span class="line">cd nginx-1.18.0</span><br><span class="line"></span><br><span class="line">配置</span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">编译安装</span><br><span class="line">make</span><br><span class="line">安装</span><br><span class="line">make install //如果报错不用管。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 启动Nginx</span><br><span class="line"> # 启动</span><br><span class="line"> 新建文件logs </span><br><span class="line"> </span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"> </span><br><span class="line"># 重启</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>之后就可以在页面输入ip地址访问</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604211449458-49e0cf.png" alt="image-20230604211449458"></p><p>其实访问的是下面的index页面</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604211408419-d7e222.png" alt="image-20230604211408419"></p><h2 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h2><p>修改baseURL</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="放置在服务器"><a href="#放置在服务器" class="headerlink" title="放置在服务器"></a>放置在服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在dist目录中生成static和index.html</span><br><span class="line">将这两个文件复制到虚拟机nginx默认访问目录下---之后进行访问就可以！！</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230604211619024-bdb909.png" alt="image-20230604211619024"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/40991.html"/>
      <url>/posts/40991.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h1><p>更多介绍看老师的文档</p><p>OS层虚拟化架构—Docker其实本质上是根据这个模式进行创建的，每一个容器装着需要运行这个容器的最小系统</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605193340901-f0c4c1.png" alt="image-20230605193340901"></p><h2 id="容器虚拟化"><a href="#容器虚拟化" class="headerlink" title="容器虚拟化"></a>容器虚拟化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</span><br><span class="line">容器与容器之间是完全相互独立的</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。</span><br><span class="line">    镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：添加一个文件；执行一个命令；打开一个窗口。也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</span><br></pre></td></tr></table></figure><h2 id="Docker-Registry-注册中心"><a href="#Docker-Registry-注册中心" class="headerlink" title="Docker Registry(注册中心)"></a>Docker Registry(注册中心)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像</span><br></pre></td></tr></table></figure><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</span><br><span class="line">    </span><br><span class="line">或者可以认为，镜像是java中的类，容器则是类的实现对象</span><br></pre></td></tr></table></figure><h1 id="Docker的安装和启动"><a href="#Docker的安装和启动" class="headerlink" title="Docker的安装和启动"></a>Docker的安装和启动</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>安装必须要的工具</span><br><span class="line">sudo是表示权限---超级管理员不需要</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>添加docker的yum库，用镜像</span><br><span class="line"> 阿里云镜像库</span><br><span class="line">yum-config-manager --add-repo http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line">缓存</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>安装Docker</span><br><span class="line">    sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span> 设置启动&amp;开机启动</span><br><span class="line">    启动</span><br><span class="line">    sudo systemctl start docker</span><br><span class="line">设置开机自动启动</span><br><span class="line">systemctl enable docker</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>测试Docker</span><br><span class="line"> 如果在run的时候，发现没有这个镜像，会去主动拉取</span><br><span class="line">    docker run hello-world</span><br><span class="line">    </span><br><span class="line">或者也可以通过查看版本来测试：docker version</span><br></pre></td></tr></table></figure><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605195912112-74fcd5.png" alt="image-20230605195912112"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605195926153-b5569e.png" alt="image-20230605195926153"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605195935910-386240.png" alt="image-20230605195935910"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://s9pbd7jo.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">可以直接将上面的代码放到控制台运行</span><br><span class="line"></span><br><span class="line">或者去/etc/docker文件里面创建一个daemon.json  然后再里面写入</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://s9pbd7jo.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">然后sudo systemctl daemon-reload     <span class="comment">//重新加载配置</span></span><br><span class="line">sudo systemctl restart docker      <span class="comment">//重启docker</span></span><br></pre></td></tr></table></figure><h1 id="Docker操作"><a href="#Docker操作" class="headerlink" title="Docker操作"></a>Docker操作</h1><h2 id="服务操作"><a href="#服务操作" class="headerlink" title="服务操作"></a>服务操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动docker：systemctl start docker</span><br><span class="line">停止docker：systemctl stop docker</span><br><span class="line">重启docker：systemctl restart docker</span><br><span class="line">查看docker状态：systemctl status docker</span><br><span class="line">开机启动：systemctl enable docker</span><br><span class="line">查看docker概要信息：docker info</span><br><span class="line">    里面涉及到IPPADR  是服务器的IP地址</span><br><span class="line">    </span><br><span class="line">查看docker帮助文档：docker --help</span><br></pre></td></tr></table></figure><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker images :  查看本地镜像</span><br><span class="line"></span><br><span class="line">docker search 镜像名：搜索远程镜像 --从指定的远程仓库搜索</span><br><span class="line"></span><br><span class="line">docker rmi 镜像名:版本 或者 imageId  :   删除指定镜像  ---如果有容器，删除不掉</span><br><span class="line"></span><br><span class="line">docker rmi ‘docker images -q’ :   删除所有镜像</span><br><span class="line"></span><br><span class="line">docker pull 镜像名:版本 :   拉取镜像</span><br><span class="line"></span><br><span class="line">docker push 镜像:版本 ：推送镜像到远程</span><br></pre></td></tr></table></figure><h3 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker images :  查看本地镜像</span><br><span class="line"></span><br><span class="line">REPOSITORY：镜像所在的仓库名称</span><br><span class="line">TAG：镜像标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像的创建日期（不是获取该镜像的日期）</span><br><span class="line">SIZE：镜像大小</span><br><span class="line">这些镜像都是存储在Docker宿主机的/<span class="keyword">var</span>/lib/docker目录下</span><br></pre></td></tr></table></figure><h3 id="镜像搜索"><a href="#镜像搜索" class="headerlink" title="镜像搜索"></a>镜像搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</span><br><span class="line">docker search 镜像名称</span><br><span class="line"></span><br><span class="line">NAME：仓库名称</span><br><span class="line">DESCRIPTION：镜像描述</span><br><span class="line">STARS：用户评价，反应一个镜像的受欢迎程度</span><br><span class="line">OFFICIAL：是否官方</span><br><span class="line">AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的<span class="number">63.4</span>拉取镜</span><br></pre></td></tr></table></figure><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认是HUB拉取，但是配置镜像后就在镜像拉取</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker rmi IMAGE_ID：删除指定镜像</span><br><span class="line"></span><br><span class="line">docker rmi `docker images -q`：删除所有镜像</span><br><span class="line">docker images -q  取到所有的镜像id</span><br></pre></td></tr></table></figure><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Docker ps -a ：查看所有容器</span><br><span class="line">Docker run  ： 创建并运行一个容器</span><br><span class="line">Docker rm ： 删除容器</span><br><span class="line">Docker stop ： 停止容器</span><br><span class="line">Docker start ：把停止的容器启动起来</span><br><span class="line">Docker logs ：查看容器的运行日志</span><br><span class="line">Docker inspect ：查看容器的配置</span><br><span class="line">Docker exec ：进入容器里面 ， exit 退出容器</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">查看所有的容器：docker ps –a</span><br><span class="line">查看最后一次运行的容器：docker ps –l</span><br><span class="line">查看停止的容器：docker ps -f status=exited</span><br></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建容器命令：docker run 镜像名字：版本号</span><br><span class="line">参数说明：</span><br><span class="line">-i：表示运行容器</span><br><span class="line">-t：表示容器启动后会进入容器命令行(交互式)。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</span><br><span class="line">注意：在交互式容器中如果执行 “exit”会结束容器，如果使用“ctrl + p + q”就不会退出容器</span><br><span class="line">-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</span><br><span class="line">注意：在后台容器中如果执行 “exit”会结束容器</span><br><span class="line">--name :为创建的容器命名。</span><br><span class="line">-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射</span><br><span class="line">-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">| 交互式： docker run -i -t  --name=容器名字 -p=外端口（linux端口）:内端口（容器端口） 镜像名字:版本号  /bin/bash 或 /bin/sh |</span><br><span class="line">-i -t 可以简写成-it</span><br><span class="line"></span><br><span class="line">eg：docker run -it --name=mycentos -p=<span class="number">7788</span>:<span class="number">8899</span> centos:<span class="number">7</span> /bin/bash</span><br><span class="line">如上创建了一个交互式容器，名字是mycentos 镜像是centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">| 后台式： docker run -i -d --name=容器名字 -p=外端口:内端口 镜像名字:版本号 | </span><br><span class="line">如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器</span><br><span class="line"></span><br><span class="line">eg:docker run -id --name=mycentos2 -p=<span class="number">7788</span>:<span class="number">8899</span> centos:<span class="number">7</span></span><br><span class="line">如上，创建了一个后台式容器，名字叫mycentos2 镜像 centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line">后台式进入交互式可以这样</span><br><span class="line">docker exec -it 容器名称 (或者 容器id) /bin/bash（exit退出时，容器不会停止）</span><br></pre></td></tr></table></figure><h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">停止正在运行的容器：docker stop 容器名/容器id</span><br><span class="line">启动已运行过的容器：docker start 容器名/容器id</span><br></pre></td></tr></table></figure><h3 id="容器文件拷贝"><a href="#容器文件拷贝" class="headerlink" title="容器文件拷贝"></a>容器文件拷贝</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果我们需要将文件拷贝到容器内可以使用cp命令</span><br><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br><span class="line"></span><br><span class="line">也可以将文件从容器内拷贝出来</span><br><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure><h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</span><br><span class="line"></span><br><span class="line">创建容器 添加-v参数 后边为  宿主机目录:容器目录</span><br><span class="line"></span><br><span class="line">eg:docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos2 centos:<span class="number">7</span></span><br><span class="line">如上，创建了一个后台式的容器，将宿主的/usr/local/myhtml目录和自己的/usr/local/myhtml 目录进行绑定，同时名字叫mycentos2镜像是centos:<span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="查看容器IP地址"><a href="#查看容器IP地址" class="headerlink" title="查看容器IP地址"></a>查看容器IP地址</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker inspect  容器名称/id</span><br><span class="line"></span><br><span class="line">或者直接输出IP地址</span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> 容器名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker rm 容器名/容器ID</span><br><span class="line">删除所有容器：docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -id --name=容器名 -p=linux端口:容器端口 -v=/linux目录：/容器目录  镜像名:版本</span><br><span class="line">查看容器：docker ps -a</span><br><span class="line">查看容器ID： docker ps -a -q</span><br><span class="line">删除容器：docker rm 容器名</span><br><span class="line">删除所有容器：docker rm `docker ps -a -q`</span><br><span class="line">停止一个容器：docker kill 容器名</span><br><span class="line">停止所有容器： docker kill `docker ps -a -q`</span><br><span class="line">启动容器：docker start 容器名</span><br><span class="line">重启容器：docker restart 容器名</span><br><span class="line">进入容器：docker exec -it 容器名 /bin/bash   ， 退出容器 exit  或者ctrl + p + q (交互式容器建议使用)</span><br><span class="line">拷贝文件到容器：docker cp /linux文件  容器:/容器目录</span><br><span class="line">从容器拷贝文件到linux: docker cp 容器:/文件   /linux目录</span><br><span class="line">查看IP： docker inspect 容器名</span><br><span class="line">查看日志：docker logs  容器名</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker logs -f container_id  来查看为什么错误</span><br></pre></td></tr></table></figure><h2 id="Docker通信方式"><a href="#Docker通信方式" class="headerlink" title="Docker通信方式"></a>Docker通信方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动容器的时候，给要通信的目标容器使用link指定一个“链接名”,在容器中就可以使用“链接名”和目标容器通信。格式：  --link 目标容器:别名  ，例如： 容器stumanager 想要链接 stumanager_mysql 如下配置：</span><br><span class="line"></span><br><span class="line">创建Mysql容器，名字为： stumanager_mysql</span><br><span class="line">docker run -id --name=stumanager_mysql -p=<span class="number">3306</span>:<span class="number">3306</span> mysql:<span class="number">5.7</span>   </span><br></pre></td></tr></table></figure><h2 id="开启docker远程访问"><a href="#开启docker远程访问" class="headerlink" title="开启docker远程访问"></a>开启docker远程访问</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/docker.service </span><br><span class="line"></span><br><span class="line">其中ExecStart=后添加配置 </span><br><span class="line">-H tcp:<span class="comment">//0.0.0.0:2375 -H unix://var/run/docker.sock </span></span><br><span class="line"></span><br><span class="line">刷新配置，重启服务 </span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br><span class="line">    </span><br><span class="line">访问测试：宿主机IP地址:<span class="number">2375</span></span><br><span class="line">    </span><br><span class="line">如果不通过那么就可能是防火墙的问题</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607000051877-8ba02d.png" alt="image-20230607000051877"></p><h1 id="部署项目-基础环境"><a href="#部署项目-基础环境" class="headerlink" title="部署项目-基础环境"></a>部署项目-基础环境</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><h3 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br><span class="line">查看镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="创建容器-1"><a href="#创建容器-1" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意创建的时候宿主机得有这样的文件才可以</span><br><span class="line"></span><br><span class="line">docker run -di --name=mysql57 -p <span class="number">3306</span>:<span class="number">3306</span>  -v /root/mysql/my.cnf:/etc/mysql/my.cnf  -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> mysql:<span class="number">5.7</span></span><br><span class="line">    </span><br><span class="line">-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</span><br><span class="line"><span class="number">3306</span>:<span class="number">3306</span>  后面端口只能是<span class="number">3306</span>  前面的端口可以进行修改是外部系统访问这个端口就可以访问到容器的<span class="number">3306</span>端口</span><br><span class="line"></span><br><span class="line">-e 代表添加环境变量  MYSQL_ROOT_PASSWORD是root用户的登陆密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置文件–改mysql的编码格式"><a href="#配置文件–改mysql的编码格式" class="headerlink" title="配置文件–改mysql的编码格式"></a>配置文件–改mysql的编码格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">容器中mysql的配置：/etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">要么目录挂载的时候修改，要么文件在宿主机完成后cp到容器</span><br><span class="line">由于上面挂载了，那么就把下面内容给到宿主机的my.cnf上</span><br><span class="line">[client]</span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">socket = /<span class="keyword">var</span>/lib/mysql/mysql.sock</span><br><span class="line"><span class="keyword">default</span>-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">socket = /<span class="keyword">var</span>/lib/mysql/mysql.sock</span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line"><span class="keyword">default</span>-character-set=utf8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制不进去可以进行文件复制</span><br><span class="line">docker cp /root/mysql/my.cnf mysql57:/etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">之后就可以通过Navicat进行远程连接，需要IP地址，IP地址是虚拟机的IP地址，因为容器在虚拟机上面，通过创建时候的端口绑定，就可以通过虚拟机的端口来访问mysql，所以通过虚拟机的IP地址以及特定端口就可以进行访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果连接失败就可能需要开启远程访问</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><h3 id="拉取镜像-2"><a href="#拉取镜像-2" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="创建容器-2"><a href="#创建容器-2" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -di --name=stumanager_nginx -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line">    </span><br><span class="line">    一般都采用<span class="number">80</span>端口访问</span><br></pre></td></tr></table></figure><h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><h3 id="拉取镜像-3"><a href="#拉取镜像-3" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><h3 id="创建容器-3"><a href="#创建容器-3" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -di --name stumanager_redis -p <span class="number">6379</span>:<span class="number">6379</span> redis --requirepass <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在你的本地电脑命令提示符下，用window版本redis测试</span><br><span class="line"></span><br><span class="line">redis-cli.exe -h <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span> -p <span class="number">6379</span></span><br></pre></td></tr></table></figure><h1 id="后端项目部署"><a href="#后端项目部署" class="headerlink" title="后端项目部署"></a>后端项目部署</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于centos：<span class="number">7</span>安装jdk1<span class="number">.8</span></span><br><span class="line"><span class="number">1</span>）在宿主机准备包jdk1<span class="number">.8</span></span><br><span class="line"><span class="number">2</span>）搞一个centos7容器</span><br><span class="line"><span class="number">3</span>）把jdk1<span class="number">.8</span>传到容器</span><br><span class="line"><span class="number">4</span>）解压缩jdk1<span class="number">.8</span></span><br><span class="line"><span class="number">5</span>）配置javahomepath</span><br><span class="line">一般使用这个方法</span><br></pre></td></tr></table></figure><h2 id="Dockerfile构建-脚本构建"><a href="#Dockerfile构建-脚本构建" class="headerlink" title="Dockerfile构建-脚本构建"></a>Dockerfile构建-脚本构建</h2><h3 id="Dockerfile基本命令"><a href="#Dockerfile基本命令" class="headerlink" title="Dockerfile基本命令"></a>Dockerfile基本命令</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605215620069-3a63d4.png" alt="image-20230605215620069"></p><h3 id="jdk1-8镜像制造"><a href="#jdk1-8镜像制造" class="headerlink" title="jdk1.8镜像制造"></a>jdk1.8镜像制造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一下操作除了第一个，剩下两个文件放在一个目录下</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、docker pull centos:<span class="number">7</span>  #拉取基础镜像</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、上传一个名字叫“jdk-8u171-linux-x64.tar.gz”的jdk安装包</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、 命令编写Dockerfile的脚本 ，名称就是Dockerfile  里面填写下面的命令</span><br><span class="line"></span><br><span class="line">FROM centos:<span class="number">7</span></span><br><span class="line">MAINTAINER root</span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir /usr/local/java</span><br><span class="line">ADD jdk-8u151-linux-x64.tar.gz /usr/local/java</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1<span class="number">.8</span><span class="number">.0_151</span></span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/bin/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">要修改的有 jdk包 名称 以及解压完成的jdk名称</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、docker build  -t=<span class="string">&quot;jdk:1.8&quot;</span> ./</span><br><span class="line">建立一个镜像</span><br></pre></td></tr></table></figure><h3 id="建立容器"><a href="#建立容器" class="headerlink" title="建立容器"></a>建立容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -di --name=jdk1<span class="number">.8</span> jdk:<span class="number">1.8</span>  </span><br><span class="line"><span class="comment">//建立容器</span></span><br><span class="line">docker exec -it jdk1<span class="number">.8</span> /bin/bash</span><br><span class="line"><span class="comment">//进入控制台</span></span><br><span class="line">java -version</span><br><span class="line"><span class="comment">//查看版本---是否成功</span></span><br></pre></td></tr></table></figure><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Maven打包</span><br><span class="line">需要有下面的依赖</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.2</span><span class="number">.5</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">不打包test包</span><br><span class="line">mvn clean <span class="keyword">package</span> -Dmaven.test.skip=<span class="literal">true</span>   </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>上传项目的jar到 /stumanager目录（目录是宿主机的目录，里面有jar包）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>执行命令：</span><br><span class="line">docker run -id --name=stumanager  --link mysql57:mysql57 -p=<span class="number">8080</span>:<span class="number">8080</span> -v=/usr/local/src/stumanage:/stumanage jdk:<span class="number">1.8</span> java -jar /stumanage/springboot-<span class="number">1.0</span>-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行命令</span></span><br><span class="line">--link mysql57:mysql57  这个语句是将新创建的容器和mysql57容器联系起来</span><br></pre></td></tr></table></figure><h2 id="maven插件构建-也是转换为dockerfile"><a href="#maven插件构建-也是转换为dockerfile" class="headerlink" title="maven插件构建-也是转换为dockerfile"></a>maven插件构建-也是转换为dockerfile</h2><h3 id="开启docker远程访问-1"><a href="#开启docker远程访问-1" class="headerlink" title="开启docker远程访问"></a>开启docker远程访问</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/docker.service </span><br><span class="line"></span><br><span class="line">其中ExecStart=后添加配置 </span><br><span class="line">-H tcp:<span class="comment">//0.0.0.0:2375 -H unix://var/run/docker.sock </span></span><br><span class="line"></span><br><span class="line">刷新配置，重启服务 </span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br><span class="line">    </span><br><span class="line">访问测试：宿主机IP地址:<span class="number">2375</span></span><br><span class="line">    </span><br><span class="line">如果不通过那么就可能是防火墙的问题</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605222423688-c3dc83.png" alt="image-20230605222423688"></p><h3 id="增加Docker插件"><a href="#增加Docker插件" class="headerlink" title="增加Docker插件"></a>增加Docker插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;stumanager&lt;/finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">         &lt;/plugin&gt;</span><br><span class="line">        &lt;!--docker的maven插件，官网： https:<span class="comment">//github.com/spotify/docker‐maven‐plugin--&gt;</span></span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.4</span><span class="number">.13</span>&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;!--镜像名 PetHome:<span class="number">1.0</span>--&gt;</span><br><span class="line">        &lt;imageName&gt;$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">        &lt;!--基础镜像 ，， 所以必须得有jdk镜像--&gt;</span><br><span class="line">        &lt;baseImage&gt;jdk:<span class="number">1.8</span>&lt;/baseImage&gt;</span><br><span class="line">        &lt;entryPoint&gt;[<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/$&#123;project.build.finalName&#125;.jar&quot;</span>]&lt;/entryPoint&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                &lt;directory&gt;$&#123;project.build.directory&#125;</span><br><span class="line">                &lt;/directory&gt;</span><br><span class="line">                &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;!--docker远程主机--&gt;</span><br><span class="line">        &lt;dockerHost&gt;http:<span class="comment">//写自己虚拟机的ip:2375&lt;/dockerHost&gt;</span></span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;artifactId&gt;springboot&lt;/artifactId&gt; 该成小写  不小写报错</span><br></pre></td></tr></table></figure><h3 id="IDEA输入以下命令，进行打包和上传镜像"><a href="#IDEA输入以下命令，进行打包和上传镜像" class="headerlink" title="IDEA输入以下命令，进行打包和上传镜像"></a>IDEA输入以下命令，进行打包和上传镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn clean install <span class="keyword">package</span> <span class="string">&#x27;-Dmaven.test.skip=true&#x27;</span> docker:build</span><br><span class="line">    </span><br><span class="line">运行完成后在虚拟机就可以查看到镜像</span><br></pre></td></tr></table></figure><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="运行镜像创建容器就可以了"><a href="#运行镜像创建容器就可以了" class="headerlink" title="运行镜像创建容器就可以了"></a>运行镜像创建容器就可以了</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -id -p8088:<span class="number">8080</span> --name=stumanager --link mysql57:mysql57  --link stumanager_redis:stumanager_redis  springboot:<span class="number">1.0</span>-SNAPSHOT </span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>mysql的地址修改，密码修改，以及redis的名字修改</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230606231918395-b47e45.png" alt="image-20230606231918395"></p><h1 id="前端项目部署"><a href="#前端项目部署" class="headerlink" title="前端项目部署"></a>前端项目部署</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前段使用Nginx进行部署，首先我们需要把前段项目打包成静态资源 ， 然后使用Dockerfile自动构建一个Ningx镜像，Docerfile脚本构建镜像时需要把前段代码自动拷贝到容器中。</span><br><span class="line"></span><br><span class="line">后台代码可以通过Docker的maven插件进行自动构建，而前段不是Maven项目，需要我们手动编写Dockerfile进行项目构建。</span><br><span class="line"></span><br><span class="line">我们需要在Window电脑上准备前段项目并打包，准备好Dockerfile和nginx.config配置等，待会儿直接打包上传到Linux执行镜像构建即可。</span><br></pre></td></tr></table></figure><h2 id="修改前端"><a href="#修改前端" class="headerlink" title="修改前端"></a>修改前端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里的地址应该是指向后端服务，但是我们后端服务使Nignx进行反向代理，所以这里应该指向反向代理的地址： 如果访问容器后端的端口不是<span class="number">8080</span>，那么就得加上端口号</span><br><span class="line">    </span><br><span class="line">    这个端口是宿主机的端口，后端容器通过宿主机暴漏出来的端口，即-p 宿主机端口：容器端口</span><br><span class="line">这个定义里面的第一个端口</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605224508140-04d364.png" alt="image-20230605224508140"></p><h2 id="前端打包"><a href="#前端打包" class="headerlink" title="前端打包"></a>前端打包</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line"></span><br><span class="line">  进行两次打包压缩</span><br><span class="line">自己手动压缩打包成 tar.gz格式，因为这种格式在构建Dockerfile镜像的时候可以自动解压。   </span><br></pre></td></tr></table></figure><h2 id="编写Dockerfile脚本"><a href="#编写Dockerfile脚本" class="headerlink" title="编写Dockerfile脚本"></a>编写Dockerfile脚本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FROM nginx:<span class="number">1.15</span></span><br><span class="line">RUN mkdir /usr/share/nginx/stumanager_admin</span><br><span class="line">ADD ./stumanager_admin.tar.gz /usr/share/nginx/stumanager_admin</span><br><span class="line">ADD ./nginx.conf /etc/nginx/conf.d/</span><br><span class="line">WORKDIR /usr/share/nginx</span><br><span class="line">RUN chmod -R a+rx * stumanager_admin</span><br><span class="line"></span><br><span class="line">注意修改压缩包名称，改压缩包的名称，以及压缩包解压完成后的名称，给与文件的权限</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="编写Nginx配置文件"><a href="#编写Nginx配置文件" class="headerlink" title="编写Nginx配置文件"></a>编写Nginx配置文件</h2><p>编写nginx.conf，注意后端映射的端口问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen <span class="number">80</span>;</span><br><span class="line">      server_name  localhost;</span><br><span class="line">      location / &#123;   </span><br><span class="line">              root   /usr/share/nginx/stumanager_admin;</span><br><span class="line">              index  index.html;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">下面是配置反向代理，相当于访问后端，自动跳转到proxy_pass http:<span class="comment">//stumanager001:8080，这里如果端口不一致需要修改，名字是映射名字</span></span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">      listen <span class="number">80</span>;</span><br><span class="line">      server_name  Curry.nuesoft;</span><br><span class="line">  location / &#123;</span><br><span class="line">###add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> $http_origin;</span><br><span class="line">###add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">###add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET,POST,DELETE,PUT,OPTIONS&#x27;</span>;</span><br><span class="line">###add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,U-TOKEN,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;</span><br><span class="line">###add_header <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length,Content-Range&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> $http_origin;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET,POST,DELETE,PUT,OPTIONS&#x27;</span>;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,U-TOKEN,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length,Content-Range&#x27;</span>;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">add_header <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">add_header <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">&#125;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">proxy_pass http:<span class="comment">//stumanager001:8080;  #这里跟后端服务的link名字,是映射的名字即 --link 映射名字：容器名字   指的是第二个名字</span></span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">proxy_connect_timeout <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录如下"><a href="#目录如下" class="headerlink" title="目录如下"></a>目录如下</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230605225447720-ac976d.png" alt="image-20230605225447720"></p><h2 id="拉取镜像-4"><a href="#拉取镜像-4" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull  nginx:<span class="number">1.15</span></span><br><span class="line">由于需要nginx：<span class="number">1.15</span>版本</span><br><span class="line">所以进行拉取</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd到 项目上传的目录，执行镜像构建命令   stumanager-nginx  是镜像名称</span><br><span class="line">docker build -t=<span class="string">&quot;stumanager-nginx&quot;</span> ./</span><br></pre></td></tr></table></figure><h2 id="创建容器-4"><a href="#创建容器-4" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -di --name=stumanager_web -p <span class="number">80</span>:<span class="number">80</span> --link stumanager:stumanager001 stumanager-nginx</span><br><span class="line"></span><br><span class="line">这里一定要是“--link stumanager:stumanager001” ，因为在nginx.conf中使用了这个link名字来反向代理到后端服务</span><br><span class="line">    第一个名字是容器名称，第二个名字是在nginx.conf中的名字</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc</span><br><span class="line">去修改hosts文件</span><br><span class="line">由于配置反向代理，域名并没有绑定，所以在进行跳转的时候，本地进行拦截转换</span><br></pre></td></tr></table></figure><h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       <span class="number">80</span>;</span><br><span class="line">server_name  <span class="number">192.168</span><span class="number">.17</span><span class="number">.129</span>;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root   html;</span><br><span class="line">index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">proxy_pass  <span class="attr">http</span>:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">此处的意思为：nginx 反向代理服务监听 <span class="number">192.168</span><span class="number">.17</span><span class="number">.129</span>的<span class="number">80</span>端口，如果有请求过来，则转到proxy_pass配置的对应服务器上，仅此而已。</span><br><span class="line"></span><br><span class="line">在location下，同时配置root和proxy_pass选项时，两个选项只会二选一执行</span><br><span class="line">此处不能配置https反向代理</span><br><span class="line"></span><br><span class="line">原文链接：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/zxd1435513775/article/details/102508463</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">去掉注释信息后，可以将 nginx.conf 配置文件分为三部分：</span><br><span class="line"></span><br><span class="line">第一部分：全局块</span><br><span class="line"> worker_processes  <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">从配置文件开始到events块之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令，主要包括：配置运行Nginx服务器的用户（组）、允许生成的 worker process 数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。</span><br><span class="line">上面这行 worker_processes 配置，是 Nginx 服务器并发处理服务的关键配置，该值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的约束。</span><br><span class="line"></span><br><span class="line">第二部分：events 块</span><br><span class="line">events &#123;</span><br><span class="line">worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">events 块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置包括：是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 work process 可以同时支持的最大连接数等</span><br><span class="line"></span><br><span class="line">上述例子就表示每个 work process 支持的最大连接数为 <span class="number">1024</span>。这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 第三部分：http 块</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这部分是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是：http 块也可以包括 http 全局块、server 块。下面的反向代理、动静分离、负载均衡都是在这部分中配置</span><br><span class="line"></span><br><span class="line">http 全局块：http 全局块配置的指令包括：文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</span><br><span class="line"></span><br><span class="line">server 块：这块和虚拟主机有密切关系，从用户角度看，虚拟主机和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</span><br><span class="line"></span><br><span class="line">每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。而每个server块也分为全局server块，以及可以同时包含多个locaton块。（☆☆☆☆☆）</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/posts/27273.html"/>
      <url>/posts/27273.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://redis.io/download ; http://redis.cn/</span><br><span class="line"></span><br><span class="line">window版本解压Redis包即可</span><br></pre></td></tr></table></figure><h2 id="Redis目录介绍"><a href="#Redis目录介绍" class="headerlink" title="Redis目录介绍"></a>Redis目录介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis.window.conf    #【重要】reids配置文件</span><br><span class="line"></span><br><span class="line">redis-benchmark.exe   #reids压测工具</span><br><span class="line"></span><br><span class="line">redis-check-aof.exe    #aof文件校验、修复功能</span><br><span class="line"></span><br><span class="line">redis-check-rdb.exe    #rdb文件校验、修复功能</span><br><span class="line"></span><br><span class="line">redis-cli.exe    #【重要】命令行客户端，连接Redis服务端可对Redis进行相关操作</span><br><span class="line"></span><br><span class="line">redis-server.exe  #【重要】Redis服务器,启动Redis</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动redis-server</span><br><span class="line"></span><br><span class="line">进入到Redis安装目录，用CMD运行</span><br><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动redis-client  启动本地</span><br><span class="line">redis-cli.exe</span><br><span class="line"></span><br><span class="line">启动其他服务器的Redis</span><br><span class="line">redis-cli.exe -h ip -p 端口   #如  redis-client.exe -h <span class="number">192.168</span><span class="number">.0</span><span class="number">.11</span> -p <span class="number">6379</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">便捷操作，可以写两个bat文件，将命令分别放进去</span><br><span class="line">eg：title redis-start</span><br><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line">这段命令放在redis-start.bat文件里面，点击这个文件就可以运行了</span><br></pre></td></tr></table></figure><h1 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h1><h2 id="String的操作"><a href="#String的操作" class="headerlink" title="String的操作"></a>String的操作</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set key value 将单个字符串值value关联到key,存储到Redis</span><br><span class="line">mset key value key value 同时设置一个或多个 key-value </span><br></pre></td></tr></table></figure><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get key返回key关联的字符串值#获取值，key为 name</span><br><span class="line">mget key key 获取多个值</span><br></pre></td></tr></table></figure><h3 id="值增加"><a href="#值增加" class="headerlink" title="值增加"></a>值增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">incr key            将key中储存的数字值增<span class="number">1</span>(key不存在,则初始化为<span class="number">0</span>,再加<span class="number">1</span>)</span><br><span class="line">incrby keynumber  将key中储存的数字值增加指定数字number</span><br></pre></td></tr></table></figure><h3 id="值减少"><a href="#值减少" class="headerlink" title="值减少"></a>值减少</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">decr key 将key中储存的数字值减<span class="number">1</span>(key不存在,则初始化为<span class="number">0</span>,再减<span class="number">1</span>)</span><br><span class="line">decrby keynumber  将key中储存的数字值减少指定数字number</span><br></pre></td></tr></table></figure><h3 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SETEX key seconds value 设置key-value，并设置过期时间</span><br></pre></td></tr></table></figure><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SETNX key value 设置一个key-value,如果这个key不存在则设置成功返回<span class="number">1</span>，否则设置不成功，返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">GETSET key value 设置一个key-value，把这个key以前的值返回</span><br></pre></td></tr></table></figure><h2 id="Key的操作"><a href="#Key的操作" class="headerlink" title="Key的操作"></a>Key的操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keys * 查看所有的key</span><br><span class="line">del key 删除指定的某个key</span><br><span class="line">expire key secnods  设置key的过期时间(secnods秒后过期)</span><br><span class="line">ttl key 查看key的过期时间</span><br><span class="line">flushall  清空整个redis服务器数据，所有的数据库全部清空</span><br><span class="line">flushdb  清除当前库</span><br><span class="line">select index 选择数据库,redis中默认有<span class="number">16</span>个数据库，名称分别为<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,,,<span class="number">15</span> ， index数据库索引</span><br><span class="line"></span><br><span class="line">exists key  查询key是否存在</span><br></pre></td></tr></table></figure><h2 id="List的操作"><a href="#List的操作" class="headerlink" title="List的操作"></a>List的操作</h2><p>一个键多个值</p><h3 id="增加-1"><a href="#增加-1" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lpush key value value 将一个或多个值value插入到列表key的表头(最左边)</span><br><span class="line">rpush key value value 将一个或多个值value插入到列表key的表尾(最右边)</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lrange key start stop 从左边开始寻找，返回列表key中指定区间内的元素，查询所有的stop为-<span class="number">1</span>即可</span><br><span class="line">    </span><br><span class="line">lindex key index  返回列表 key 中，下标为 index 的元素</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lpop key  移除并返回列表 key 的头(最左边)元素。</span><br><span class="line">rpop key 移除并返回列表 key 的尾(最右边)元素。</span><br><span class="line">    </span><br><span class="line">lrem key count value </span><br><span class="line">    根据count值移除列表key中与参数value相等的元素count&gt;<span class="number">0</span> : 从表头开始向表尾搜索，移除与value相等的元素，数量为 count。count&lt;<span class="number">0</span> : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为count的绝对值。count = <span class="number">0</span> : 移除表中所有与 value 相等的值</span><br></pre></td></tr></table></figure><h3 id="裁剪（取一部分）"><a href="#裁剪（取一部分）" class="headerlink" title="裁剪（取一部分）"></a>裁剪（取一部分）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ltrim key start stop  对一个列表进行修剪 ，保留范围内的，范围外的删除</span><br></pre></td></tr></table></figure><h3 id="Redis中实现栈和队列"><a href="#Redis中实现栈和队列" class="headerlink" title="Redis中实现栈和队列"></a>Redis中实现栈和队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">什么是队列：FIFO   先进先出</span><br><span class="line">什么是栈： FILO    先进后出</span><br><span class="line"></span><br><span class="line">在redis中是使用list数据结构来实现栈和队列的</span><br><span class="line">实现队列：控制从同一边进，另外一边出，就是队列</span><br><span class="line">        lpush   rpop</span><br><span class="line">        rpush   lpop</span><br><span class="line">实现栈：控制从同一边进，同一边出</span><br><span class="line">       lpush  lpop</span><br><span class="line">       rpush  rpop</span><br></pre></td></tr></table></figure><h2 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h2><p> set集合是一个无序的不含重复值的队列</p><h3 id="增加-2"><a href="#增加-2" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sadd key value value  将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略</span><br></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">smembers key  返回集合key中的所有成员。</span><br><span class="line">scard key  返回集合存储的key的基数 (集合元素的数量).如果key不存在,则返回 <span class="number">0</span>。</span><br><span class="line">    </span><br><span class="line">sismember key member</span><br><span class="line">    - 返回成员 member 是否是存储的集合 key的成员.</span><br><span class="line">- 如果member元素是集合key的成员，则返回<span class="number">1</span></span><br><span class="line">- 如果member元素不是key的成员，或者集合key不存在，则返回<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">srem key member 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略</span><br></pre></td></tr></table></figure><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SDIFF key [key ...]  返回一个集合与给定集合的差集的元素</span><br></pre></td></tr></table></figure><h2 id="ZSet的操作"><a href="#ZSet的操作" class="headerlink" title="ZSet的操作"></a>ZSet的操作</h2><p>ZSet(sorted sets)在Set基础上增加了“分数”，让set集合有了排序功能</p><h3 id="增加-3"><a href="#增加-3" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zadd key score value score value 将所有指定成员添加到键为key有序集合（sorted set）里面，如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置</span><br></pre></td></tr></table></figure><h3 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zcard key  返回key的有序集元素个数。key存在的时候，返回有序集的元素个数，否则返回<span class="number">0</span>。</span><br><span class="line">zcount key min max  返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。</span><br><span class="line">zrange key start stop [WITHSCORES] 返回存储在有序集合key中的指定范围的元素。 返回的元素可以认为是按得分从最低到最高排列。 如果得分相同，将按字典排序。返回给定范围内的元素列表（如果指定了WITHSCORES选项，将同时返回它们的得分）</span><br><span class="line"></span><br><span class="line">因为member可以有多个，相同的分数不同</span><br><span class="line">zrank key member 返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以<span class="number">0</span>为底，也就是说，score值最小的成员排名为<span class="number">0</span>。</span><br><span class="line">zreverank key member 返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以<span class="number">0</span>为底，也就是说，score值最大的成员排名为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zscore key member 返回有序集key中，成员member的score值。如果member元素不是有序集key的成员，或key不存在，返回nil。</span><br><span class="line"></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES] 返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。</span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max WITHSCORES LIMIT offset count 返回有序集合中指定分数区间内的成员，分数由低到高排序,LIMIT控制分页  min是最小分数，max最大分数， offset从哪里开始查询，count每页几条</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count返回有序集合中指定分数区间内的成员，分数由高到低排序,LIMIT控制分页</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>ZREVRANGEBYSCORE</td><td>是</td><td>指令</td></tr><tr><td>key</td><td>是</td><td>有序集合键名称</td></tr><tr><td>max</td><td>是</td><td>最大分数值,可使用”+inf”代替</td></tr><tr><td>min</td><td>是</td><td>最小分数值,可使用”-inf”代替</td></tr><tr><td>WITHSCORES</td><td>否</td><td>将成员分数一并返回</td></tr><tr><td>LIMIT</td><td>否</td><td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td></tr><tr><td>offset</td><td>否</td><td>返回结果起始位置</td></tr><tr><td>count</td><td>否</td><td>返回结果数量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]  进行排序返回</span><br><span class="line">zrange key start stop [WITHSCORES] 不进行排序返回</span><br></pre></td></tr></table></figure><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zpopmax key [count] 删除并返回有序集合key中的最多count个具有最高得分的成员。如未指定，count的默认值为<span class="number">1</span>。</span><br><span class="line">zpopmin key [count] 删除并返回有序集合key中的最多count个具有最低得分的成员。如未指定，count的默认值为<span class="number">1</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Hash的操作"><a href="#Hash的操作" class="headerlink" title="Hash的操作"></a>Hash的操作</h2><p>Hash类似于jdk中的Map,一个key下面以键值对的方式存储数据</p><p>注意key是一个键值对！！！</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230606200653986-4fe7b3.png" alt="image-20230606200653986"></p><h3 id="增加-4"><a href="#增加-4" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSET key field value  设置 key 指定的哈希集中指定字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段在哈希集中存在，它将被重写。</span><br><span class="line"></span><br><span class="line">HMSET key field value field value 批量添加name=value键值对到key这个hash类型</span><br></pre></td></tr></table></figure><h3 id="查询-3"><a href="#查询-3" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HGet key name  获取hash类型的name键对应的值</span><br><span class="line"></span><br><span class="line">HMGET key field field 批量获取hash类型的键对应的值</span><br><span class="line">hkeys key 返回哈希表 key 中的所有键</span><br><span class="line">hvals key 返回哈希表 key 中的所有值</span><br><span class="line">hgetall key 返回哈希表 key 中，所有的键和值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SORT key  对 list ,set ,zset进行排序</span><br><span class="line"></span><br><span class="line">SORT ages #对年龄集合进行排序 </span><br><span class="line">SORT ages DESC #对年龄集合进行排序,倒排</span><br><span class="line">SORT names ALPHA  #对姓名集合进行字典顺序排序</span><br><span class="line">SORT names LIMIT <span class="number">0</span> <span class="number">10</span> # 取names集合中，从第 <span class="number">0</span> 个元素，往后取<span class="number">10</span>个元素</span><br><span class="line">SORT names LIMIT <span class="number">0</span> <span class="number">5</span>  ALPHA DESC # 取集合中前<span class="number">5</span>个元素，按字典顺序倒排</span><br></pre></td></tr></table></figure><h1 id="认证设置"><a href="#认证设置" class="headerlink" title="认证设置"></a>认证设置</h1><h2 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONFIG SET 命令可以动态地调整 Redis 服务器的配置而无须重启,重启后失效</span><br><span class="line">CONFIG SET requirepass <span class="number">123456</span>   </span><br><span class="line">这是将密码临时设置成<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">要登录的话 auth <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改配置文件 redis.widows.conf ，</span><br><span class="line">寻找到# requirepass foobared 这个信息</span><br><span class="line">修改为 </span><br><span class="line">requirepass <span class="number">123456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Auth认证</span><br><span class="line">auth <span class="number">123456</span></span><br></pre></td></tr></table></figure><h1 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">导入Jedis依赖</span><br><span class="line">commons-pool2#连接池</span><br><span class="line">jedis    #Jedis核心包</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.5</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建连接</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span><span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">   <span class="comment">//端口</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line"><span class="comment">//超时时间,1秒超时</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">   <span class="comment">//jedis客户端</span></span><br><span class="line">   <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(host,port,timeout);</span><br><span class="line">   <span class="comment">//认证</span></span><br><span class="line">   jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">   <span class="comment">//执行操作,保存值</span></span><br><span class="line">   jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;simaqian&quot;</span>);</span><br><span class="line">   <span class="comment">//获取值</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">   System.out.print(result);</span><br><span class="line">   <span class="comment">//关闭连接</span></span><br><span class="line">   jedis.close();</span><br></pre></td></tr></table></figure><h2 id="连接池使用"><a href="#连接池使用" class="headerlink" title="连接池使用"></a>连接池使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建jedispool配置对象</span></span><br><span class="line">   <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">   <span class="comment">//2 做配置</span></span><br><span class="line">   <span class="comment">//最大空闲连接数</span></span><br><span class="line">   config.setMaxIdle(<span class="number">2</span>);</span><br><span class="line">   <span class="comment">//最大链接对象数</span></span><br><span class="line">   config.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">   <span class="comment">//链接超时时间</span></span><br><span class="line">   config.setMaxWaitMillis(<span class="number">1</span>*<span class="number">1000</span>);</span><br><span class="line">   <span class="comment">//获取连接是测试连接是否畅通</span></span><br><span class="line">   config.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//3 创建jedispool连接池对戏</span></span><br><span class="line">   <span class="comment">//参数：配置对象，redis主机地址 ，超时时间，密码</span></span><br><span class="line">   <span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>,<span class="number">1</span>*<span class="number">1000</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">   <span class="comment">//4 通过jedispool获取连接</span></span><br><span class="line">   <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br><span class="line">   <span class="comment">//5 执行操作</span></span><br><span class="line">   jedis.set(<span class="string">&quot;age&quot;</span>,<span class="number">10</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">   System.out.println(result);</span><br><span class="line">   <span class="comment">// 6 释放连接 , 底层做了兼容,如果是连接池操作就是释放,如果是连接操作就是关闭</span></span><br><span class="line">   jedis.close(); </span><br><span class="line">   <span class="comment">// 7 摧毁连接池-如果是真正项目中它应该是一个受spring管理的单例</span></span><br><span class="line">   pool.destroy();</span><br></pre></td></tr></table></figure><h2 id="封装类–可以自己寻找"><a href="#封装类–可以自己寻找" class="headerlink" title="封装类–可以自己寻找"></a>封装类–可以自己寻找</h2><p>工具类封装：JedisPool应该是单例的(想想你的Mybatis的DataSource也只是创建了一个)，为了方便使用，将<code>JedisPool</code>封装成工具。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接池对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RedisUtils</span> &#123;</span><br><span class="line">    <span class="comment">//使用枚举实现单例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"><span class="comment">//连接池对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//初始化链接池</span></span><br><span class="line">        <span class="comment">//1 创建连接池配置对象</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//2 进行配置-四个配置</span></span><br><span class="line">        <span class="comment">////最小连接数</span></span><br><span class="line">        config.setMaxIdle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//最大连接数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">11</span>);</span><br><span class="line"><span class="comment">//链接最长等待时间</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line"><span class="comment">//测试连接时是否畅通</span></span><br><span class="line">        config.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接池</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, host,port,timeout, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="keyword">public</span> Jedis <span class="title function_">getSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeSource</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置字符值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> getSource();</span><br><span class="line">        jedis.set(key, value);</span><br><span class="line">        closeSource(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置字符值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seconds ：过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setex</span><span class="params">(String key,<span class="type">int</span> seconds, String value)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> getSource();</span><br><span class="line">        jedis.setex(key,seconds, value);</span><br><span class="line">        closeSource(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置字符值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> getSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeSource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">byte</span>[] key, <span class="type">byte</span>[] value)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> getSource();</span><br><span class="line">        jedis.set(key, value);</span><br><span class="line">        closeSource(jedis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[]  get(<span class="type">byte</span>[] key) &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> getSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeSource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis的API操作"><a href="#Jedis的API操作" class="headerlink" title="Jedis的API操作"></a>Jedis的API操作</h2><p>使用jedis来操作redis的key和value，而value有很多种类型，和命令操作一样。</p><h3 id="key的操作"><a href="#key的操作" class="headerlink" title="key的操作"></a>key的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(jedis.keys(<span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="String的操作-1"><a href="#String的操作-1" class="headerlink" title="String的操作"></a>String的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//新增</span></span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//获取</span></span><br><span class="line">System.out.println(jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan1&quot;</span>));<span class="comment">//修改</span></span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));<span class="comment">//获取</span></span><br><span class="line">System.out.println(jedis.del(<span class="string">&quot;name&quot;</span>));<span class="comment">//删除</span></span><br><span class="line">System.out.println(jedis.keys(<span class="string">&quot;*&quot;</span>));<span class="comment">//查看所有的key</span></span><br></pre></td></tr></table></figure><h3 id="List的操作-1"><a href="#List的操作-1" class="headerlink" title="List的操作"></a>List的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.lpush(<span class="string">&quot;students1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>);<span class="comment">//添加数据</span></span><br><span class="line">System.out.println(jedis.lrange(<span class="string">&quot;students1&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));<span class="comment">//获取数据</span></span><br></pre></td></tr></table></figure><ul><li>排序操作，对于数字元素排序不需要加<code>SortingParams</code>，对于字符串需要指定<code>SortingParams</code>，并且指定使用assii值排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对数字排序</span></span><br><span class="line">jedis.flushDB();</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">jedis.lpush(<span class="string">&quot;nums&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">System.out.println(jedis.sort(<span class="string">&quot;nums&quot;</span>));</span><br><span class="line"><span class="comment">//指定排序方式</span></span><br><span class="line"><span class="type">SortingParams</span> <span class="variable">sortingParams1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortingParams</span>();</span><br><span class="line">sortingParams1.desc();</span><br><span class="line">System.out.println(jedis.sort(<span class="string">&quot;nums&quot;</span>, sortingParams1));</span><br><span class="line"></span><br><span class="line"><span class="comment">//对字母排序</span></span><br><span class="line">jedis.lpush(<span class="string">&quot;langues&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;php&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;ui&quot;</span>);</span><br><span class="line"><span class="type">SortingParams</span> <span class="variable">sortingParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortingParams</span>();</span><br><span class="line">sortingParams.alpha();</span><br><span class="line">sortingParams.desc();</span><br><span class="line"></span><br><span class="line">System.out.println(jedis.sort(<span class="string">&quot;langues&quot;</span>,sortingParams));</span><br></pre></td></tr></table></figure><h3 id="Set的操作"><a href="#Set的操作" class="headerlink" title="Set的操作"></a>Set的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;students2&quot;</span>,<span class="string">&quot;a1&quot;</span>,<span class="string">&quot;b1&quot;</span>,<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;b1&quot;</span>);<span class="comment">//添加数据</span></span><br><span class="line">System.out.println(jedis.smembers(<span class="string">&quot;students2&quot;</span>));<span class="comment">//获取成员</span></span><br></pre></td></tr></table></figure><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;students3&quot;</span>,<span class="string">&quot;student&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);<span class="comment">//添加数据</span></span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;students3&quot;</span>, <span class="string">&quot;student&quot;</span>)); <span class="comment">//获取数据</span></span><br></pre></td></tr></table></figure><h3 id="事务操作-–-了解"><a href="#事务操作-–-了解" class="headerlink" title="事务操作 – 了解"></a>事务操作 – 了解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">multi.incr(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">multi.incr(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">List&lt;Object&gt; result = multi.exec();</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">jedis.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接池</span></span><br><span class="line">pool.destory();</span><br></pre></td></tr></table></figure><h1 id="Springboot使用"><a href="#Springboot使用" class="headerlink" title="Springboot使用"></a>Springboot使用</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        加入springboot和Redis的依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis 属性信息</span></span><br><span class="line"><span class="comment">## redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">## redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="comment">## redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">## redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment">## 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">## 连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">## 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="comment">## 连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据源配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">2000ms</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">       redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">       System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1001</span>,<span class="string">&quot;Curry&quot;</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="string">&quot;Basketball&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;student&quot;</span>,student);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">student1</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">存储对象--需要序列化</span><br><span class="line">    加入一个对象，传出来就是一个对象</span><br><span class="line">所以对象接口实现<span class="keyword">implements</span> <span class="title class_">Serializable</span>  接口</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230606222705230-1dd37c.png" alt="image-20230606222705230"></p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p> Redis 提供了两种不同级别的持久化方式：RDB和AOF,可以通过修改redis.windows.conf来进行配置.在加载时，把两个数据做一个并集。 </p><h2 id="Redis持久化-RDB"><a href="#Redis持久化-RDB" class="headerlink" title="Redis持久化-RDB"></a>Redis持久化-RDB</h2><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照,默认开启该模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>  #至少在<span class="number">900</span>秒的时间段内至少有一次改变存储同步一次</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>  #至少在<span class="number">300</span>秒的时间段内至少有十次改变存储同步一次</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>   #至少在<span class="number">60</span>秒的时间段内至少有<span class="number">10000</span>次改变存储同步一次</span><br><span class="line">在这些情况下都会触发RDB存储</span><br><span class="line">如果想关闭RDB存储，那么将上面设置的三个关闭（注释掉）</span><br><span class="line">开启这个语句 #save <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Redis持久化-AOF"><a href="#Redis持久化-AOF" class="headerlink" title="Redis持久化-AOF"></a>Redis持久化-AOF</h2><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集,默认关闭该模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appendonly yes        #yes 开启,no 关闭</span><br><span class="line"></span><br><span class="line"># appendfsync always  #每次有新命令时就执行一次fsync </span><br><span class="line"></span><br><span class="line">appendfsync everysec  #每秒 fsync 一次 ,这里我们启用 everysec</span><br><span class="line"></span><br><span class="line"># appendfsync no      #从不fsync(交给操作系统来处理,可能很久才执行一次fsync)</span><br><span class="line">#其它的参数请大家看redis.conf配置文件详解</span><br></pre></td></tr></table></figure><h2 id="Redis持久配置"><a href="#Redis持久配置" class="headerlink" title="Redis持久配置"></a>Redis持久配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- bind # 指定的ip才能访问</span><br><span class="line">- port#默认端口</span><br><span class="line">- timeout#连接超时</span><br><span class="line">- loglevel#日志的级别</span><br><span class="line">- logfile#日志文件输出路径</span><br><span class="line">- databases#数据库数量</span><br><span class="line">- save <span class="number">900</span> <span class="number">1</span>#RDB持久方式，<span class="number">900</span> 秒有一个数据修改进行持久化</span><br><span class="line">- appendonely#AOF持久方式</span><br></pre></td></tr></table></figure><h1 id="Redis的淘汰策略"><a href="#Redis的淘汰策略" class="headerlink" title="Redis的淘汰策略"></a>Redis的淘汰策略</h1><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>最近最小使用 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="keyword">volatile</span>-lru ：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</span><br><span class="line">- <span class="keyword">volatile</span>-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</span><br><span class="line">- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</span><br><span class="line">- <span class="keyword">volatile</span>-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</span><br><span class="line">- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</span><br><span class="line">- no-enviction（驱逐）：禁止驱逐数据</span><br></pre></td></tr></table></figure><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改配置redis.window.conf，修改maxmemory，放开注释， 根据情况设置大小</span><br><span class="line">如果超过这个大小，那么就会按照你给定的策略进行淘汰</span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改配置redis.window.conf ，修改maxmemory-policy ，放开注释，按情况修改策略</span><br><span class="line">maxmemory-policy no-eviction#noeviction 为默认的策略，根据情况修改</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="/posts/62590.html"/>
      <url>/posts/62590.html</url>
      
        <content type="html"><![CDATA[<h1 id="mybaits"><a href="#mybaits" class="headerlink" title="mybaits"></a>mybaits</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">引入依赖</span><br><span class="line">  &lt;!--        引入mybatis依赖--&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line">        &lt;!--        引入jdbc--&gt;</span><br><span class="line">        &lt;!--mysql驱动依赖--&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">        &lt;!--        加入lokbok依赖--&gt;</span><br><span class="line">        &lt;!--自动生成getter setter toString--&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导入依赖，</span><br><span class="line">配置mybatis-config.xml文件</span><br><span class="line">配置jdbc.properties文件并且引入到mybatis-config.xml文件中</span><br><span class="line">创建Mapper.xml文件</span><br><span class="line">修改里面的内容</span><br><span class="line">Juint进行测试</span><br></pre></td></tr></table></figure><h3 id="配置mybatis-config-xml文件"><a href="#配置mybatis-config-xml文件" class="headerlink" title="配置mybatis-config.xml文件"></a>配置mybatis-config.xml文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--引入属性集配置文件 配置的jdbc--&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;properties resource=<span class="string">&quot;jdbc.properties&quot;</span>&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--环境--&gt;</span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;!--一组环境信息 --&gt;</span><br><span class="line">        &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">            &lt;!--事务管理--&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;!--数据源-使用连接池--&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;!--数据库的连接信息--&gt;</span><br><span class="line">                &lt;!-- 驱动信息--&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--引入映射配置文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--            下面是test--&gt;</span><br><span class="line">        &lt;!--        映射配置文件的路径--&gt;</span><br><span class="line">        &lt;!--        导入的是mapper.xml位置--&gt;</span><br><span class="line">        &lt;!-- &lt;mapper resource=<span class="string">&quot;Mapper/StudentMapper.xml&quot;</span>/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--    使用包的方式引入--&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;Mapper&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="配置jdbc-properties文件"><a href="#配置jdbc-properties文件" class="headerlink" title="配置jdbc.properties文件"></a>配置jdbc.properties文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/neu_soft?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="创建Mapper-xml文件"><a href="#创建Mapper-xml文件" class="headerlink" title="创建Mapper.xml文件"></a>创建Mapper.xml文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;!--每一个映射配置文件，都需要有个名称空间，以区别于其他的映射配置文件--&gt;</span><br><span class="line">&lt;!--测试的时候可以随便写--&gt;</span><br><span class="line">&lt;!--实际开发过程中,和Mapper对应，相同的位置--&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;Mapper.StudentMapper&quot;</span>&gt;</span><br><span class="line">    &lt;!--   resultType结果类型，每一行的是什么 必须写--&gt;</span><br><span class="line">    &lt;!--    parameterType 传递参数类型，不必须写--&gt;</span><br><span class="line">    &lt;!--    查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findAll&quot;</span> resultType=<span class="string">&quot;entiy.Student&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from student</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findById&quot;</span> resultType=<span class="string">&quot;entiy.Student&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from student</span><br><span class="line">        <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 自增键id获取 useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyColumn=<span class="string">&quot;id&quot;</span> <span class="comment">//数据库表里的名称  keyProperty=&quot;id&quot; //实体类的名称--&gt;</span></span><br><span class="line">    &lt;!--    自动返回，传入的参数对象里面的自增对象id返回--&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;add&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyColumn=<span class="string">&quot;id&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">student</span><span class="params">(sname, age, gender, major, birthday)</span></span><br><span class="line">        values (#&#123;sname&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;major&#125;, #&#123;birthday&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h3 id="Juint测试"><a href="#Juint测试" class="headerlink" title="Juint测试"></a>Juint测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">//获取回话工厂，连接数据库，获取连接 发送sql</span></span><br><span class="line">            <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">            <span class="comment">//回话对象</span></span><br><span class="line">            <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">            <span class="comment">// 发生sql</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 发送sql</span></span><br><span class="line"><span class="comment">             * 以insert为例：</span></span><br><span class="line"><span class="comment">             *          insert(String s,Object 0)</span></span><br><span class="line"><span class="comment">             *          String s :对应一个sql   名称空间.id</span></span><br><span class="line"><span class="comment">             *          Object o :要添加的对象，也就是sql中需要的参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            </span><br><span class="line">            List&lt;Student&gt; studentList = sqlSession.selectList(<span class="string">&quot;StudentMapper.findAll&quot;</span>);</span><br><span class="line">            studentList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 方法中需要多个变量，方法只能一个对象，那么将数据封装到对象里面</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="literal">null</span>, <span class="string">&quot;name&quot;</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="string">&quot;软件工厂&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sqlSession.insert(<span class="string">&quot;StudentMapper.add&quot;</span>, student);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(student.getId());</span><br><span class="line">            <span class="comment">//连接是非自动提交，即增删改需要手动提交才会使得数据库发生变化</span></span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="使用mapper映射–注意这几步骤就好了"><a href="#使用mapper映射–注意这几步骤就好了" class="headerlink" title="使用mapper映射–注意这几步骤就好了"></a>使用mapper映射–注意这几步骤就好了</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 两个包名的方式得一致，跟接口包名路径一致</span><br><span class="line">* 两个mapper的名字得一致</span><br><span class="line">* Mapper.xml里面的namespace 必须是对应接口的全限命名</span><br><span class="line">    &lt;mapper namespace=<span class="string">&quot;Mapper.StudentMapper&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">* sql(XML里面的文件)  id和方法名字一一对应</span><br><span class="line">* 总配置文件里面引用</span><br><span class="line">   &lt;mappers&gt;</span><br><span class="line">       &lt;!--            下面是test--&gt;</span><br><span class="line">       &lt;!--        映射配置文件的路径--&gt;</span><br><span class="line">       &lt;!--        导入的是mapper.xml位置--&gt;</span><br><span class="line">       &lt;!-- &lt;mapper resource=<span class="string">&quot;Mapper/StudentMapper.xml&quot;</span>/&gt;--&gt;</span><br><span class="line">       &lt;!--    使用包的方式引入--&gt;</span><br><span class="line">       &lt;<span class="keyword">package</span> name=<span class="string">&quot;Mapper&quot;</span>/&gt;</span><br><span class="line">   &lt;/mappers&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">详细    </span><br><span class="line">    * 接口开发：</span><br><span class="line">     *   创建接口  add update delete findById findAll</span><br><span class="line">     *   映射配置文件：</span><br><span class="line">     *      1、在哪放</span><br><span class="line">     *      2、叫什么</span><br><span class="line">     *      3、名称空间</span><br><span class="line">     *      4、sql的id</span><br><span class="line">     *      5、在总配置文件中通过package引入</span><br><span class="line">     *   提取了MybatisUtil工具类</span><br><span class="line">     *   测试</span><br><span class="line">     *      StudentMapper studentMapper = session.getMapper(StudentMapper.class);</span><br></pre></td></tr></table></figure><h2 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h2><h3 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">批量添加，传入参数是一个list结构的数据，xml文件这样写</span><br><span class="line">    &lt;!--批量加入--&gt;</span><br><span class="line">    &lt;!--    collection要进行遍历的是什么，list  arr --&gt;</span><br><span class="line">    &lt;!--     item表示每一次循环的对象，进行遍历，--&gt;</span><br><span class="line">    &lt;!--    separator表示分隔符，两个对象之间用什么符号进行分割--&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;batchInsert&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">student</span><span class="params">(sname, age, gender, major, birthday)</span></span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=<span class="string">&quot;list&quot;</span> item=<span class="string">&quot;stu&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            (#&#123;stu.sname&#125;, #&#123;stu.age&#125;, #&#123;stu.gender&#125;, #&#123;stu.major&#125;, #&#123;stu.birthday&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">批量进行删除，传入一个主键的list，然后进行删除，sql语句关键是where id <span class="title function_">in</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line">    </span><br><span class="line">       &lt;!-- 批量删除--&gt;</span><br><span class="line">    &lt;delete id=<span class="string">&quot;batchRemove&quot;</span>&gt;</span><br><span class="line">        delete</span><br><span class="line">        from student</span><br><span class="line">        where id in</span><br><span class="line">        &lt;foreach collection=<span class="string">&quot;list&quot;</span> item=<span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">分页查询,分页查询主要来讲，还是用的limit进行限制分割，</span><br><span class="line">    注意在进行计算的时候，startIndex = （当前的页码-<span class="number">1</span>） *pageSize</span><br><span class="line">    一般前端只会传入当前页码和当前的Size，后端计算startIndex，由于xml 的#&#123;&#125;会调用Getter方法，所以我们只需要重写一下GetterStartIndex方法即可</span><br><span class="line">    </span><br><span class="line">    一般会给当前页码和pageSize默认值</span><br><span class="line">    </span><br><span class="line">    总页码也是一般是计算出来的，获取到数据的总条数，然后除以Size去模就可以，一般用三元运算符，看下面的例子：</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count % pageSize == <span class="number">0</span> ? count / pageSize : count / pageSize + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">limit <span class="number">0</span>,<span class="number">5</span>  第一个参数是从哪里开始查，第二个参数是表示查询几个数据</span><br><span class="line">   select *</span><br><span class="line">   from student limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于模糊查询，使用的是like关键字，加上%%是进行全字段匹配，</span><br><span class="line">       &lt;!--模糊查询--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findByConditions&quot;</span> resultType=<span class="string">&quot;entity.Student&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from student</span><br><span class="line">        where sname like <span class="title function_">concat</span><span class="params">(<span class="string">&#x27;%&#x27;</span>, #&#123;sname&#125;, <span class="string">&#x27;%&#x27;</span>)</span></span><br><span class="line">          AND gender like <span class="title function_">concat</span><span class="params">(<span class="string">&#x27;%&#x27;</span>, #&#123;gender&#125;, <span class="string">&#x27;%&#x27;</span>)</span></span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于条件查询来讲，可以先对一个表进行操作，即先将表数据拿出来，然后再拿出数据的表里面继续进行操作，这就叫条件查询，eg:查询分页  -- 生成一个新表进行分页</span><br><span class="line">    </span><br><span class="line">下面就是一个先条件再分页的一个写法：</span><br><span class="line"> select *</span><br><span class="line">        from</span><br><span class="line">        (select *</span><br><span class="line">        from student</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;sname!=null and sname != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">                sname like <span class="title function_">concat</span><span class="params">(<span class="string">&#x27;%&#x27;</span>, #&#123;sname&#125;, <span class="string">&#x27;%&#x27;</span>)</span></span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">        ) stu</span><br><span class="line"></span><br><span class="line">        limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br></pre></td></tr></table></figure><h2 id="用xml进行条件判断"><a href="#用xml进行条件判断" class="headerlink" title="用xml进行条件判断"></a>用xml进行条件判断</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xml里面也有where标签和<span class="keyword">if</span>标签，where标签用来包含<span class="keyword">if</span>标签，其中<span class="keyword">if</span>标签里面的test和正常<span class="keyword">if</span>语句里面一样。</span><br><span class="line">     &lt;!--不确定条件--&gt;</span><br><span class="line">    &lt;!--<span class="keyword">if</span>里面的test判断，用双引号的话不用#--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findByCondictions2&quot;</span> resultType=<span class="string">&quot;entity.Student&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from student</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;sname!=null and sname != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">                sname like <span class="title function_">concat</span><span class="params">(<span class="string">&#x27;%&#x27;</span>, #&#123;sname&#125;, <span class="string">&#x27;%&#x27;</span>)</span></span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;gender!=null&quot;</span>&gt;</span><br><span class="line">                <span class="type">AND</span> <span class="variable">gender</span> <span class="operator">=</span> #&#123;gender&#125;,</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;startAge!=null&quot;</span>&gt;</span><br><span class="line">                AND age &amp;gt; #&#123;startAge&#125;</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;endAge!=null&quot;</span>&gt;</span><br><span class="line">                AND age &amp;lt;#&#123;endAge&#125;</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;major!=null and major !=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">                <span class="type">AND</span> <span class="variable">major</span> <span class="operator">=</span> #&#123;major&#125;</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="对映关系"><a href="#对映关系" class="headerlink" title="对映关系"></a>对映关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表与表之间有一对一，一对多，多对一的对应关系</span><br><span class="line">一对多或者多对一 都有外键进行连接</span><br><span class="line"></span><br><span class="line">多对多的关系，一般有另一个表来进行维护才可以使用</span><br></pre></td></tr></table></figure><h3 id="一对一关系处理"><a href="#一对一关系处理" class="headerlink" title="一对一关系处理"></a>一对一关系处理</h3><p>首先要会基本的连表查询，内连接查询，两张表能匹配的信息才会显示，如下图</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230523145558144-d79f19.png" alt="image-20230523145558144"></p><p>员工信息全部展示，外连接查询–分为左外连接和右外连接</p><p>左连接查询 – 左表完全显示，右表匹配左表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--   select e.*, d.`dname`</span><br><span class="line">          from t_emp e,</span><br><span class="line">               t_dept d</span><br><span class="line">          where e.`id` = d.`id`--&gt;</span><br><span class="line">  &lt;!--    内连接查询--&gt;</span><br><span class="line">  &lt;!-- select e.*, d.`dname`</span><br><span class="line">          from t_emp e INNER JOIN</span><br><span class="line">               t_dept d</span><br><span class="line">          ON e.`id` = d.`id`--&gt;</span><br><span class="line">  &lt;!--左连接--&gt;</span><br><span class="line">  &lt;!--select e.*, d.`dname`</span><br><span class="line">          from t_emp e</span><br><span class="line">                   LEFT JOIN</span><br><span class="line">               t_dept d</span><br><span class="line">               ON e.`id` = d.`id`--&gt;</span><br></pre></td></tr></table></figure><p>关于一对一问题的具体解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- type表示实体类的全限定名--&gt;</span><br><span class="line">&lt;!--type表示下面映射关系所属的一个实体类位置--&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;simpleEmpMap&quot;</span> type=<span class="string">&quot;entity.Emp&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 主键特殊 ,用id--&gt;</span><br><span class="line">    &lt;!--        表示数据库的列名以及实体属性名称--&gt;</span><br><span class="line">    &lt;!--   column 表示数据库列名也叫字段，property 属性，是上面传入type里面的属性名称     --&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;ename&quot;</span> property=<span class="string">&quot;ename&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;dept_id&quot;</span> property=<span class="string">&quot;deptId&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;!--员工关联的部门对象  property表示type传入的属性里面的名称，javaType所属的类型--&gt;</span><br><span class="line">    &lt;association property=<span class="string">&quot;dept&quot;</span> javaType=<span class="string">&quot;entity.Dept&quot;</span>&gt;</span><br><span class="line">        &lt;!--这个里面column是联查的时候所用到的名称</span><br><span class="line">            如果没有重新命名，那么就是数据库里面的名称，如果重命名，那么就需要改成重命名的名称</span><br><span class="line">            注意如果是外键，应该是外键的名称，而不是数据库原来表的列名称</span><br><span class="line">        ，property是javaType属性里面的名称--&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;dname&quot;</span> property=<span class="string">&quot;dname&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h3 id="一对多关系处理"><a href="#一对多关系处理" class="headerlink" title="一对多关系处理"></a>一对多关系处理</h3><h4 id="联查，相当于一次性查出来，然后赋值给元素"><a href="#联查，相当于一次性查出来，然后赋值给元素" class="headerlink" title="联查，相当于一次性查出来，然后赋值给元素"></a>联查，相当于一次性查出来，然后赋值给元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;deptMap&quot;</span> type=<span class="string">&quot;entity.Dept&quot;</span>&gt;</span><br><span class="line">     &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>&gt;&lt;/id&gt;</span><br><span class="line">     &lt;result column=<span class="string">&quot;dname&quot;</span> property=<span class="string">&quot;dname&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">    <span class="comment">//注意这个collection</span></span><br><span class="line">    <span class="comment">//  &lt;!--ofType 表示这个集合里面单个元素是什么实体--&gt;</span></span><br><span class="line">     &lt;collection property=<span class="string">&quot;empList&quot;</span> ofType=<span class="string">&quot;entity.Emp&quot;</span>&gt;</span><br><span class="line">         &lt;id column=<span class="string">&quot;eid&quot;</span> property=<span class="string">&quot;id&quot;</span>&gt;&lt;/id&gt;</span><br><span class="line">         &lt;result column=<span class="string">&quot;ename&quot;</span> property=<span class="string">&quot;ename&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">     &lt;/collection&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--    使用联查的方法，一次性查出来赋值给元素--&gt;</span><br><span class="line"> &lt;/resultMap&gt; </span><br><span class="line">    </span><br><span class="line">       &lt;select id=<span class="string">&quot;findAll&quot;</span> resultMap=<span class="string">&quot;deptMap&quot;</span>&gt;</span><br><span class="line">     select d.*, e.id eid, e.ename</span><br><span class="line">     from t_dept d</span><br><span class="line">              LEFT JOIN t_emp e</span><br><span class="line">                        ON d.id = e.dept_id</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure><h4 id="分两次查询，第一次查询用第一个sql查询外层的，第二个查询里面嵌套的多个对象"><a href="#分两次查询，第一次查询用第一个sql查询外层的，第二个查询里面嵌套的多个对象" class="headerlink" title="分两次查询，第一次查询用第一个sql查询外层的，第二个查询里面嵌套的多个对象"></a>分两次查询，第一次查询用第一个sql查询外层的，第二个查询里面嵌套的多个对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;deptMapID&quot;</span> type=<span class="string">&quot;entity.Dept&quot;</span>&gt;</span><br><span class="line">       &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>&gt;&lt;/id&gt;</span><br><span class="line">       &lt;result column=<span class="string">&quot;dname&quot;</span> property=<span class="string">&quot;dname&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">       &lt;collection property=<span class="string">&quot;empList&quot;</span></span><br><span class="line">                   ofType=<span class="string">&quot;entity.Emp&quot;</span></span><br><span class="line">                   select=<span class="string">&quot;Mapper.EmpMapper.findByDeptId&quot;</span></span><br><span class="line">                   column=<span class="string">&quot;id&quot;</span></span><br><span class="line">       &gt;</span><br><span class="line">           &lt;!-- select 属性是用来选中这个sql语句位于哪里，注意返回值要进行匹配，用namespace.id来进行匹配--&gt;</span><br><span class="line">           &lt;!--column表示上面的sql要传入的参数，这个参数是第一个sql里面查询出来的数据里面的参数，必须匹配--&gt;</span><br><span class="line">       &lt;/collection&gt;</span><br><span class="line">   &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">第一次查询</span><br><span class="line">   &lt;select id=<span class="string">&quot;findById&quot;</span> resultMap=<span class="string">&quot;deptMapID&quot;</span>&gt;</span><br><span class="line">       select id,dname</span><br><span class="line">       from t_dept</span><br><span class="line">       <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fetchType=<span class="string">&quot;lazy&quot;</span>    &lt;!--   fetchType lazy懒加载，需要的时候再查询，不需要的时候不查询--&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;deptMapID&quot;</span> type=<span class="string">&quot;entity.Dept&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span>&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;dname&quot;</span> property=<span class="string">&quot;dname&quot;</span>&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=<span class="string">&quot;empList&quot;</span></span><br><span class="line">                    ofType=<span class="string">&quot;entity.Emp&quot;</span></span><br><span class="line">                    select=<span class="string">&quot;Mapper.EmpMapper.findByDeptId&quot;</span></span><br><span class="line">                    column=<span class="string">&quot;id&quot;</span></span><br><span class="line">                    fetchType=<span class="string">&quot;lazy&quot;</span></span><br><span class="line">        &gt;</span><br><span class="line">            &lt;!-- select 属性是用来选中这个sql语句位于哪里，注意返回值要进行匹配，用namespace.id来进行匹配--&gt;</span><br><span class="line">            &lt;!--column表示上面的sql要传入的参数，这个参数是第一个sql里面查询出来的数据里面的参数，必须匹配--&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  一级缓存: SqlSession级别缓存,缓存对象存储周期为第一次获取,到sqlsession被销毁掉,或是sqlSession().clearCache();  </span><br><span class="line"></span><br><span class="line"> 二级缓存:SqlSessionFactory级别缓存,缓存对象存储周期为第一次获取,到SqlSessionFactory被销毁掉(应用停止了);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">相邻两次查询，对于第二次查询不会进行 ，因为有缓存，这叫一级缓存，也叫回话缓存，当你打开一次回话session的话就默认开启了一级缓存</span><br><span class="line"></span><br><span class="line">二级缓存（没用）  sqlSesionFactory 工厂的缓存，需要设置</span><br></pre></td></tr></table></figure><h2 id="相同sql语句的提取"><a href="#相同sql语句的提取" class="headerlink" title="相同sql语句的提取"></a>相同sql语句的提取</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">再进行xml语句进行数据库操作的时候，避免不了出现一些相同的sql语句,重复复制粘贴影响代码，在这里可以使用sql标签进行引出，然后在使用的地方用include进行引入</span><br><span class="line">    </span><br><span class="line">    &lt;!--抽取总文件--&gt;</span><br><span class="line">    &lt;sql id=<span class="string">&quot;conditionSql&quot;</span>&gt;</span><br><span class="line">        (select *</span><br><span class="line">        from student</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;major!=null and major !=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">                <span class="type">AND</span> <span class="variable">major</span> <span class="operator">=</span> #&#123;major&#125;</span><br><span class="line">            &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">        ) stu</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在要调用的地方，直接用include进行引入，refid就是id名字，这样就可以省略很多代码</span></span><br><span class="line">    &lt;include refid=<span class="string">&quot;conditionSql&quot;</span>&gt;&lt;/include&gt;</span><br></pre></td></tr></table></figure><h2 id="配置namespace别名"><a href="#配置namespace别名" class="headerlink" title="配置namespace别名"></a>配置namespace别名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以发现在xml里面的resultType进行配置的时候，每次都要引入实体类的全限定名，这样很麻烦，所以为了简化操作，我们可以把包名进行别名，然后在xml里面进行引用的时候，就直接写实体类名称即可。</span><br><span class="line"></span><br><span class="line">在mybatis-config.xml总的配置文件里面进行配置如下信息，下面的是将entity的包引入，无别名，之后再xml里面就可以直接写entity的名字</span><br><span class="line">    &lt;!--    配置别名给实体类--&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;entity&quot;</span>/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat,用来进行字符串拼接，对于参数没有个数要求 </span><br><span class="line">eg:concat(&#x27;%&#x27;, #&#123;sname&#125;, &#x27;%&#x27;)</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="xml里面的-方法"><a href="#xml里面的-方法" class="headerlink" title="xml里面的#方法"></a>xml里面的#方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于xml里面的#&#123;value&#125; 来进行参数调用，如果传入参数那么直接赋值，如果传入的是一个对象，就去调用这个对象对应的属性名称的Get方法来进行返回值</span><br></pre></td></tr></table></figure><h3 id="对于传入多个参数的问题"><a href="#对于传入多个参数的问题" class="headerlink" title="对于传入多个参数的问题"></a>对于传入多个参数的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于接口来讲，有多个参数传入的时候，xml文件不会识别哪个参数对应哪个，所以需要自己指定，而<span class="meta">@Param</span>这个注解，就用来解决这个问题，<span class="meta">@Param(&#x27;value&#x27;)</span> 其中value就是绑定的xml里面的数据，而后面跟的是一个形参，命名无所谓。</span><br><span class="line"><span class="meta">@Param(&quot;sname&quot;)</span>String s, <span class="meta">@Param(&quot;gender&quot;)</span> Integer g);</span><br></pre></td></tr></table></figure><h3 id="出现数据库名称和实体类名称不一致"><a href="#出现数据库名称和实体类名称不一致" class="headerlink" title="出现数据库名称和实体类名称不一致"></a>出现数据库名称和实体类名称不一致</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">起别名：字段名称和selelct名称一致就可以</span><br><span class="line">select id,ename,dept_id deptId<span class="comment">//修改和数据库一样,第一个是数据库名称，第二个是属性名称</span></span><br><span class="line">第二种方法：resultMap替换resultType</span><br></pre></td></tr></table></figure><h3 id="mybatis里面的foreach标签"><a href="#mybatis里面的foreach标签" class="headerlink" title="mybatis里面的foreach标签"></a>mybatis里面的foreach标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**在mybatis动态有以下标签**</span><br><span class="line"></span><br><span class="line">- foreach用于循环</span><br><span class="line">- if 用于判断</span><br><span class="line">- foreach中的属性：</span><br><span class="line">  - collection=&quot;list&quot;：使用集合的话，默认就是使用list与collection来接收</span><br><span class="line">  - separator=&quot;,&quot; ：每遍历一次后的分隔符</span><br><span class="line">  - item=&quot;p&quot; ：每次遍历的这个对象别名，可以修改</span><br><span class="line">  - index：获取当前遍历索引(一般没有作用)</span><br><span class="line">  - open：拼接sql以什么开始</span><br><span class="line">  - close：拼接sql以什么结束</span><br></pre></td></tr></table></figure><h3 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于分页查询来讲，一般要给前端返回总数据，总页数，每条记录的信息，但是对于整个系统来讲，不可能只查询一个实体类的信息，那么对于多个实体类都要进行返回每条记录的信息，那么List每一个初始胡都得初始成实体太复杂，所以为了通用，要使用泛型，再定义的时候使用泛型即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer totalPages;</span><br><span class="line">    <span class="keyword">private</span> Integer totalRows;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; rowData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">那么在使用的时候声明就ok:PageBean&lt;Student&gt; </span><br></pre></td></tr></table></figure><h3 id="出现错误回滚"><a href="#出现错误回滚" class="headerlink" title="出现错误回滚"></a>出现错误回滚</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">回滚（Rollback）指的是程序或数据处理错误，将程序或数据恢复到上一次正确状态的行为。回滚包括程序回滚和数据回滚等类型。</span><br><span class="line"></span><br><span class="line">mybatis 进行回滚出错后  session.rollback(); </span><br><span class="line"></span><br><span class="line">一般都这样处理：</span><br><span class="line">  <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//用方法生成了session</span></span><br><span class="line">            session = MybatisUtil.getSqlSession();</span><br><span class="line">            <span class="comment">//mybatis生成了接口的实现类对象</span></span><br><span class="line">            <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> session.getMapper(StudentMapper.class);</span><br><span class="line">            studentMapper.delete(id);</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            session.rollback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个自动导入getter setter toString的依赖：</span><br><span class="line">使用方法，加注解：</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"></span><br><span class="line"> * pom 中加入内容</span><br><span class="line"> * 实体类上加入注解 <span class="meta">@Data</span></span><br><span class="line"> * 安装lombok插件</span><br><span class="line"> *</span><br><span class="line"> * data里面不带全参构造</span><br><span class="line"> * <span class="meta">@AllArgsConstructor</span>  全参构造</span><br><span class="line"> * <span class="meta">@NoArgsConstructor</span>   无参构造</span><br></pre></td></tr></table></figure><h1 id="配置打印日志"><a href="#配置打印日志" class="headerlink" title="配置打印日志"></a>配置打印日志</h1><h2 id="导入日志依赖"><a href="#导入日志依赖" class="headerlink" title="导入日志依赖"></a>导入日志依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--日志依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.7</span><span class="number">.36</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"> <span class="attr">log4j.properties：文件配置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> #5.控制台输出+自定义布局</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG,my</span></span><br><span class="line"><span class="comment">#指定输出器</span></span><br><span class="line"><span class="attr">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="comment">#指定布局器(自定义布局)</span></span><br><span class="line"><span class="comment">#指定布局为自定义布局</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">#指定在自定义布局的格式，%d -- 表示当前系统时间，%t -- 执行该业务的线程名称，%p -- 日记器的级别，-5 -- 5表示输出字符的个数，符号表示右对齐</span></span><br><span class="line"><span class="comment">#%c -- 表示指定业务所在的类的完全限定名(包名.类名)，%m -- 输出额外信息，%n -- 表示换行</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout.ConversionPattern</span>=<span class="string">%-5p - %m%n</span></span><br><span class="line"><span class="comment">#设置package（可以是自定义的包也可以是api的包）输出级别，#trace - 可以看见sql查询的信息</span></span><br><span class="line"><span class="attr">log4j.logger.com.hxj</span>=<span class="string">trace </span></span><br></pre></td></tr></table></figure><h1 id="Mybatis逆向工程"><a href="#Mybatis逆向工程" class="headerlink" title="Mybatis逆向工程"></a>Mybatis逆向工程</h1><p>在项目中 通常不在表中加外键约束  dba对进行维护会比较方便   开发过程中测试也会比较方便 一般在代码中维护约束关系</p><p>作用：可以 通过数据表 生成 实体类  Mapper接口 映射配置文件</p><p>1、创建一个新的Maven工程</p><p>2、引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 是否覆盖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 自动生成的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 和你的数据库版本一致 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.39<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、创建mybatis-generator.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis3Simple:只生成简单的增删改查 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;MySqlTables&quot;</span>  <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;&gt;&lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;&gt;&lt;/plugin&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="comment">&lt;!-- 阻止成成注释 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="comment">&lt;!-- 阻止生成的注释包含时间戳 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库链接URL，用户名、密码 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        如果数据库是8.0版本以上是com.mysql.cj.jdbc.Driver--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/neu_soft?useSSL=false<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时</span></span><br><span class="line"><span class="comment">        把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成模型的包名和位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;entity&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成映射文件的包名和位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;Mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成DAO的包名和位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;product&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Product&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 实体类的属性名称和数据库表的字段名称一致 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useActualColumnNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;MySql&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;table tableName=&quot;goods&quot; domainObjectName=&quot;Goods&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/table&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;table tableName=&quot;stu&quot;</span></span><br><span class="line"><span class="comment">               domainObjectName=&quot;Student&quot; enableCountByExample=&quot;false&quot;</span></span><br><span class="line"><span class="comment">               enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;</span></span><br><span class="line"><span class="comment">                enableDeleteByExample=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/table&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、刷新Maven</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/1653440197059-16847619997922-4e35a1.png" alt="1653440197059"></p><p>5、生成代码</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/1653440236217-16847620327084-f05982.png" alt="1653440236217"></p><h1 id="遗忘的sql语句"><a href="#遗忘的sql语句" class="headerlink" title="遗忘的sql语句"></a>遗忘的sql语句</h1><h2 id="批量添加-1"><a href="#批量添加-1" class="headerlink" title="批量添加"></a>批量添加</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into product (name,price) values (&quot;农夫山泉矿泉水&quot;,2),(&quot;友友鸡瓜&quot;,11)</span><br></pre></td></tr></table></figure><h2 id="批量删除-1"><a href="#批量删除-1" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from product where id in ( ? , ? ) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息队列</title>
      <link href="/posts/450.html"/>
      <url>/posts/450.html</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ安装使用"><a href="#RocketMQ安装使用" class="headerlink" title="RocketMQ安装使用"></a>RocketMQ安装使用</h1><h2 id="RocketMQ安装"><a href="#RocketMQ安装" class="headerlink" title="RocketMQ安装"></a>RocketMQ安装</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下载地址：http:<span class="comment">//rocketmq.apache.org/release_notes/release-notes-4.2.0</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608152420961-43e03d.png" alt="image-20230608152420961"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下载完成后直接进行解压,文件如下所示</span><br><span class="line">Bin : 可执行文件目录</span><br><span class="line">Conf：配置文件目录</span><br><span class="line">Lib : 依赖库，一堆Jar包</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608152507119-0b6429.png" alt="image-20230608152507119"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置 ROCKETMQ_HOME，注意路径到安装包的外围，即压缩完成的路径</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608153029851-1b9192.png" alt="image-20230608153029851"></p><h3 id="启动NameServer"><a href="#启动NameServer" class="headerlink" title="启动NameServer"></a>启动NameServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cmd命令框执行进入至MQ文件夹\bin下，然后执行 start mqnamesrv.cmd，启动NameServer。</span><br><span class="line"></span><br><span class="line">会弹出提示框，不报错就证明成功</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608153205590-f135bb.png" alt="image-20230608153205590"></p><h3 id="启动Broker"><a href="#启动Broker" class="headerlink" title="启动Broker"></a>启动Broker</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入至MQ文件夹\bin下，修改Bean目录下的 runbroker.cmd 中JVM占用内存大小</span><br><span class="line"></span><br><span class="line">由于默认JVM启动，所占用内存过大，为了避免资源浪费以及电脑卡顿，所以将这里的内存占用调小</span><br><span class="line">这里整体缩小一倍，也可以继续进行修改</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608153437521-45a7c4.png" alt="image-20230608153437521"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">继续打开CMD,CMD执行start mqbroker.cmd -n <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9876</span> autoCreateTopicEnable=<span class="literal">true</span> ，启动Broker。,-n 后面的服务器以及端口号，autoCreateTopicEnable 这个是设置可以自动创建标题，成功后会弹出来一个窗口，别关闭</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608153833415-a91937.png" alt="image-20230608153833415"></p><h3 id="RocketMQ存储结构"><a href="#RocketMQ存储结构" class="headerlink" title="RocketMQ存储结构"></a>RocketMQ存储结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RocketMQ安装好之后会在用户目录下产生一个store目录用来存储相关数据：</span><br><span class="line">- Commitlog : 消息是存储,在commitlog目录中，以mapperdFile文件顺序存储消息。</span><br><span class="line">- Config : 存放运行期间的配置文件</span><br><span class="line">- Consumerqueue : 该目录中存放的是队列，consume queue存放着commitlog中的消息的索引位置</span><br><span class="line">- Index :存放着消息索引文件 indexFile，用来实现根据key进行消息的快速查询</span><br><span class="line">- Abort : 该文件在broker启动后自动创建，正常关闭abort会消失</span><br><span class="line">- Checkpoint ：记录 Commitlog ，Consumerqueue 和index 文件的最后刷盘时间戳</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608153901493-1499fb.png" alt="image-20230608153901493"></p><h2 id="RocketMQ插件"><a href="#RocketMQ插件" class="headerlink" title="RocketMQ插件"></a>RocketMQ插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于RocketMQ的一个可视化插件</span><br><span class="line">RocketMQ可视化管理插件下载地址：https:<span class="comment">//github.com/apache/rocketmq-externals/releases</span></span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">解压后，修改配置：src/main/resource/application.properties ,这里需要指向Name Server 的地址和端口 如下：</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608154229447-b23226.png" alt="image-20230608154229447"></p><h3 id="打包插件"><a href="#打包插件" class="headerlink" title="打包插件"></a>打包插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">回到安装目录(pom.xml所在目录),执行:mvn clean <span class="keyword">package</span> -Dmaven.test.skip=<span class="literal">true</span>，然后会在target目录生成打包后的jar文件</span><br></pre></td></tr></table></figure><h3 id="启动插件"><a href="#启动插件" class="headerlink" title="启动插件"></a>启动插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入 target 目录，CMD执行 `java -jar rocketmq-console-ng-<span class="number">1.0</span><span class="number">.0</span>.jar， 访问 http:<span class="comment">//localhost:8080</span></span><br></pre></td></tr></table></figure><h2 id="创建批处理文件"><a href="#创建批处理文件" class="headerlink" title="创建批处理文件"></a>创建批处理文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于启动RocketMQ每次需要三个CMD才能启动，所以为了简化操作，我们写一个批处理文件进行运行即可。将要执行的三个操作依次写入.bat文件，之后双击bat文件就可以直接运行。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608154439177-2f383a.png" alt="image-20230608154439177"></p><h1 id="RockerMQ原理"><a href="#RockerMQ原理" class="headerlink" title="RockerMQ原理"></a>RockerMQ原理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RocketMQ开发官方文档：</span><br><span class="line"></span><br><span class="line">https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608194900778-87345b.png" alt="image-20230608194900778"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RocketMQ架构上主要分为四部分，如上图所示</span><br><span class="line"></span><br><span class="line">Producer</span><br><span class="line">消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</span><br><span class="line"></span><br><span class="line">Consumer</span><br><span class="line">消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</span><br><span class="line"></span><br><span class="line">Broker</span><br><span class="line">Broker主要负责消息的存储、投递和查询以及服务高可用保证。</span><br><span class="line"></span><br><span class="line">NameServer</span><br><span class="line">NameServer是一个Broker与Topic路由的注册中心支持Broker的动态注册与发现，主要包括两个功能</span><br><span class="line"></span><br><span class="line">- Broker管理</span><br><span class="line">  NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活。</span><br><span class="line"></span><br><span class="line">- 路由信息管理</span><br><span class="line">  每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608202532666-12cc8b.png" alt="image-20230608202532666"></p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</span><br><span class="line"></span><br><span class="line">RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</span><br><span class="line"></span><br><span class="line"> Producer会使用一定的算法选择把消息发送到哪个master的某个queue中。</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer 支持两种消费形式：拉取式消费、推动式消费。（主动，被动），RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息，不同的 Consumer Group可以消费同一个Topic。</span><br><span class="line"></span><br><span class="line">一个Queue是不能被同一个ConsumerGroup中的多个Consumer消费的，目的是减少资源竞争提升整体性能。</span><br></pre></td></tr></table></figure><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</span><br><span class="line"></span><br><span class="line">Topic表示一类消息的集合，每个topic主题包含若干条message消息，每条message消息只能属于一个topic主题，Topic是RocketMQ进行消息订阅的基本单位。</span><br><span class="line">    </span><br><span class="line">Topic是消息的一级分类，Tag是消息的二级分类</span><br></pre></td></tr></table></figure><h2 id="MessageQueue队列"><a href="#MessageQueue队列" class="headerlink" title="MessageQueue队列"></a>MessageQueue队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个Topic中可以包含多个Queue，一 个Topic的Queue也被称为一个Topic中消息的分区（Partition）。 在一个Consumer Group内，一个Queue最多只能分配给一个Consumer，一个Cosumer可以分配得到多个Queue。这样的分配规则，每个Queue只有一个消费者，可以避免消费过程中的多线程处理和资源锁定，有效提高各Consumer消费的并行度和处理效率。</span><br><span class="line"></span><br><span class="line">消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的 Consumer将不能消费消息。如果一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608204043761-264edf.png" alt="image-20230608204043761"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个Topic可以对应多个消费者 ，一个Queue只能对应一个组中的一个消费者。</span><br><span class="line"></span><br><span class="line">为了防止消息紊乱，一个Consumer Group 中的Consumer都是订阅相同Topic下的</span><br></pre></td></tr></table></figure><h2 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue分为 写队列 和 读队列，默认创建数量是都是<span class="number">4</span> ，这个读写队列是从逻辑上进行划分在物理上读/写是一个队列，Producer发送的消息进入写队列 ，Consumer从读队列获取数据，一般情况下读写队列数量是一样的。</span><br><span class="line"></span><br><span class="line">可以通过可视化界面修改Topic中的队列数量</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608204156288-a65efc.png" alt="image-20230608204156288"></p><h2 id="MessageId-Key"><a href="#MessageId-Key" class="headerlink" title="MessageId&#x2F;Key"></a>MessageId&#x2F;Key</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。 不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)， </span><br><span class="line"></span><br><span class="line">当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。 </span><br></pre></td></tr></table></figure><h2 id="Rebalance重新负载"><a href="#Rebalance重新负载" class="headerlink" title="Rebalance重新负载"></a>Rebalance重新负载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当消费者数量或者Queue的数量修改，Rebalance是把⼀个Topic下的多个Queue重新分配给Consumer Group下的Consumer。目的是增加消费能力。</span><br><span class="line"></span><br><span class="line">由于一个队列只分配给一个Consumer,那么当Consumer Group中的消费者数量大于队列数量，那么多出来的Consumer分配不到队列。</span><br></pre></td></tr></table></figure><h2 id="消息拉取模式"><a href="#消息拉取模式" class="headerlink" title="消息拉取模式"></a>消息拉取模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消息到消费分为：拉取式 pull ,和推送是 push </span><br><span class="line"></span><br><span class="line">- Pull:拉取式，需要消费者间隔一定时间就去遍历关联的Queue,实时性差但是便于应用控制消息的拉取</span><br><span class="line"></span><br><span class="line">- Push:推送式，封装了Queue的遍历，实时性强，但是对系统资源占用比较多。</span><br></pre></td></tr></table></figure><h2 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 广播模式:同一个Consumer Group 下的所有Consumer都会受到同一个Topic的所有消息。同一个消息可能会被消费多次。</span><br><span class="line"></span><br><span class="line">- 集群模式:同一个Gonsumer Group 下的Consumer平分同一个Topic下的消息。同一个消息只是被消费一次。</span><br></pre></td></tr></table></figure><h2 id="Queue的分配算法"><a href="#Queue的分配算法" class="headerlink" title="Queue的分配算法"></a>Queue的分配算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue是如何分配给Consumer的，这对应了四种算法：平均分配策略，环形平均策略，一致性Hash策略，同机房策略。</span><br><span class="line"></span><br><span class="line">- 平均分配【默认】：根据 qeueuCount / consumerCount 作为每个消费者平均分配数量，如果多出来的queue就再依次逐个分配给Consumer。</span><br><span class="line"></span><br><span class="line">- 环形平均策略：根据消费者的顺序，一个一个的分配Queue即可类似于发扑克牌。</span><br><span class="line"></span><br><span class="line">- 一致性Hash策略 ： 该算法将Consumer的Hash值作为节点放到Hash环上，然后将Queue的hash值也放入Hash环上，通过顺时针进行就近分配。</span><br><span class="line"></span><br><span class="line">- 同机房策略：该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</span><br><span class="line"></span><br><span class="line">平均分配性能比较高，一致性Hash性能不高，但是能减少Rebalance，如果Consumer数量变动频繁可以使用一致性Hash。</span><br></pre></td></tr></table></figure><h2 id="Offset管理"><a href="#Offset管理" class="headerlink" title="Offset管理"></a>Offset管理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RockertMQ通过Offset来维护Consumer的消费进度，比如：消费者从哪个位置开始持续消费消息的？这里有三个枚举来指定从什么位置消费</span><br><span class="line"></span><br><span class="line">- `CONSUME_FROM_LAST_OFFSET：从queue的最后一条消息开始消费` </span><br><span class="line">- `CONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费` </span><br><span class="line">- `CONSUME_FROM_TIMESTAMP：从某个时间戳位置的消息开始消费`。</span><br><span class="line"></span><br><span class="line">消费者消费结束之后，会向Consumer会提交其消费进度offset给Broker。Offset信息的存储分为本地 Offset管理 和远程Offset管理</span><br><span class="line"></span><br><span class="line">- 远程Offset管理:Brocker通过 store/config/consumerOffset.json 文件以JSON方式来存储offset相关数据以json的形式：适用于集群模式</span><br><span class="line">- 本地Offset管理：offset相关数据以json的形式持久化到Consumer本地磁盘文件中，路径为当前用户主目录下的.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json ：适用于广播模式</span><br><span class="line"></span><br><span class="line">Offset的同步提交与异步提交: 集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种： </span><br><span class="line"></span><br><span class="line">- 同步提交：消费者在消费完一批消息后会向broker提交这些消息的offset，等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取 nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费 者是阻塞的。其严重影响了消费者的吞吐量。 </span><br><span class="line">- 异步提交：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset 后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取 nextBeginOffset。</span><br></pre></td></tr></table></figure><h2 id="消息的清理"><a href="#消息的清理" class="headerlink" title="消息的清理"></a>消息的清理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消息不会被单独清理，消息是顺序存储到commitlog的，消息是以commitlog为单位进行清理，RocketMQ有自己的清理规则，默认是<span class="number">72</span>小时候后进行清理</span><br><span class="line"></span><br><span class="line">- 到达时间清理点，自动清理过期的文件(凌晨<span class="number">4</span>点)</span><br><span class="line"></span><br><span class="line">- 磁盘空间使用率达到了过期清理阈值(<span class="number">75</span>%),自动清理过期的文件。</span><br><span class="line"></span><br><span class="line">- 磁盘占用率达到清理阈值(<span class="number">85</span>%)，开始按照设定的规则清理文件，从老的文件开始。</span><br><span class="line"></span><br><span class="line">- 磁盘占用率达到系统危险阈值(<span class="number">90</span>%),拒绝写入数据。</span><br></pre></td></tr></table></figure><h1 id="RockerMQ入门"><a href="#RockerMQ入门" class="headerlink" title="RockerMQ入门"></a>RockerMQ入门</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">注意和安装的MQ版本一致</span><br></pre></td></tr></table></figure><h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体 可以理解为Topic 是一级分类  Tag是二级分类</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;hello608&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    <span class="comment">//消息体，获取一个字节数组</span></span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer ： MQ生产者 ， 可以指定组名 producerGroupName</span><br><span class="line">    </span><br><span class="line">producer.setNamesrvAddr ： 指定Name Server地址，用作Brocker发现。注意IP和启动name server服务时指定的IP保持一致。</span><br><span class="line"></span><br><span class="line">producer.start() ： 启动 生产者</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic_log&quot;</span>,<span class="string">&quot;tags_error&quot;</span>,(<span class="string">&quot;我是消息&quot;</span>+i).getBytes()) ：消息，参数为：topic，tags,内容</span><br><span class="line"></span><br><span class="line">producer.send(message) : 发送消息</span><br><span class="line"></span><br><span class="line">SendResult ：发送结果，其中包含</span><br><span class="line">  - sendStatus=SEND_OK ：发送状态</span><br><span class="line">  - msgId ：producer 创建的消息ID</span><br><span class="line">  - offsetMsgId ：Brocker创建的消息ID </span><br><span class="line">  - messageQueue ：消息存储的队列</span><br><span class="line">producer.shutdown():关闭生产者</span><br></pre></td></tr></table></figure><h2 id="检查发送"><a href="#检查发送" class="headerlink" title="检查发送"></a>检查发送</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当发生完成后，可以去可视化的界面去进行查看</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608200925418-025123.png" alt="image-20230608200925418"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230608201157409-7a769c.png" alt="image-20230608201157409"></p><h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;ConsumerTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;hello608&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 注册回调实现类来处理从broker拉取回来的消息，这是一个监听</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">//打印消息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (MessageExt messageExt : msgs) &#123;</span><br><span class="line">                    <span class="type">byte</span>[] body = messageExt.getBody();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//接收到消息体，构建消息体字符串，设置编码。进行答应消息内容</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到的消息&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body, RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标记该消息已经被成功消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者实例</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer  ：消费者 ， 可以指定 consumerGroupName</span><br><span class="line">consumer.setNamesrvAddr : 设置name server 地址</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET) ：从什么位置开始消费</span><br><span class="line">consumer.subscribe(<span class="string">&quot;topic_log&quot;</span>, <span class="string">&quot;tags_error&quot;</span>) ：订阅某个topic下的某个tags的消息</span><br><span class="line">consumer.registerMessageListener ：注册消息监听器，拿到消息后，进行消息处理。</span><br><span class="line"></span><br><span class="line">    ConsumeConcurrentlyStatus ：消费者消费结果状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS代表成功,ConsumeConcurrentlyStatus.RECONSUME_LATER代表消费失败，稍后重试，会进行多次重试</span><br></pre></td></tr></table></figure><h1 id="RockerMQ使用"><a href="#RockerMQ使用" class="headerlink" title="RockerMQ使用"></a>RockerMQ使用</h1><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于消费者代码类似，所以不再写  </span><br><span class="line">由于方法众多，所以只学习了几种方法，要想看具体的，可以看老师的文档具体学习</span><br></pre></td></tr></table></figure><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">同步消息是发送者发送消息，需要等待结果的返回，才能继续发送第二条消息，这是一种阻塞式模型，虽然消息可靠性高，但是阻塞导致性能低。API ： <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.send(message); 代码示例：</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体 可以理解为Topic 是一级分类  Tag是二级分类</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;hello608&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    <span class="comment">//消息体，获取一个字节数组</span></span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">    <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;AsyncProducer608&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="comment">//设置失败之后的重试次数</span></span><br><span class="line">    producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">messageCount</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 根据消息数量实例化倒计时计算器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch2</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch2</span>(messageCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(</span><br><span class="line">                <span class="comment">//topic标识</span></span><br><span class="line">                <span class="string">&quot;hello608&quot;</span>,</span><br><span class="line">                <span class="comment">//Tag标识</span></span><br><span class="line">                <span class="string">&quot;async&quot;</span>,</span><br><span class="line">                <span class="comment">//业务特点标识</span></span><br><span class="line">                <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">        producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="comment">//成功的回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//失败的回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待5s，因为直接关闭，因为是一个异步请求，如果还没有发送就关闭了，就会报错，所以等待5s才关闭</span></span><br><span class="line"><span class="comment">//    Thread.sleep(5000);  也是等待五秒</span></span><br><span class="line">    countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这种方式指的是发送者发送消息后无需等待Broker的结果返回，Broker也不会返回结果，该方式性能最高，但是消息可靠性低。</span><br><span class="line"></span><br><span class="line">... 省略...</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;asyn-topic&quot;</span>, <span class="string">&quot;sms&quot;</span>, <span class="string">&quot;我是消息&quot;</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">producer.sendOneway(message);</span><br><span class="line"></span><br><span class="line">sendOneway 单向发送是没有返回结果值的。</span><br></pre></td></tr></table></figure><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">延迟消息即：把消息写到Broker后需要延迟一定时间才能被消费 ， 在RocketMQ中消息的延迟时间不能任意指定，而是由特定的等级(<span class="number">1</span> 到 <span class="number">18</span>)来指定，分别有：</span><br><span class="line"></span><br><span class="line">messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">可以通过修改配置来增加级别，比如在mq安装目录的 broker.conf 文件中增加 </span><br><span class="line"></span><br><span class="line">messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h <span class="number">2d</span>  这个时候总共就有<span class="number">19</span>个level。</span><br><span class="line">    </span><br><span class="line">    主要就是发生前加入代码  message.setDelayTimeLevel(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="发送者-1"><a href="#发送者-1" class="headerlink" title="发送者"></a>发送者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageProducer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">      <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;delayProducer608&quot;</span>);</span><br><span class="line">      <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">      producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动生产者</span></span><br><span class="line">      producer.start();</span><br><span class="line">      <span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">          <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;hello608&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          producer.send(message);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 关闭生产者</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot使用"><a href="#SpringBoot使用" class="headerlink" title="SpringBoot使用"></a>SpringBoot使用</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    关键导入的东西！！！！！</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动类（不变）"><a href="#启动类（不变）" class="headerlink" title="启动类（不变）"></a>启动类（不变）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ApplicationStart.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">  <span class="comment"># 是否开启自动配置</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="comment"># 发送同一类消息设置为同一个group，保证唯一默认不需要设置，rocketmq会使用ip@pid（pid代表jvm名字）作为唯一标识</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">&quot;service-pay-producer&quot;</span></span><br><span class="line">    <span class="comment"># 消息最大长度 默认 1024 * 4 (4M)</span></span><br><span class="line">    <span class="attr">max-message-size:</span> <span class="number">4096</span></span><br><span class="line">    <span class="comment"># 发送消息超时时间，默认 3000</span></span><br><span class="line">    <span class="attr">send-message-timeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="comment"># 发送消息失败重试次数，默认2</span></span><br><span class="line">    <span class="attr">retry-times-when-send-failed:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">retry-times-when-send-async-failed:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="普通消息-1"><a href="#普通消息-1" class="headerlink" title="普通消息"></a>普通消息</h2><h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">//创建对象，交给Spring管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQProducer</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//只要引入依赖就有这个类型</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取超时的事件，从yml获取到</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.send-message-timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer messageTimeOut;</span><br><span class="line"> </span><br><span class="line">    发送的第一个参数是Topic</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送普通消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">sendMsg</span><span class="params">(String msgBody)</span>&#123;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> rocketMQTemplate.syncSend(<span class="string">&quot;queue_test_topic&quot;</span>, MessageBuilder.withPayload(msgBody).build());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送异步消息 在SendCallback中可处理相关成功失败时的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAsyncMsg</span><span class="params">(String msgBody)</span>&#123;</span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;queue_test_topic&quot;</span>,MessageBuilder.withPayload(msgBody).build(), <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理消息发送成功逻辑</span></span><br><span class="line">             System.out.println(sendResult);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理消息发送异常逻辑</span></span><br><span class="line">           e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送延时消息&lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * 在start版本中 延时消息一共分为18个等级分别为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&lt;br/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMsg</span><span class="params">(String msgBody, Integer delayLevel)</span>&#123;</span><br><span class="line">       rocketMQTemplate.syncSend(<span class="string">&quot;queue_test_topic&quot;</span>,MessageBuilder.withPayload(msgBody).build(),messageTimeOut,delayLevel);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送带tag的消息,直接在topic后面加上&quot;:tag&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTagMsg</span><span class="params">(String msgBody)</span>&#123;</span><br><span class="line">       rocketMQTemplate.syncSend(<span class="string">&quot;queue_test_topic:tag1&quot;</span>,MessageBuilder.withPayload(msgBody).build());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h3><p>实现：RocketMQListener<MessageExt> 接口消费消息，通过@RocketMQMessageListener指定consumerGroup,topic,和tags</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rocketmq 消息监听，<span class="doctag">@RocketMQMessageListener</span>中的selectorExpression为tag，默认为*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;queue_test_topic&quot;,selectorExpression=&quot;*&quot;,consumerGroup = &quot;queue_group_test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQMsgListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt message)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, CharsetUtil.UTF_8);</span><br><span class="line">        log.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQProducer rocketMQProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(String msg)</span>  &#123;</span><br><span class="line">        <span class="comment">//formats: `topicName:tags`</span></span><br><span class="line">        <span class="keyword">return</span> rocketMQProducer.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="部署虚拟机"><a href="#部署虚拟机" class="headerlink" title="部署虚拟机"></a>部署虚拟机</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull foxiswho/rocketmq:server-<span class="number">4.3</span><span class="number">.2</span> </span><br><span class="line">docker pull foxiswho/rocketmq:broker-<span class="number">4.3</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><h2 id="创建数据挂载目录"><a href="#创建数据挂载目录" class="headerlink" title="创建数据挂载目录"></a>创建数据挂载目录</h2><p>为了修改目录的时候可以同步修改，目录提前创建,去创建目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/dockerrocketmq/rmqserver01/logs</span><br><span class="line">mkdir -p /usr/dockerrocketmq/rmqserver01/store</span><br><span class="line">mkdir -p /usr/dockerrocketmq/rmqbroker01/logs</span><br><span class="line">mkdir -p /usr/dockerrocketmq/rmqbroker01/store</span><br><span class="line">mkdir -p /usr/dockerrocketmq/rmqbroker01/conf</span><br></pre></td></tr></table></figure><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>创建配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vi /usr/dockerrocketmq/rmqbroker01/conf/broker.conf</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">加入这些内容</span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span>:<span class="number">9876</span></span><br><span class="line">brokerClusterName = <span class="type">DefaultCluster</span></span><br><span class="line"><span class="variable">brokerName</span> <span class="operator">=</span> broker-<span class="type">a</span></span><br><span class="line"><span class="variable">brokerId</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = <span class="type">ASYNC_MASTER</span></span><br><span class="line"><span class="variable">flushDiskType</span> <span class="operator">=</span> <span class="type">ASYNC_FLUSH</span></span><br><span class="line"><span class="variable">brokerIP1</span> <span class="operator">=</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span></span><br><span class="line">listenPort=<span class="number">10911</span></span><br><span class="line"></span><br><span class="line">要修改的地方有IP 地址</span><br></pre></td></tr></table></figure><h2 id="创建-nameserver容器"><a href="#创建-nameserver容器" class="headerlink" title="创建 nameserver容器"></a>创建 nameserver容器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker create -p <span class="number">9876</span>:<span class="number">9876</span> --name rmqserver01 -e <span class="string">&quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m&quot;</span> -e <span class="string">&quot;JAVA_OPTS=-Duser.home=/opt&quot;</span> -v /usr/dockerrocketmq/rmqserver01/logs:/opt/logs -v /usr/dockerrocketmq/rmqserver01/store:/opt/store foxiswho/rocketmq:server-<span class="number">4.3</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker start rmqserver01</span><br></pre></td></tr></table></figure><h2 id="创建mq容器"><a href="#创建mq容器" class="headerlink" title="创建mq容器"></a>创建mq容器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -it -d --net host --name rmqbroker01 -e <span class="string">&quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m&quot;</span> -e <span class="string">&quot;JAVA_OPTS=-Duser.home=/opt&quot;</span> -v /usr/dockerrocketmq/rmqbroker01/conf/broker.conf:/etc/rocketmq/broker.conf -v /usr/dockerrocketmq/rmqbroker01/logs:/opt/logs -v /usr/dockerrocketmq/rmqbroker01/store:/opt/store --privileged=<span class="literal">true</span> foxiswho/rocketmq:broker-<span class="number">4.3</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><h2 id="创建控制台管理工具容器"><a href="#创建控制台管理工具容器" class="headerlink" title="创建控制台管理工具容器"></a>创建控制台管理工具容器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -id -e <span class="string">&quot;JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.153.1:9876;192.168.153.1:9877 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span> -p <span class="number">9090</span>:<span class="number">8080</span> -t styletang/rocketmq-console-ng:<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    </span><br><span class="line">其实在修改配置文件，<span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span>:<span class="number">9877</span> 没有使用到<span class="number">9877</span>端口，其实可以没用</span><br></pre></td></tr></table></figure><h2 id="开放防火墙，或者安全组"><a href="#开放防火墙，或者安全组" class="headerlink" title="开放防火墙，或者安全组"></a>开放防火墙，或者安全组</h2><p>如果关闭了就不需要重复关闭</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别开放三个端口</span></span><br><span class="line">firewall-cmd --permanent --zone=<span class="keyword">public</span> --add-port=<span class="number">9876</span>/tcp</span><br><span class="line">firewall-cmd --permanent --zone=<span class="keyword">public</span> --add-port=<span class="number">10911</span>/tcp</span><br><span class="line">firewall-cmd --permanent --zone=<span class="keyword">public</span> --add-port=<span class="number">9090</span>/tcp</span><br></pre></td></tr></table></figure><h2 id="立即生效"><a href="#立即生效" class="headerlink" title="立即生效"></a>立即生效</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudAlibaba</title>
      <link href="/posts/20004.html"/>
      <url>/posts/20004.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title="SpringCloudAlibaba"></a>SpringCloudAlibaba</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">感觉没用，所以没写，如果有需要，去老师的文件里面寻找</span><br></pre></td></tr></table></figure><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于需要版本限制，所以提前了解版本限制，有助于后续开发过程中错误的出现，将版本对应的版本放置在这里</span><br><span class="line"></span><br><span class="line">Spring Cloud Alibaba是Spring Cloud的子项目 ，Spring Cloud 基于Spring Boot，所以我们在选择版本的时候需要考虑三个框架的版本</span><br></pre></td></tr></table></figure><table><thead><tr><th>Spring Cloud Version</th><th>Spring Cloud Alibaba Version</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>Spring Cloud Greenwich</td><td>2.1.x.RELEASE</td><td>2.1.x.RELEASE</td></tr><tr><td>Spring Cloud Finchley</td><td>2.0.x.RELEASE</td><td>2.0.x.RELEASE</td></tr><tr><td>Spring Cloud Edgware</td><td>1.5.x.RELEASE</td><td>1.5.x.RELEASE</td></tr></tbody></table><h1 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h1><h2 id="Nacos服务安装"><a href="#Nacos服务安装" class="headerlink" title="Nacos服务安装"></a>Nacos服务安装</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">官方提供了Nacos的服务端供我们下载使用，我们启动Nacos后将我们的微服务注册进入Nacos即可。</span><br><span class="line"></span><br><span class="line">下载地址：https:<span class="comment">//github.com/alibaba/nacos/releases</span></span><br><span class="line"></span><br><span class="line">解压后，启动Nacos： </span><br><span class="line"></span><br><span class="line">- windows执行bin目录下的startup命令 ：startup.cmd -m standalone</span><br><span class="line">- linux 执行 ：sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问Nacos，端口8848：http://127.0.0.1:8848/nacos/index.html ，用户名和密码都是：nacos</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609105700866-690340.png" alt="image-20230609105700866"></p><p>登录成功之后</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200416193215863-b152af.png" alt="在这里插入图片描述"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609110420746-1cc0ea.png" alt="image-20230609110420746"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609110454520-1eab01.png" alt="image-20230609110454520"></p><h2 id="部署在虚拟机"><a href="#部署在虚拟机" class="headerlink" title="部署在虚拟机"></a>部署在虚拟机</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tar -xzvf nacos-server-<span class="number">2.0</span><span class="number">.3</span>.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进入到安装目录下\bin文件</span><br><span class="line"></span><br><span class="line">去启动 startup.cmd （确保有这个文件）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linux 执行 ：sh startup.sh -m standalone</span><br><span class="line"></span><br><span class="line">查询 : ps -ef|grep nacos</span><br></pre></td></tr></table></figure><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609110559000-8fa3bc.png" alt="image-20230609110559000"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">去尝试构建一个上面的服务，如下所示的结构</span><br><span class="line">springcloudalibaba-parent</span><br><span class="line">pom.xml</span><br><span class="line">springcloudalibaba-user-common<span class="comment">//公共的user实体，服务调用传输对象</span></span><br><span class="line">springcloudalibaba-order-server-<span class="number">1020</span><span class="comment">//消费者服务</span></span><br><span class="line">springcloudalibaba-user-server-<span class="number">1010</span><span class="comment">//提供者服务</span></span><br></pre></td></tr></table></figure><h3 id="父项目搭建"><a href="#父项目搭建" class="headerlink" title="父项目搭建"></a>父项目搭建</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">搭建父工程springcloudalibaba-parent并管理相关依赖，Spring boot版本为<span class="number">2.1</span><span class="number">.3</span>.RELEASE，Spring Cloud 版本为Greenwich.SR1，Alibaba版本为<span class="number">2.1</span><span class="number">.0</span>.RELEASE</span><br><span class="line"></span><br><span class="line"> &lt;!--公共的一些配置--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;!--编码--&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;!--        java版本--&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--SpringBoot--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.2</span><span class="number">.5</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--SpringCloud--&gt;</span><br><span class="line">    &lt;!--<span class="number">2.</span>管理 SpringCloud的jar包--&gt;</span><br><span class="line">    &lt;!-- 放置在管理依赖里面--&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!--导入spring cloud alibaba 的依赖--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.2</span><span class="number">.1</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;!--导入spring cloud依赖--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;Hoxton.SR3&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">3.</span>这里是所有子项目都可以用的jar包，每个模块都需要使用的，就放在这个里面--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a>服务注册到Nacos</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--导入nacos发现的依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--加入WEB依赖是为了方便后面写Controller--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建配置类加上<span class="meta">@EnableDiscoveryClient</span>注解开启服务发现功能</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务注册与发现</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//加上注解使得nacos可以发现它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServerApplication1010</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserServerApplication1010.class) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置文件主要配置端口，服务名，已经nacos注册中心地址</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">1010</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: user-server</span><br><span class="line">#配置nacos的注册中心地址</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span>:<span class="number">8848</span>#注册中心地址</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动服务提供者，观察Nacos服务列表 ， user-server已经注册进去了</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609113949442-cb8461.png" alt="image-20230609113949442"></p><h1 id="OpenFeign-通讯以及负载均衡"><a href="#OpenFeign-通讯以及负载均衡" class="headerlink" title="OpenFeign -通讯以及负载均衡"></a>OpenFeign -通讯以及负载均衡</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feign是一个声明式的http客户端，使用Feign可以实现声明式REST调用，它的目的就是让WebService调用更加简单。Feign整合了Ribbon和SpringMvc注解，这让Feign的客户端接口看起来就像一个Controller。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。同时Feign整合了Hystrix，可以很容易的实现服务熔断和降级(关于Hystrix我们后面再讲)。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607205858232-c61c90.png" alt="image-20230607205858232"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所以对于上面两个方法，这个一个就解决了，所以大部分用这个，所以从头到尾讲一下配置过程</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--导入nacos发现的依赖--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--加入WEB依赖是为了方便后面写Controller--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--依赖common模块就可以引用实体类了--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;curry.neusoft&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;springcloudalibaba-common&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--<span class="number">2.</span>导入Feign的包--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="启动类配置"><a href="#启动类配置" class="headerlink" title="启动类配置"></a>启动类配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主配置类增加<span class="meta">@EnableFeignClients</span>标签 , 其value属性可以指定Feign的客户端接口的包,当然也可以省略value属性</span><br><span class="line"><span class="meta">@EnableFeignClients</span> :开启Feign支持</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//注意后面的路径</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;curry.neusoft&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServerApplication1010</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderServerApplication1010.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yml配置-1"><a href="#yml配置-1" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1020</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-server</span></span><br><span class="line">  <span class="comment">#配置nacos的注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span><span class="string">:8848</span><span class="comment">#注册中心地址</span></span><br></pre></td></tr></table></figure><h3 id="Feign的客户端接口"><a href="#Feign的客户端接口" class="headerlink" title="Feign的客户端接口"></a>Feign的客户端接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feign的客户端接口是用来调用微服务的，编写了一个用来调用用户服务的客户端接口，相当于模块间通讯的</span><br><span class="line"><span class="comment">//标记为FeignClient  就可以调用其他服务的接口了</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//直接将UserController上面的接口复制过来，注意如果Usercontroller上面有路径记得该路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-server&quot;)</span> : user-server是用户服务的服务名字，Feign根据服务名能够在注册中心找到目标服务的通信地址</span><br><span class="line">    </span><br><span class="line">方法：把要调用的目标服务的controller方法拷贝过来，然后去掉方法体即可。</span><br><span class="line"></span><br><span class="line"> 即：服务名要一致 ， url路径要一致 ， 参数要一致 ， 返回值类型要一致。</span><br><span class="line">建议 ：服务名直接去目标服务配置中拷贝 ， 方法直接从目标服务controller中拷贝</span><br></pre></td></tr></table></figure><h3 id="编写Controller使用Feign接口"><a href="#编写Controller使用Feign接口" class="headerlink" title="编写Controller使用Feign接口"></a>编写Controller使用Feign接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserFeignClient userFeignClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sadas&quot;</span>);</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(id, <span class="string">&quot;1231231&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">123.12</span>), id, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据order对象的用户id去查用户</span></span><br><span class="line">        <span class="comment">//使用Feign调用用户服务获取User</span></span><br><span class="line">        ResultBean&lt;User&gt; bean = userFeignClient.getById(order.getUserId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过远程调用传递来的对象，转化为了LinkedHashMap  形式的数据，需要申明泛型</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) bean.getData();</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.success(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接用浏览器访问这个方法的地址，</span><br><span class="line"></span><br><span class="line">多次请求发现依然默认使用了轮询策略</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">要使用Feign，除了导入依赖之外，需要主配置类通过<span class="meta">@EnableFeignClients(value=&quot;&quot;)</span>注解开启Feign,通过value属性指定了Feign的扫描包。</span><br><span class="line">   同时需要为Feign编写客户端接口，接口上需要注解<span class="meta">@FeignClient</span>标签。 当程序启动，注解了<span class="meta">@FeignClient</span>的接口将会被扫描到然后交给Spring管理。</span><br><span class="line"></span><br><span class="line">当请求发起，会使用jdk的动态代理方式代理接口，生成相应的RequestTemplate，Feign会为每个方法生成一个RequestTemplate同时封装好http信息，如：url，请求参数等等</span><br><span class="line"></span><br><span class="line">       最终RequestTemplate生成request请求，交给Http客户端(UrlConnection,HttpClient,OkHttp)。然后Http客户端会交给LoadBalancerClient，使用Ribbon的负载均衡发起调用。</span><br></pre></td></tr></table></figure><h2 id="Feign的参数配置-扩展"><a href="#Feign的参数配置-扩展" class="headerlink" title="Feign的参数配置(扩展)"></a>Feign的参数配置(扩展)</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feign已经集成了Ribbon，所以它的负载均衡配置基于Ribbon配置即可，这里使用xml简单配置负载均衡策略如下</span><br><span class="line"></span><br><span class="line">user-server:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><h3 id="Feign的超时配置"><a href="#Feign的超时配置" class="headerlink" title="Feign的超时配置"></a>Feign的超时配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果在服务调用时出现了 “feign.RetryableException : Read timed out...”错误日志，说明Ribbon处理超时 ，我们可以配置Ribbon的超时时间：</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">ConnectTimeout: <span class="number">3000</span></span><br><span class="line">    ReadTimeout: <span class="number">6000</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"> 如果服务调用出现“com.netflix.hystrix.exception.HystrixRuntimeException：.. timed - out and no fallback available” 错误日志，是因为Hystrix超时，默认Feign集成了Hystrix，但是高版本是关闭了Hystrix，我们可以配置Hystrix超时时间：</span><br><span class="line">        </span><br><span class="line">feign:</span><br><span class="line">   hystrix:</span><br><span class="line">       enabled: <span class="literal">true</span> #开启熔断支持</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        execution:</span><br><span class="line">          isolation:</span><br><span class="line">            thread:</span><br><span class="line">              timeoutInMilliseconds: <span class="number">6000</span>   #hystrix超时时间      </span><br></pre></td></tr></table></figure><h3 id="Feign开启日志调试"><a href="#Feign开启日志调试" class="headerlink" title="Feign开启日志调试"></a>Feign开启日志调试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">有的时候我们需要看到Feign的调用过程中的参数及相应，我们可以对Feign的日志进行配置，Feign支持如下几种日志模式来决定日志记录内容多少：</span><br><span class="line"></span><br><span class="line">- NONE，不记录（DEFAULT）。</span><br><span class="line">- BASIC，仅记录请求方法和URL以及响应状态代码和执行时间。</span><br><span class="line">- HEADERS，记录基本信息以及请求和响应标头。</span><br><span class="line">- FULL，记录请求和响应的标题，正文和元数据。</span><br></pre></td></tr></table></figure><h4 id="创建Feign配置类"><a href="#创建Feign配置类" class="headerlink" title="创建Feign配置类"></a>创建Feign配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;<span class="comment">//打印Feign的所有日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置日志打印级别"><a href="#配置日志打印级别" class="headerlink" title="配置日志打印级别"></a>配置日志打印级别</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置UserFeignClient的日志打印级别，上面的配置打印Feign的那些内容，下面这个是配置日志框架打印日志的级别，不修改可能打印不出来日志，DEBUG打印日志调试信息。</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    cn.neusoft: debug</span><br></pre></td></tr></table></figure><h3 id="Feign开启GZIP"><a href="#Feign开启GZIP" class="headerlink" title="Feign开启GZIP"></a>Feign开启GZIP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以通过开启Feign的数据压缩传输来节省网络开销，但是压缩数据会增加CPU的开销，所以太小的数据没必要压缩，可以通过压缩大小阈值来控制，配置如下：</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  compression:</span><br><span class="line">    request:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">      min-request-size: <span class="number">1024</span> #最小阈值，小于这个不压缩</span><br><span class="line">      mime-types: text/xml,application/xml,application/json #压缩哪些类型的数据</span><br><span class="line">    response:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果要双向调用，其实原理是一样的，在另一个模块里面调用另一个，相互调用是不冲突的</span><br></pre></td></tr></table></figure><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Nacos作为Spring Cloud Alibaba的一个重要组件，它不仅可以用作服务注册与发现，也可以用来替代Spring Cloud Config作为统一配置文件管理，而且他的使用更为简单和人性化。</span><br></pre></td></tr></table></figure><h2 id="nacos添加配置"><a href="#nacos添加配置" class="headerlink" title="nacos添加配置"></a>nacos添加配置</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609144832403-b7ef19.png" alt="image-20230609144832403"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里定义了一个名字为application-user-dev.yaml的配置，使用的是YAML格式。</span><br><span class="line"></span><br><span class="line">Data ID : 非常重要，可以看做是配置的文件的名字，在程序中拉取配置文件的时候需要指定Data ID。</span><br><span class="line"></span><br><span class="line">Group: 分组，默认是 DEFAULT_GROUP , 可以针对不同的项目指定不同的配置组。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609144958074-41b67b.png" alt="image-20230609144958074"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609145017872-5b6eb5.png" alt="image-20230609145017872"></p><h2 id="客户端接入配置中心"><a href="#客户端接入配置中心" class="headerlink" title="客户端接入配置中心"></a>客户端接入配置中心</h2><h3 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        配置中心客户端--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="yml配置-2"><a href="#yml配置-2" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将原来的配置文件修改成bootstrap.yml，然后增加如下内容：</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-server</span></span><br><span class="line"><span class="comment">#配置中心的配比</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="comment">#配置nacos的注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span><span class="string">:8848</span><span class="comment">#注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment">#配置中心</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#配置文件格式</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">application-user</span> <span class="comment">#配置前缀 ，默认使用sring.application.name</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment">#默认分组</span></span><br><span class="line"><span class="comment">#如何查找配置文件:application-user + dev + yaml=application-user-dev.yaml 正好和Nacos配置的DataId一致</span></span><br><span class="line"> <span class="string">prefix</span> <span class="string">表示前缀</span>   <span class="attr">profiles: active:</span> <span class="string">dev</span>  <span class="string">表示激活dev,也是连接起来，最后加上后缀，这三部分一起构成了dataID,还有分组</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.cloud.nacos.config.server-addr ：配置了Nacos的地址</span><br><span class="line">    </span><br><span class="line">spring.cloud.nacos.config.file-extension：指定了配置文件的格式为YAML,默认是properties,</span><br><span class="line"></span><br><span class="line">spring.cloud.nacos.config.prefix：配置前缀，如果不配置前缀默认会把服务名即spring.application.name的值作为前缀 </span><br><span class="line">    </span><br><span class="line">spring.cloud.nacos.config.group：分组名，默认是DEFAULT_GROUP对应了Nacos配置中的Group</span><br><span class="line">    </span><br><span class="line">spring.profiles.active：配置了环境为dev.该配置可以实现多配置多环境管理</span><br><span class="line"></span><br><span class="line">据如上配置，那么config客户端会将：前缀+环境+后缀 拼接成的文件名“application-user-dev.yaml” 去Nacos上查找是否有对应Data ID的配置文件。</span><br></pre></td></tr></table></figure><h3 id="控制类"><a href="#控制类" class="headerlink" title="控制类"></a>控制类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">控制类上增添配置<span class="meta">@RefreshScope</span>  <span class="comment">//刷新配置，注解是用来做配置自动刷新。那么当我们修改了Nacos中的配置文件，Controller中读取到的book.name配置将会自动变化。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span>  <span class="comment">//刷新配置</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line">    String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/bookname&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean&lt;String&gt; <span class="title function_">getBookName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.success(bookName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将原来的配置文件修改成bootstrap.yml</span><br><span class="line">云端配置文件的后缀应该是 yaml而不是yml </span><br><span class="line">客户端配置需要指定：spring.profiles.active=dev 环境名</span><br><span class="line">客户端配置 ：前缀 + 环境名 + 后缀应该和云端配置文件的DataId一致</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">命名空间可以用来隔离不同项目的配置文件，在Nacos中配置了命名空间后，那么Java客户端需要指定命名空间后才能拉取到该命名空间下的配置文件。</span><br><span class="line"></span><br><span class="line">相当于把配置文件放在不同的包里面，防止由于配置名称相同而引起错误</span><br></pre></td></tr></table></figure><h3 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609151849884-e8f3ca.png" alt="image-20230609151849884"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下我们就创建了一个Test的命名空间</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609151946747-5c9c8a.png" alt="image-20230609151946747"></p><h3 id="在新的命名空间新建配置"><a href="#在新的命名空间新建配置" class="headerlink" title="在新的命名空间新建配置"></a>在新的命名空间新建配置</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609152145185-34e22b.png" alt="image-20230609152145185"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609152300080-1a3ac8.png" alt="image-20230609152300080"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230609152319907-83f576.png" alt="image-20230609152319907"></p><h3 id="程序引用"><a href="#程序引用" class="headerlink" title="程序引用"></a>程序引用</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">需要指定一下从哪个命名空间拉取配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-server</span></span><br><span class="line"><span class="comment">#配置中心的配比</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="comment">#配置nacos的注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span><span class="string">:8848</span><span class="comment">#注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment">#配置中心</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#配置文件格式</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">application-user</span> <span class="comment">#配置前缀 ，默认使用sring.application.name</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment">#默认分组</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">f3b4a26f-6f76-4a0c-9f13-fcd42875f77a</span> <span class="comment">#test命名空间的ID</span></span><br><span class="line"><span class="comment">#如何查找配置文件:application-user + dev + yaml=application-user-dev.yaml 正好和Nacos配置的DataId一致</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">这里的namespace对应了</span> <span class="string">Nacos中“test”这个命名空间的ID，意思是从“test”这个命名空间去找</span> <span class="string">application-user-dev.yaml的配置文件。</span></span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="如何自定义Data-ID"><a href="#如何自定义Data-ID" class="headerlink" title="如何自定义Data ID"></a>如何自定义Data ID</h3><p>支持自定义扩展的 Data Id 配置 ：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a></p><h3 id="开启Nacos认证"><a href="#开启Nacos认证" class="headerlink" title="开启Nacos认证"></a>开启Nacos认证</h3><p>开启Nacos认证，需要通知账号和密码进行注册，以及拉取配置。</p><p><a href="https://nacos.io/zh-cn/docs/auth.html">https://nacos.io/zh-cn/docs/auth.html</a></p><h1 id="Sentienl限流"><a href="#Sentienl限流" class="headerlink" title="Sentienl限流"></a>Sentienl限流</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar -Dserver.port=<span class="number">1111</span> sentinel-dashboard-<span class="number">1.7</span><span class="number">.1</span>.jar</span><br><span class="line"></span><br><span class="line">确定jar包以及运行端口</span><br><span class="line"></span><br><span class="line">访问：http:<span class="comment">//127.0.0.1:1111 进入控制台，使用 sentinel/sentinel登录。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意：只有<span class="number">1.6</span><span class="number">.0</span>及以上版本才有这个登录页面。默认用户名和密码都是sentinel。对于用户登录的相关配置可以在启动命令中增加下面的参数来进行配置：</span><br><span class="line"></span><br><span class="line">Dsentinel.dashboard.auth.username=sentinel: 用于指定控制台的登录用户名为 sentinel；</span><br><span class="line">    </span><br><span class="line">Dsentinel.dashboard.auth.password=<span class="number">123456</span>: 用于指定控制台的登录密码为 <span class="number">123456</span>；如果省略这两个参数，默认用户和密码均为 sentinel</span><br><span class="line"></span><br><span class="line">Dserver.servlet.session.timeout=<span class="number">7200</span>: 用于指定 Spring Boot 服务端 session 的过期时间，如 <span class="number">7200</span> 表示 <span class="number">7200</span> 秒；60m 表示 <span class="number">60</span> 分钟，默认为 <span class="number">30</span> 分钟；</span><br><span class="line"></span><br><span class="line">Dserver.port=<span class="number">1111</span>：配置端口</span><br></pre></td></tr></table></figure><h2 id="Springboot使用"><a href="#Springboot使用" class="headerlink" title="Springboot使用"></a>Springboot使用</h2><h3 id="引入依赖-4"><a href="#引入依赖-4" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--接入sentinel--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="yml配置-3"><a href="#yml配置-3" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">1111</span></span><br><span class="line">            </span><br><span class="line">配置sentienl的访问地址</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置完成后，如果继续访问以前的路径，返回的JSON字符串，就会成XML格式，所以需要手动设置</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, produces = &quot;application/json;charset=utf-8&quot;)</span></span><br><span class="line">在RequestMapping里面增添属性produces即可</span><br></pre></td></tr></table></figure><h3 id="资源限流"><a href="#资源限流" class="headerlink" title="资源限流"></a>资源限流</h3><h4 id="方法设置"><a href="#方法设置" class="headerlink" title="方法设置"></a>方法设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sentinel为我们提供了<span class="meta">@SentinelResource</span>注解标记需要限流的资源</span><br><span class="line">    需要注意的是：降级方法要和被限流的方法参数一致，然后加上 BlockException异常对象。</span><br><span class="line">    </span><br><span class="line">    value：资源名称，需要设置，是在中心对这个资源进行管理的依据</span><br><span class="line">    blockHandler：触发流控规则后的降级处理方法</span><br><span class="line">    后面内容就是方法内容：</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">        <span class="meta">@RequestMapping(value = &quot;get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="comment">//限流降级</span></span><br><span class="line">    <span class="meta">@SentinelResource(value=&quot;user&quot;,blockHandler=&quot;blockHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean&lt;User&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;Curry&quot;</span>, <span class="string">&quot;2022年NBA总决赛FMVP&quot;</span>, id, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        ResultBean&lt;Order&gt; bean = orderFeignClient.getByIdOrder(user.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> bean.getData();</span><br><span class="line">        user.setOrder(order);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.success(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> blockHandler ：方法的返回值参数是一致的</span><br><span class="line">     参数列表中加入BlockException</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限流降级的方法，如果getById超过流控的话就会访问该方法,返回值和参数得一样</span></span><br><span class="line">   <span class="keyword">public</span> ResultBean&lt;User&gt;  <span class="title function_">blockHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, BlockException ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultBean.fail(<span class="number">102</span>,<span class="string">&quot;无法根据&quot;</span>+id+<span class="string">&quot;查询用户&quot;</span>+ex.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SentinelResource</span>的value属性为资源取名为 “user” ，后续根据该资源名来进行限流。</span><br><span class="line"></span><br><span class="line">同时这里通过 blockHandler 属性我配置了一个限流降级方法，即当“user”资源触发限流了会调用blockHandler指向的降级方法返回拖地数据，不至于抛出默认的限流异常信息给客户端(一串英文用户也看不懂) </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="类设置"><a href="#类设置" class="headerlink" title="类设置"></a>类设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">也可以将降级限流方法放置在一个整体的类里面，进行调用</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SentinelResource(value=&quot;user&quot;,blockHandler=&quot;blockHandler&quot;,blockHandlerClass = UserBlockHandler.class )</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean&lt;User&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;Curry&quot;</span>, <span class="string">&quot;2022年NBA总决赛FMVP&quot;</span>, id, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        ResultBean&lt;Order&gt; bean = orderFeignClient.getByIdOrder(user.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> bean.getData();</span><br><span class="line">        user.setOrder(order);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.success(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">注意方法用<span class="keyword">static</span>进行修饰即可</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBlockHandler</span> &#123;</span><br><span class="line">    <span class="comment">//限流降级的方法，如果getById超过流控的话就会访问该方法,返回值和参数得一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultBean&lt;User&gt; <span class="title function_">blockHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, BlockException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultBean.fail(<span class="number">102</span>, <span class="string">&quot;在类中,无法根据&quot;</span> + id + <span class="string">&quot;查询用户&quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限流设置"><a href="#限流设置" class="headerlink" title="限流设置"></a>限流设置</h2><h3 id="Sentinel流控模式"><a href="#Sentinel流控模式" class="headerlink" title="Sentinel流控模式"></a>Sentinel流控模式</h3><h4 id="直接-–单机阈值"><a href="#直接-–单机阈值" class="headerlink" title="直接 –单机阈值"></a>直接 –单机阈值</h4><p>Sentinel默认的流控处理就是【直接-&gt;快速失败】，QPS达到阈值，当前资源<code>直接失败</code>。在流控规则中配置如下：<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200424224855218-4af74b.png" alt="在这里插入图片描述"></p><p>对某个资源进行设置单机阈值，相当于在一秒内最多访问多少次，超过次数将会返回限流方法的返回值，其中的QPS是表示每秒访问多少次</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230612204416600-b23d5f.png" alt="image-20230612204416600"></p><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>关联的资源达到某个阈值，限流自己，如：限流的资源是<code>/user/delete</code> ，关联的资源是<code>/user/list</code>，当<code>/user/list</code>达到阈值，限流<code>user/delete</code> ， 举例： 支付并发太高，可以限制下单的流量<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/2020042422514056-96010d.png" alt="在这里插入图片描述"></p><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><p>限流线路调用链路的入口，如 <code>/user/list</code> 资源中 调用了 <code>/dept/list</code> ，对<code>/dept/list</code>添加限流，当<code>/dept/list</code>达到阈值，其实限流的是<code>/user/list</code>，因为他是访问的入口<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200424225347309-dfa388.png" alt="在这里插入图片描述"></p><h3 id="Sentinel流控效果"><a href="#Sentinel流控效果" class="headerlink" title="Sentinel流控效果"></a>Sentinel流控效果</h3><h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>快速失败:(RuleConstant.CONTROL_BEHAVIOR_DEFAULT)是默认的流控方式，当<code>流量达到阀值直接返回异常</code>，QPS达到任何规则阈值后，<code>后续请求就会立即拒绝</code>，并抛出FlowException 异常。简单理解：并发太高，直接请求拒绝</p><h4 id="Warm-Up预热"><a href="#Warm-Up预热" class="headerlink" title="Warm Up预热"></a>Warm Up预热</h4><p>Warm Up预热:(RuleConstant.CONTROL_BEHAVIOR_WARM_UP)方式，根据codeFactor（默认3）的值，从（阀值&#x2F;codeFactor）为初始阀值，经过预热时长，才到达设置的QPS的阀值，即预热&#x2F;冷启动方式。简单理解：&#x3D;&#x3D;慢慢的增大处理并发的能力&#x3D;&#x3D;<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200424225831661-c7c363.png" alt="在这里插入图片描述"><br>提示：初始的QPS阈值为 100 &#x2F; 3 &#x3D;33 ，10秒后 QPS阈值达到 100.</p><p>当系统长期并发不高，流量突然增加可能会直接把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值的上限，给系统一个预热的时间，避免冷系统被压垮。</p><h4 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h4><p>排队等(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER)，忽然增加的请求并发量达到了限流阈值后续请求会被决绝，有时候我们可能更希望后续的请求可以加入队列进行排队，慢慢执行，而不是直接拒绝请求，这种方式后严格控制请求通过的时间间隔，也即是让请求以均匀的速度通过，对应的是漏桶算法，这种方式主要用于处理间隔性突发的流量，例如消息队列。 简单理解：突发流量处理不过来，让请求排队。<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200424230647590-11ff06.png" alt="在这里插入图片描述"><br>提示：QPS阈值为100，超过的请求会排队，排队超时时间为 10S</p><h3 id="热点限流"><a href="#热点限流" class="headerlink" title="热点限流"></a>热点限流</h3><p>还有一种特殊的动态限流规则，用于限制动态的热点资源 ， 比如对同一个用户的请求频率做限定，比如对参数进行限定，比如对参数的值做限定(比如对商品ID为1的资源做限流)。</p><h4 id="参数限流"><a href="#参数限流" class="headerlink" title="参数限流"></a>参数限流</h4><p>参数限流就是 对资源的参数进行限流，我们来编写一个方法，接受两个参数：p1,和p2并设置好限流降级。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//限流降级</span></span><br><span class="line"><span class="meta">@SentinelResource(value=&quot;/parameterLimit&quot;,blockHandler=&quot;parameterLimitHandler&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/parameterLimit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">parameterLimit</span><span class="params">(<span class="meta">@RequestParam(&quot;p1&quot;)</span> String p1 ,<span class="meta">@RequestParam(&quot;p2&quot;)</span> String p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;parameterLimit方法调用成功...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 限流与阻塞处理</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">parameterLimitHandler</span><span class="params">(<span class="meta">@RequestParam(&quot;p1&quot;)</span> String p1 ,<span class="meta">@RequestParam(&quot;p2&quot;)</span> String p2,BlockException ex)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;限流了...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置热点规则 ， 对第一个参数限流 ， 当第一个参数超过了1的QPS就熔断降级。<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200425232333228-ff0a87.png" alt="在这里插入图片描述"></p><h4 id="参数值限流"><a href="#参数值限流" class="headerlink" title="参数值限流"></a>参数值限流</h4><p>对某一个参数的值满足某种条件的时候就进行限流，如下配置</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200425232749902-be0e2c.png" alt="在这里插入图片描述"><br>意思是第一个参数的值为 <strong>haha</strong> 的时候限流阈值为10 ， 超过 QPS &gt; 10的并发就限流。</p><p>举例：应用场景比如说商品名称为“华为p40”的商品并发特别高，我们可以针对参数商品名为“华为p40”的商品进行限流。</p><h3 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h3><h4 id="配置全局限流规则"><a href="#配置全局限流规则" class="headerlink" title="配置全局限流规则"></a>配置全局限流规则</h4><p>系统规则可以看做是总的限流策略，所有的只要都要受到系统规则的限制。<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200425233121705-111476.png" alt="在这里插入图片描述"><br>上面的意思是最大并发只能允许 10 个线程数，并且是作用于全局的。 </p><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><p>工程名：springcloud-gateway-server-1110 ，导入gataway基础依赖</p><h2 id="引入依赖-5"><a href="#引入依赖-5" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--导入nacos发现的依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">&lt;!--            gateway网关--&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayServerApplication1110</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayServerApplication1110.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yml配置-4"><a href="#yml配置-4" class="headerlink" title="yml配置"></a>yml配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1110</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway-server</span></span><br><span class="line">  <span class="comment">#配置nacos的注册中心地址</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.1</span><span class="string">:8848</span><span class="comment">#注册中心地址</span></span><br><span class="line"><span class="comment">#    网关</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">false</span> <span class="comment">#开放服务名访问方式</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span> <span class="comment">#服务名小写</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">application-user</span> <span class="comment">#指定服务名（随意写）</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-server</span> <span class="comment">#去注册中心找这个服务名，这个得写对，lb表示负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#断言，匹配访问的路径</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/userserver/**</span>    <span class="comment">#服务访问路径</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span>    <span class="comment">#请求转发的时候会去掉 /userserver访问路径</span></span><br><span class="line">        </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">application-order</span> <span class="comment">#指定服务名（随意写）</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://order-server</span> <span class="comment">#去注册中心找这个服务名，这个得写对，lb表示负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment">#断言，匹配访问的路径</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orderserver/**</span>    <span class="comment">#服务访问路径</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span>    <span class="comment">#请求转发的时候会去掉 /orderserver访问路径</span></span><br><span class="line"><span class="comment">#日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">curry.neusoft:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- spring.cloud.gateway.discovery.locator.enabled=<span class="literal">false</span>: 不开放服务名访问方式</span><br><span class="line">- spring.cloud.gateway.discovery.locator.lower-<span class="keyword">case</span>-service-id: <span class="literal">true</span> 忽略服务名大小写，大写小写都可以匹配</span><br><span class="line">- spring.cloud.gateway.routes.id : 指定了路由的服务名，可以自己定义</span><br><span class="line">- spring.cloud.gateway.routes.uri=lb:<span class="comment">//user-server : 去注册中心找服务，采用负载均衡的方式请求。其实就是找要调用的服务。</span></span><br><span class="line">- spring.cloud.gateway.routes.predicates: 断言，这里使用的Path=/user<span class="comment">/**，即匹配访问的路径如果匹配/user/就可以将请求路由(分发)到user-server这个服务上。</span></span><br><span class="line"><span class="comment">- spring.cloud.gateway.routes.filters :这里使用StripPrefix=1主要是处理前缀 /user ,访问目标服务的时候会去掉前缀访问。这个需要根据url情况来定义。</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230617174815066-87ed15.png" alt="image-20230617174815066"></p><p>带上userserver进行访问</p><h2 id="Predicate断言工厂"><a href="#Predicate断言工厂" class="headerlink" title="Predicate断言工厂"></a>Predicate断言工厂</h2><h3 id="什么是断言工厂"><a href="#什么是断言工厂" class="headerlink" title="什么是断言工厂"></a>什么是断言工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spring Cloud Gateway将路由作为Spring WebFlux HandlerMapping基础架构的一部分进行匹配。Spring Cloud Gateway包括许多内置的路由断言工厂。所有这些断言都与HTTP请求的不同属性匹配。您可以将多个路由断言工厂与逻辑and语句结合使用。</span><br><span class="line"></span><br><span class="line">这里不难理解，其实断言工厂就是用来判断http请求的匹配方式。比如我们再上面案例中配置的：“Path=/user<span class="comment">/**” ，就是使用的是 “Path Route Predicate Factory” 路径匹配工厂，意思是http请求的资源地址必须是 /user 才会被匹配到对应的路由，然后继续执行对应的服务获取资源。</span></span><br></pre></td></tr></table></figure><p>在Spring Cloud Gateway中，针对不同的场景内置的路由断言工厂，比如 </p><ul><li><code>Query Route Predicate Factory</code>：根据查询参数来做路由匹配</li><li><code>RemoteAddr Route Predicate Factory</code>：根据ip来做路由匹配</li><li><code>Header Route Predicate Factory</code>：根据请求头中的参数来路由匹配</li><li><code>Host Route Predicate Factory</code>：根据主机名来进行路由匹配</li><li><code>Method Route Predicate Factory</code> ：根据方法来路由匹配</li><li><code>Cookie Route Predicate Factory</code>：根据cookie中的属性值来匹配</li><li><code>Before Route Predicate Factory</code>：指定时间之间才能匹配</li><li><code>After Route Predicate Factory</code>： 指定时间之前才能匹配</li><li><code>Weight Route Predicate Factory</code>： 根据权重把流量分发到不同的主机</li></ul><h2 id="断言方式"><a href="#断言方式" class="headerlink" title="断言方式"></a>断言方式</h2><h3 id="根据查询参数断言-Query-Route-Predicate-Factory"><a href="#根据查询参数断言-Query-Route-Predicate-Factory" class="headerlink" title="根据查询参数断言- Query Route Predicate Factory"></a>根据查询参数断言- Query Route Predicate Factory</h3><p><a href="http://localhost:0/xxx/xxx?asdf=asdfasdfa">http://localhost:0000/xxx/xxx?asdf=asdfasdfa</a></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=green</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面配置表达的试试是如果请求参数中包含了 green，那么就会断言成功，从而执行uri后面的地址。</p><h3 id="根据path断言-Path-Route-Predicate-Factory-重要"><a href="#根据path断言-Path-Route-Predicate-Factory-重要" class="headerlink" title="根据path断言-Path Route Predicate Factory(重要)"></a>根据path断言-Path Route Predicate Factory(重要)</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">path_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>请求路径如: <code>/red/1</code>或<code>/red/blue</code>或<code>/blue/green</code> 就可以断言成功</p><h3 id="根据权重比例断言-Weight-Route-Predicate-Factory"><a href="#根据权重比例断言-Weight-Route-Predicate-Factory" class="headerlink" title="根据权重比例断言-Weight Route Predicate Factory"></a>根据权重比例断言-Weight Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weighthigh.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://weightlow.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>大约80％的请求转发到<a href="https://weighthigh.org/">weighthigh.org</a>，将大约20％的流量<a href="https://weighlow.org/">转发</a>到<a href="https://weighlow.org/">weightlow.org。</a></p><h3 id="根据远程ip断言-RemoteAddr-Route-Predicate-Factory"><a href="#根据远程ip断言-RemoteAddr-Route-Predicate-Factory" class="headerlink" title="根据远程ip断言 - RemoteAddr Route Predicate Factory"></a>根据远程ip断言 - RemoteAddr Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure><p>如果请求的远程地址为 <code>192.168.1.1</code>到<code>192.168.1.24</code>之间，则此路由匹配</p><h3 id="指定时间之后断言-After-Route-Predicate-Factory"><a href="#指定时间之后断言-After-Route-Predicate-Factory" class="headerlink" title="指定时间之后断言-After Route Predicate Factory"></a>指定时间之后断言-After Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure><p>在atfer配置的时间之后才能访问</p><h3 id="在指定时间之前断言-Before-Route-Predicate-Factory"><a href="#在指定时间之前断言-Before-Route-Predicate-Factory" class="headerlink" title="在指定时间之前断言-Before Route Predicate Factory"></a>在指定时间之前断言-Before Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure><p>在before配置的时间之前才能访问</p><h3 id="在指定时间段之间断言-Between-Route-Predicate-Factory"><a href="#在指定时间段之间断言-Between-Route-Predicate-Factory" class="headerlink" title="在指定时间段之间断言-Between Route Predicate Factory"></a>在指定时间段之间断言-Between Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure><p>请求时间在两个时间之内者允许访问</p><h3 id="根据cookie断言-Cookie-Route-Predicate-Factory"><a href="#根据cookie断言-Cookie-Route-Predicate-Factory" class="headerlink" title="根据cookie断言-Cookie Route Predicate Factory"></a>根据cookie断言-Cookie Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br></pre></td></tr></table></figure><p>cookies中必须有Cookie配置的属性才能匹配</p><h3 id="根据请求头断言-Header-Route-Predicate-Factory"><a href="#根据请求头断言-Header-Route-Predicate-Factory" class="headerlink" title="根据请求头断言-Header Route Predicate Factory"></a>根据请求头断言-Header Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p>请求头必须出现 X-Request-Id 才可以访问</p><h3 id="根据主机断言-Host-Route-Predicate-Factory"><a href="#根据主机断言-Host-Route-Predicate-Factory" class="headerlink" title="根据主机断言-Host Route Predicate Factory"></a>根据主机断言-Host Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br></pre></td></tr></table></figure><p>如果请求的主机头具有值**.somehost.org,或者**.anotherhost.org这匹配路由</p><h3 id="根据请求方式断言-Method-Route-Predicate-Factory"><a href="#根据请求方式断言-Method-Route-Predicate-Factory" class="headerlink" title="根据请求方式断言-Method Route Predicate Factory"></a>根据请求方式断言-Method Route Predicate Factory</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure><p>只允许 GET和POST请求</p><h2 id="Gateway-的-Filter-过滤器"><a href="#Gateway-的-Filter-过滤器" class="headerlink" title="Gateway 的 Filter 过滤器"></a>Gateway 的 Filter 过滤器</h2><h3 id="内置的Gateway-filter（我没看）"><a href="#内置的Gateway-filter（我没看）" class="headerlink" title="内置的Gateway filter（我没看）"></a>内置的Gateway filter（我没看）</h3><p><code>针对单个路由的Filter</code>, 它允许以某种方式修改HTTP请求或HTTP响应。过滤器可以作用在某些特定的请求路径上。Gateway内置了很多的GatewayFilter工厂。如果要使用这些Filter只需要在配置文件配置GatewayFilter Factory的名称。下面拿一个内置的Gateway Filter举例：</p><p><strong>AddRequestHeader GatewayFilter Factory</strong><br>该Filter是Gateway内置的，它的作用是在请求头加上指定的属性。配置如下：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-red,</span> <span class="string">blue</span></span><br></pre></td></tr></table></figure><p>在<code>spring.cloud.gateway.routes.filters</code>配置项配置了一个<code>AddRequestHeader</code> ,他是“<code>AddRequestHeader GatewayFilter Factory</code>”的名称，意思是在请求头中添加一个“<code>X-Request-red</code>”的属性，值为<code>blue</code> 。</p><p>其他的Filter可以去看 AbstractGatewayFilterFactory 的实现类。</p><p>更多的内置的Filter，见 <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gatewayfilter-factories">官网文档</a></p><h3 id="自定义Gateway-Filter（局部）"><a href="#自定义Gateway-Filter（局部）" class="headerlink" title="自定义Gateway Filter（局部）"></a>自定义Gateway Filter（局部）</h3><p>在Spring Cloud Gateway自定义过滤器，过滤器需要实现GatewayFilter和Ordered这两个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestTimeFilter</span> <span class="keyword">implements</span> <span class="title class_">GatewayFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COUNT_Start_TIME</span> <span class="operator">=</span> <span class="string">&quot;countStartTime&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        exchange.getAttributes().put(COUNT_Start_TIME, System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//执行完成之后</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(</span><br><span class="line">                Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">//开始时间</span></span><br><span class="line">                    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> exchange.getAttribute(COUNT_Start_TIME);</span><br><span class="line">                    <span class="comment">//结束时间</span></span><br><span class="line">                    Long endTime=(System.currentTimeMillis() - startTime);</span><br><span class="line">                    <span class="keyword">if</span> (startTime != <span class="literal">null</span>) &#123;</span><br><span class="line">                        log.info(exchange.getRequest().getURI().getRawPath() + <span class="string">&quot;: &quot;</span> + endTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示： getOrder返回filter的优先级，越大的值优先级越低 ， 在filterI方法中计算了请求的开始时间和结束时间</p><p>最后我们还需要把该Filter配置在对应的路由上，配置如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Filter作用于那个访问规则上</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customerRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.routes().route(r -&gt; r.path(<span class="string">&quot;/services/user/**&quot;</span>)</span><br><span class="line">                <span class="comment">//去掉2个前缀</span></span><br><span class="line">                        .filters(f -&gt; f.stripPrefix(<span class="number">2</span>)</span><br><span class="line">                        .filter(<span class="keyword">new</span> <span class="title class_">RequestTimeFilter</span>())</span><br><span class="line">                        .addResponseHeader(<span class="string">&quot;X-Response-test&quot;</span>, <span class="string">&quot;test&quot;</span>))</span><br><span class="line">                        .uri(<span class="string">&quot;lb://service-user&quot;</span>)</span><br><span class="line">                        .order(<span class="number">0</span>)</span><br><span class="line">                        .id(<span class="string">&quot;test-RequestTimeFilter&quot;</span>)</span><br><span class="line">                ).build();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>GlobalFilter:全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeGlobleFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; token = exchange.getRequest().getHeaders().get(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;检查 TOKEN = &#123;&#125;&quot;</span> ,token);</span><br><span class="line">        <span class="keyword">if</span>(token == <span class="literal">null</span> || token.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//响应对象</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            <span class="comment">//构建错误结果</span></span><br><span class="line">            <span class="type">ResultBean</span> <span class="variable">data</span> <span class="operator">=</span> ResultBean.fail(<span class="number">401</span>, <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] bytes = JSON.toJSONString(data).getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                buffer = response.bufferFactory().wrap(bytes);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置完成相应，不会继续执行后面的filter</span></span><br><span class="line">                <span class="comment">//response.setComplete();</span></span><br><span class="line">                response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">                response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把结果写给客户端没有放行</span></span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;Token不为空 ，放行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接这样配置就好了，</span><br></pre></td></tr></table></figure><h2 id="Gateway跨域配置"><a href="#Gateway跨域配置" class="headerlink" title="Gateway跨域配置"></a>Gateway跨域配置</h2><p>所谓的跨域是因为浏览器的同源(同一个域)策略限制，其实就是同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互 ，在前后端分离的项目架构中就会出现跨域问题，因为Gateway 网关是微服务的访问入口，所以我们只需要在Gateway配置跨域即可：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#cors-configuration">官方文档</a></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">globalcors:</span> <span class="comment">#跨域配置</span></span><br><span class="line">            <span class="attr">cors-configurations:</span></span><br><span class="line">              <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">                <span class="attr">allowedOrigins:</span> <span class="string">&quot;https://docs.spring.io&quot;</span> <span class="comment">#允许的站点</span></span><br><span class="line">                <span class="attr">allowedMethods:</span><span class="comment">#允许的请求方式</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">HEAD</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">CONNECT</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">TRACE</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">                <span class="attr">allowHeaders:</span><span class="comment">#允许的请求头</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">Content-Type</span></span><br></pre></td></tr></table></figure><p>提示：运行跨域访问的站点：<a href="https://docs.spring.io/">https://docs.spring.io</a> ，同时把常见的请求方式都开放。</p><h2 id="Gateway超时"><a href="#Gateway超时" class="headerlink" title="Gateway超时"></a>Gateway超时</h2><p>超时配置在微服务调用和数据读取的时候显得尤为重要，下面演示Gateway中的全局超时设置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">httpclient:</span></span><br><span class="line">        <span class="attr">connect-timeout:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">response-timeout:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure><p>指定路由超时配置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">per_route_timeouts</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Path</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">              <span class="attr">pattern:</span> <span class="string">/delay/&#123;timeout&#125;</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">response-timeout:</span> <span class="number">200</span></span><br><span class="line">          <span class="attr">connect-timeout:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><h1 id="Gateway使用Sentinel限流-一般是拿网关来限流！"><a href="#Gateway使用Sentinel限流-一般是拿网关来限流！" class="headerlink" title="Gateway使用Sentinel限流,一般是拿网关来限流！"></a>Gateway使用Sentinel限流,一般是拿网关来限流！</h1><h2 id="引入依赖-6"><a href="#引入依赖-6" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--    限流和gataway使用--&gt;</span><br><span class="line">整合包注意是</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="yml配置-5"><a href="#yml配置-5" class="headerlink" title="yml配置"></a>yml配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">      sentinel:</span><br><span class="line">          transport:</span><br><span class="line">            dashboard: localhost:<span class="number">1111</span></span><br></pre></td></tr></table></figure><h2 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SentinelConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        GatewayCallbackManager.setBlockHandler(<span class="keyword">new</span> <span class="title class_">BlockRequestHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">handleRequest</span><span class="params">(ServerWebExchange serverWebExchange, Throwable throwable)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ServerResponse.ok().body(Mono.just(<span class="string">&quot;限流啦,请求太频繁&quot;</span>),String.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置限流规则"><a href="#配置限流规则" class="headerlink" title="配置限流规则"></a>配置限流规则</h2><p>启动Gateway，登录sentinel控制台，对url资源进行流控限制，配置方式和前面的配置方式一样</p><h1 id="Nacos存储限流规则"><a href="#Nacos存储限流规则" class="headerlink" title="Nacos存储限流规则"></a>Nacos存储限流规则</h1><h2 id="引入依赖-7"><a href="#引入依赖-7" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--Sentinel和Nacos做持久的--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="yml配置-6"><a href="#yml配置-6" class="headerlink" title="yml配置"></a>yml配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="comment">#配置中心</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">application-user</span></span><br><span class="line">    <span class="attr">sentinel:</span><span class="comment">#限流服务器sentinel配置</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:1111</span></span><br><span class="line"><span class="comment">#====================持久化配置=================================        </span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span></span><br><span class="line">          <span class="attr">nacos:</span> <span class="comment">#限流持久配置</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span><span class="comment">#使用nacos的持久</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">application-user-dev</span><span class="comment">#获取限流的数据源的dataId，看清楚不是前缀</span></span><br><span class="line">            <span class="string">如果需要配置名称空间，别忘记，</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment">#类型：限流</span></span><br><span class="line"><span class="comment">#=====================================================            </span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里其实是在之前的配置基础上增加了 spring.cloud.sentinel.datasource持久化数据源的配置，对应了NacosDataSourceProperties 配置类具体含义如下：</span><br><span class="line"></span><br><span class="line">- spring.cloud.sentinel.datasource.ds.nacos.server-addr：nacos的访问地址</span><br><span class="line">- spring.cloud.sentinel.datasource.ds.nacos.groupId：nacos中存储规则的groupId</span><br><span class="line">- spring.cloud.sentinel.datasource.ds.nacos.dataId：nacos中存储规则的dataId</span><br><span class="line">- spring.cloud.sentinel.datasource.ds.nacos.rule-type：该参数是用来定义存储的规则类型。所有的规则类型可查看枚举类：...datasource.RuleType，每种规则的定义格式可以通过各枚举值中定义的规则对象来查看，比如限流规则可查看：...flow.FlowRule</span><br></pre></td></tr></table></figure><h2 id="编写要限流的方法"><a href="#编写要限流的方法" class="headerlink" title="编写要限流的方法"></a>编写要限流的方法</h2><p>自己写一个方法即可</p><h2 id="Nacos持久化Sentinel限流规则"><a href="#Nacos持久化Sentinel限流规则" class="headerlink" title="Nacos持久化Sentinel限流规则"></a>Nacos持久化Sentinel限流规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;resource&quot;: &quot;/hello&quot;,</span><br><span class="line">        &quot;limitApp&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;grade&quot;: 1,</span><br><span class="line">        &quot;count&quot;: 10,</span><br><span class="line">        &quot;strategy&quot;: 0,</span><br><span class="line">        &quot;controlBehavior&quot;: 0,</span><br><span class="line">        &quot;clusterMode&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里做一个解释</span><br><span class="line"></span><br><span class="line">- resource：对那个资源进行限流, <span class="meta">@SentinelResource(value=&quot;user&quot;,  这个value的值表示</span></span><br><span class="line"><span class="meta">- limitApp：这个是流控的调用者，default 代表不区分调用者</span></span><br><span class="line"><span class="meta">- grade：限流方式0是根据并发数量限流，1是表根据QPS来限流</span></span><br><span class="line"><span class="meta">- count：限流阈值，达到这个阈值就被限流，触发降级。</span></span><br><span class="line"><span class="meta">- strategy：基于调用链的流控制策略。0 直接，1 关联 2 链路</span></span><br><span class="line"><span class="meta">- controlBehavior：流控效果，0 直接拒绝，1是Warm Up，2是匀速排队</span></span><br><span class="line"><span class="meta">- clusterMode：是否为集群</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230617222523592-301917.png" alt="image-20230617222523592"></p><h2 id="Nacos持久化Sentinel降级规则"><a href="#Nacos持久化Sentinel降级规则" class="headerlink" title="Nacos持久化Sentinel降级规则"></a>Nacos持久化Sentinel降级规则</h2><p>在Nacos配置列表增加文件 如：application-user-degrade-dev ，内容如下</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GetUserByID&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>解释一下</p><ul><li>resources : 资源名</li><li>grade : 慢调用比例 0  ；异常比例 1 ；异常数 2；</li><li>count : 最大RT，最大平均响应时间</li><li>timeWindow ：时间窗口，即熔断时长</li></ul><p>效果如：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220313175350683-16471652326681-bc75fd.png" alt="image-20220313175350683"></p><p>第二步：项目中增加配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-user</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span> <span class="comment">#限流的配置</span></span><br><span class="line">          <span class="attr">nacos:</span> <span class="comment">#限流持久配置</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span><span class="comment">#使用nacos的持久</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">application-user-sentinal-dev</span><span class="comment">#获取限流的数据源的dataId</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment">#类型：限流</span></span><br><span class="line"><span class="comment">##==================================================================            </span></span><br><span class="line">        <span class="attr">degrade:</span> <span class="comment">#降级的配置</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">application-user-degrade-dev</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">degrade</span></span><br></pre></td></tr></table></figure><p>第三步：启动测试，观察sentinel的熔断规则列表</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220313175926832-16471655684772-dcb74c.png" alt="image-20220313175926832"></p><h1 id="Sentinel熔断"><a href="#Sentinel熔断" class="headerlink" title="Sentinel熔断"></a>Sentinel熔断</h1><h2 id="jmeter使用"><a href="#jmeter使用" class="headerlink" title="jmeter使用"></a>jmeter使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_45014379/article/details/124190381?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168705398516782425199828%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168705398516782425199828&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124190381-null-null.142^v88^insert_down38v5,239^v2^insert_chatgpt&amp;utm_term=jmeter&amp;spm=1018.2226.3001.4187</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;getByIdUser&quot;,fallback = &quot;fallback&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResultBean&lt;User&gt; <span class="title function_">getByIdUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       Thread.sleep(<span class="number">700</span>);</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;Curry&quot;</span>, <span class="string">&quot;2022常规赛FMVP&quot;</span>, id, <span class="literal">null</span>);</span><br><span class="line">       <span class="keyword">return</span> ResultBean.success(user);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> ResultBean&lt;User&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ResultBean.fail(<span class="number">400</span>,<span class="string">&quot;熔断&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置降级策略"><a href="#配置降级策略" class="headerlink" title="配置降级策略"></a>配置降级策略</h2><p>在Sentinel控制台，在<strong>族点链路</strong>菜单中找到“<strong>user</strong>”资源，然后点击“<strong>降级</strong>”按钮添加降级策略，如下：<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200425132046460-719abf.png" alt="在这里插入图片描述"><br>这里的降级策略为“RT”，大概意思是：如果并发数大于5 (QPS &gt; 5) ，然后平均响应时间大于200毫秒，那么接下来的2秒钟之内对该资源的请求会被熔断降级。</p><h2 id="降级策略-了解"><a href="#降级策略-了解" class="headerlink" title="降级策略(了解)"></a>降级策略(了解)</h2><p>资源在什么情况下会触发熔断降级？调用异常，达到流控，调用超时 都会触发熔断降级，在上面的案例中我们看到资源的降级策略有 RT,异常比例，异常数三种方式，我们可以通过这三种方式来定义资源是否稳定，决定是否要进行熔断降级。</p><h3 id="平均响应RT"><a href="#平均响应RT" class="headerlink" title="平均响应RT"></a>平均响应RT</h3><blockquote><p>平均响应时间 (DEGRADE_GRADE_RT)：当资源的平均响应时间超过阈值（DegradeRule 中的 count，以 ms 为单位）之后，资源进入准降级状态。如果接下来 1s 内持续进入 5 个请求（即 QPS &gt;&#x3D; 5），它们的 RT 都持续超过这个阈值，那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p></blockquote><p>是不是很生涩难懂？我们根据下面这个配置来理解：<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200425134216138-bcf5ff.png" alt="在这里插入图片描述"><br>我们挑关键信息来理解上面那句话<br>这里配置的RT是200意思是对资源的多次请求平均响应时间都超过200毫秒，意思是 1s 内持续进入 5 个请求（即 QPS &gt;&#x3D; 5），这五个请求的平均响应时间都超过了200，后续的2秒之内(时间窗口)请求这个方法都被熔断，触发降级</p><p>总结一下：RT其实就是<strong>平均相应时间太长</strong>资源熔断。</p><h3 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h3><blockquote><p>异常比例(DEGRADE_GRADE_EXCEPTION_RATIO)：每秒请求量 &gt; 5 ,当资源的每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p></blockquote><p>根据下面这个配置来理解<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/2020042522463519-9494f3.png" alt="在这里插入图片描述"><br>上面配置的意思就是“user”这个资源的异常比例超过了0.2，即10个请求有两个都异常了，资源被熔断，在接下来的2秒钟之后请求这个方法都被熔断，触发降级。</p><p>总结一下：异常比例就是按<strong>照资源的请求失败率</strong>来熔断。</p><h3 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h3><blockquote><p>异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p></blockquote><p>根据下面这个配置来理解<br><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/20200425230228273-8b5f82.png" alt="在这里插入图片描述"><br>这里的意思是一分钟(61s)超过5个异常请求，服务进行熔断。后续请求都拒绝。</p><p>注意：异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（BlockException）不生效</p><p>总结一下：异常数就是按照 <strong>一分钟的异常的数量</strong> 来熔断。</p><h1 id="Feign整合Sentinel熔断"><a href="#Feign整合Sentinel熔断" class="headerlink" title="Feign整合Sentinel熔断"></a>Feign整合Sentinel熔断</h1><p>即服务相互调用的时候，如果一个服务出现问题，那么另一个服务也得返回兜底数据</p><h2 id="yml配置-7"><a href="#yml配置-7" class="headerlink" title="yml配置"></a>yml配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#熔断</span></span><br></pre></td></tr></table></figure><h2 id="给Feign接口降级"><a href="#给Feign接口降级" class="headerlink" title="给Feign接口降级"></a>给Feign接口降级</h2><p>这里跟Feign开启<a href="https://blog.csdn.net/u014494148/article/details/105088732">Hystrix</a>降级一样，还是可以使用fallback属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-server&quot;,fallback = UserClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写降级类"><a href="#编写降级类" class="headerlink" title="编写降级类"></a>编写降级类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClientFallback</span> <span class="keyword">implements</span> <span class="title class_">UserClient</span> &#123;    </span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Long id)</span> &#123;        </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1L</span>,<span class="string">&quot;无此用户&quot;</span>,<span class="string">&quot;无此用户&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们已经完成了Feign和Sentinel的兼容使用，是不是很简单呢，因为它的集成方式和Hystrix简直一模一样</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springCloud</title>
      <link href="/posts/26325.html"/>
      <url>/posts/26325.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h1><h2 id="SpringCloud常用组件"><a href="#SpringCloud常用组件" class="headerlink" title="SpringCloud常用组件"></a>SpringCloud常用组件</h2><p>当我们的项目采用微服务架构之后就会引发一些列的难题需要去解决，如众多微服务的通信地址应该如何管理，微服务之间应该使用何种方式发起调用，微服务故障该如何处理，众多微服务的配置文件如何集中管理等等，SpringCloud为这一系列的难题提供了相应的组件来解决，下面我们简单来理解一下SpringCloud最核心的几大组件如如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607190815314-e8d5df.png" alt="image-20230607190815314"></p><h5 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当我们的微服务过多的时候，管理服务的通信地址是一个非常麻烦的事情，Eureka就是用来管理微服务的通信地址清单的，有了Eureka之后我们通过服务的名字就能实现服务的调用。</span><br></pre></td></tr></table></figure><h5 id="Netflix-Ribbon-Feign-客户端负载均衡"><a href="#Netflix-Ribbon-Feign-客户端负载均衡" class="headerlink" title="Netflix Ribbon\Feign : 客户端负载均衡"></a>Netflix Ribbon\Feign : 客户端负载均衡</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ribbon和Feign都是客户端负载均衡器，它的作用是在服务发生调用的时候帮我们将请求按照某种规则分发到多个目标服务器上，简单理解就是用来解决微服务之间的通信问题。</span><br></pre></td></tr></table></figure><h5 id="Netflix-Hystrix-：断路器"><a href="#Netflix-Hystrix-：断路器" class="headerlink" title="Netflix Hystrix ：断路器"></a>Netflix Hystrix ：断路器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">微服务的调用是非常复杂的，有的时候一个请求需要很多的微服务共同完成，那么一旦某个服务发生故障，导致整个调用链上的微服务全都出现异常，甚至导致整个微服务架构瘫痪。Hystrix就是用来解决微服务故障，保护微服务安全的组件。</span><br></pre></td></tr></table></figure><h5 id="Netflix-Zuul-：-服务网关"><a href="#Netflix-Zuul-：-服务网关" class="headerlink" title="Netflix Zuul ： 服务网关"></a>Netflix Zuul ： 服务网关</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zuul作为服务网关，我们可以把它看作是微服务的大门，所有的请求都需要经过zuul之后才能到达目标服务，根据这一特性，我们可以把微服务公共的是事情交给zuul统一处理，如：用户鉴权，请求监控等。</span><br></pre></td></tr></table></figure><h5 id="Spring-Cloud-Config-：分布式配置"><a href="#Spring-Cloud-Config-：分布式配置" class="headerlink" title="Spring Cloud Config ：分布式配置"></a>Spring Cloud Config ：分布式配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">微服务架构中的服务实例非常的多，服务的配置文件分散在每个服务中，每次修改服务的配置文件和重新服务实例都是一个很麻烦的工作，Spring Cloud Config作为分布式配置管理中心就是用来统一的管理服务的配置文件。</span><br></pre></td></tr></table></figure><h5 id="Spring-Cloud-Bus-消息总线"><a href="#Spring-Cloud-Bus-消息总线" class="headerlink" title="Spring Cloud Bus : 消息总线"></a>Spring Cloud Bus : 消息总线</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消息总线是在微服务中给各个微服务广播消息的一个组件，我们使用消息总线构建一个消息中心，其他微服务来接入到消息中心，当消息总线发起消息，接入的微服务都可以收到消息从而进行消费。</span><br></pre></td></tr></table></figure><h5 id="Spring-Cloud-sleuth-微服务链路追踪"><a href="#Spring-Cloud-sleuth-微服务链路追踪" class="headerlink" title="Spring Cloud sleuth :微服务链路追踪"></a>Spring Cloud sleuth :微服务链路追踪</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当我们的应用采用微服务架构之后，后台可能有几十个甚至几百个服务在支撑，一个请求请求可能需要多次的服务调用最后才能完成，链路追踪的作用就是来监控维护之间的调用关系,让程序员方便直观的感受到一个请求经历了哪些微服务，以及服务的请求时间，是否有异常等。</span><br></pre></td></tr></table></figure><h2 id="SpringCloud的版本"><a href="#SpringCloud的版本" class="headerlink" title="SpringCloud的版本"></a>SpringCloud的版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringCloud是基于SpringBoot的,所以两者的jar包都需要导入,需要注意的是SprinbCloud的版本需要和SpringBoot的版本兼容</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Release Train</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left">Hoxton</td><td align="left">2.2.x</td></tr><tr><td align="left">Greenwich</td><td align="left">2.1.x</td></tr><tr><td align="left">Finchley</td><td align="left">2.0.x</td></tr><tr><td align="left">Edgware</td><td align="left">1.5.x</td></tr><tr><td align="left">Dalston</td><td align="left">1.5.x</td></tr></tbody></table><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607191545152-a73a89.png" alt="image-20230607191545152"></p><h2 id="多模块结构"><a href="#多模块结构" class="headerlink" title="多模块结构"></a>多模块结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中，父项目和子项目都是一个maven项目，其中父项目只用来对jar包进行管理</span><br><span class="line"></span><br><span class="line">springcloud-parent <span class="comment">//父项目</span></span><br><span class="line">pom.xml<span class="comment">//父项目的pom，父项目里面引入的依赖会继承给子项目</span></span><br><span class="line">springcloud-eureka-server-<span class="number">1010</span> <span class="comment">//注册中心EurekaServer </span></span><br><span class="line">springcloud-user-server-<span class="number">1020</span>   <span class="comment">//用户服务EurekaClient ,提供者 </span></span><br><span class="line">springcloud-order-server-<span class="number">1030</span>  <span class="comment">//订单服务EurekaClient ,消费者</span></span><br></pre></td></tr></table></figure><h3 id="搭建父项目"><a href="#搭建父项目" class="headerlink" title="搭建父项目"></a>搭建父项目</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父项目只需要pom文件，只对jar包进行声明，不写代码，所以构建完成后将src文件删掉即可</span><br><span class="line">    </span><br><span class="line">   &lt;!--公共的一些配置--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;!--编码--&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;!--java版本--&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;!--<span class="number">1.</span>管理 SpringBoot的jar包 在父项目中引入springboot，子项目会间接继承springboot--&gt;</span><br><span class="line">    &lt;!--SpringBoot--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.2</span><span class="number">.5</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">2.</span>管理 SpringCloud的jar包--&gt;</span><br><span class="line">    &lt;!-- 放置在管理依赖里面--&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;!--注意版本--&gt;</span><br><span class="line">                &lt;version&gt;Hoxton.SR3&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">3.</span>这里是所有子项目都可以用的jar包，每个模块都需要使用的，就放在这个里面--&gt;</span><br><span class="line">     &lt;!--放置公共模块都要使用的jar包，或者大部分模块都要用的jar包--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="搭建Eureka-Server"><a href="#搭建Eureka-Server" class="headerlink" title="搭建Eureka Server"></a>搭建Eureka Server</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring-cloud-starter-netflix-eureka-server --&gt;</span><br><span class="line">    &lt;!-- 引入Eureka使得它成为一个注册中心的项目--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">     &lt;!-- 引入springboot 的web模块，使得写一个启动类就可以启动了--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">提示：spring-cloud-starter-netflix-eureka-server作为EurekaServer端的基础依赖，但同时这个包也把EurekaClient端的以来也导入进来了，spring-boot-starter-web作为web服务的基础依赖是不可缺少的。</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动类除了和以前一样，还得多加一个注解，申明他是一个Eureka Server </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注册中心启动类</span></span><br><span class="line"><span class="comment"> * @EnableEurekaServer : 开启EurekaServer服务端</span></span><br><span class="line"><span class="comment"> * 在主配置类上通过 @EnableEurekaServer 注解开启了EurekaServer端的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication1010</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication1010.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写配置-yml里面配置"><a href="#写配置-yml里面配置" class="headerlink" title="写配置(yml里面配置)"></a>写配置(yml里面配置)</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1010</span>  <span class="comment">#端口</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#主机</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#客户端配置</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span>  <span class="comment">#EurekaServer自己不要注册到EurekaServer自己 ，只有EurekaClient才注册</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span>  <span class="comment">#EurekaServer不要拉取服务的通信地址列表 ，只有EurekaClient才拉取地址列表</span></span><br><span class="line">    <span class="attr">serviceUrl:</span> <span class="comment">#注册中心的注册地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">https://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;</span>  <span class="comment">#http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/  地址后面是自己定的，</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment">#关闭自我保护警告</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里配置了EurekaServer的端口为 <span class="number">1010</span> ，主机名 localhost ，需要特别说明的是我们再引入EurekaServer的基础依赖spring-cloud-starter-netflix-eureka-server时，这个依赖即引入了EurekaServer所需要的包，也引入了EurekaClient的包，换句话说，现在的springcloud-eureka-server-<span class="number">1010</span>工程既是一个 EurekaServer，也是一个EurekaClient。</span><br><span class="line"></span><br><span class="line">我们这里暂时把EurekaClient的功能屏蔽掉 ，即关闭它的服务注册和发现功能，让他做好EurekaServer该做的事情即可。</span><br><span class="line">- serviceUrl是服务注册地址，EurekaClient需要注册到EurekaServer就得跟上该地址。</span><br><span class="line">- registerWithEureka=<span class="literal">false</span> ：禁止自己向自己注册</span><br><span class="line">- fetchRegistry=<span class="literal">false</span> ： 禁止拉取服务注册列表</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动springcloud-eureka-server-<span class="number">1010</span>工程，浏览器访问 http:<span class="comment">//localhost:1010 ,出现如下界面代码EurekaServer集成成功：</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607193239240-791cb3.png" alt="image-20230607193239240"></p><h2 id="搭建Eureka-Client"><a href="#搭建Eureka-Client" class="headerlink" title="搭建Eureka Client"></a>搭建Eureka Client</h2><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        导入 eureka 客户端的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--        导入springboot web依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用户的启动类</span></span><br><span class="line"><span class="comment"> * @EnableEurekaClient： 标记该应用是 Eureka客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主配置类通过打<span class="doctag">@EnableEurekaClient</span>注解开启EurekaClient客户端功能，</span></span><br><span class="line"><span class="comment"> * 当然如果不打这个标签也能实现功能，</span></span><br><span class="line"><span class="comment"> * 因为导入spring-cloud-starter-netflix-eureka-client 依赖后，</span></span><br><span class="line"><span class="comment"> * 默认就开启了EurekaClient</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServerApplication1020</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserServerApplication1020.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml"></a>配置yml</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注册到EurekaServer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment">#  注意必须要带 /eureka/ 不带会报错</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1010/eureka/</span></span><br><span class="line">  <span class="comment">#  注册到上面使得注册中心用IP地址,允许用ip注册</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#使用ip地址进行注册</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span>    <span class="comment">#实例ID</span></span><br><span class="line"><span class="comment">#注册到服务端的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1020</span></span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">启动springcloud-user-server-<span class="number">1020</span> ， 浏览器再次访问http:<span class="comment">//localhost:1010，那你应该可以看到我们的user-server服务已经被注册到EurekaServer</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607200723630-4eff0e.png" alt="image-20230607200723630"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认情况下EurekaClient使用hostname进行注册到EurekaServer，我们希望使用ip进行注册，可以通过配置eureka.instance.prefer-ip-address=<span class="literal">true</span>来指定，同时为了方便区分和管理服务实例，我们指定服务的实例ID，通过eureka.instance.instance-id为user-serer:<span class="number">1020</span>来指定，具体配置如下：</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span> #使用ip地址进行注册</span><br><span class="line">    instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;    #实例ID</span><br></pre></td></tr></table></figure><h1 id="RestTemplate服务通信"><a href="#RestTemplate服务通信" class="headerlink" title="RestTemplate服务通信"></a>RestTemplate服务通信</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">流程如下，相当于两个客户端进行通讯，一个客户端要访问另一个客户端的信息，注意观察下面的公共模块封装实体类</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607201521049-df7bb7.png" alt="image-20230607201521049"></p><h3 id="用户编写服务"><a href="#用户编写服务" class="headerlink" title="用户编写服务"></a>用户编写服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户服务：暴露接口给订单访问</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订单服务来调用这个方法      http://localhost:1020/user/10</span></span><br><span class="line">    <span class="comment">// @GetMapping(value = &quot;/user/&#123;id&#125;&quot; )</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据id去数据库查询User</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">User</span>(id,<span class="string">&quot;zs:&quot;</span>+id,<span class="string">&quot;我是zs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订单服务获取用户方法"><a href="#订单服务获取用户方法" class="headerlink" title="订单服务获取用户方法"></a>订单服务获取用户方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在订单服务中需要使用RestTemplate调用用户服务，我们需要把RestTmplate配置成Bean方便使用</span><br><span class="line">  在启动类里面配置下面，将它注入到spring容器里面</span><br><span class="line"><span class="comment">//配置一个RestTemplate ，Spring封装的一个机遇Restful风格的http客户端 工具</span></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//注入到容器中，相当于之前在Spring配置文件中写的《bean》 标签</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单服务</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要配置成Bean,所以就可以自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate  restTemplate ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浏览器调用该方法</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/order/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">          <span class="comment">//通过orderId 查到对应的Order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(id, <span class="string">&quot;asd123asdasd12312&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">130.23</span>), id, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过user-serve 发起请求查询对应的用户</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//发送http请求调用 user的服务，获取user对象 ： RestTemplate</span></span><br><span class="line">        <span class="comment">//目标资源路径：user的ip,user的端口，user的Controller路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:1020/user/&quot;</span>+id; </span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//发送http请求，第二个参数是返回值类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, User.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">依次启动服务，然后进行地址访问即可</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">改变端口，需要重新修改地址，因为地址是写死的，所以不灵活，而且地址每次都得拼接，集群没办法使用！！！！！，起不到负载均衡的问题</span><br></pre></td></tr></table></figure><h1 id="Ribbon客户端负载均衡"><a href="#Ribbon客户端负载均衡" class="headerlink" title="Ribbon客户端负载均衡"></a>Ribbon客户端负载均衡</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将user-server(用户服务)做集群处理，增加到<span class="number">2</span>个节点(注意：两个user-server(用户服务)的服务名要一样，ip和端口不一样)，在注册中心的服务通信地址清单中user-server(用户服务)这个服务下面会挂载两个通信地址 。 order-server(订单服务)会定时把服务通信地址清单拉取到本地进行缓存， 那么当order-server(订单服务)在向user-server(用户服务)发起调用时，需要指定服务名为 user-server(用户服务)；那么这个时候，ribbon会根据user-server(用户服务)这个服务名找到两个order-server的通信地址， 然后`ribbon会按照负载均衡算法(默认轮询)选择其中的某一个通信地址，发起http请求实现服务的调用</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607203510447-58601a.png" alt="image-20230607203510447"></p><h2 id="提供者user-server-用户服务-集群"><a href="#提供者user-server-用户服务-集群" class="headerlink" title="提供者user-server(用户服务)集群"></a>提供者user-server(用户服务)集群</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">让springboot对一个实例开启多个运行，通过修改端口，即修改端口和ip开启服务，再次修改再次开启，</span><br><span class="line">具体操作看   《其他》里面的第一条</span><br></pre></td></tr></table></figure><h2 id="控制层拿到端口号"><a href="#控制层拿到端口号" class="headerlink" title="控制层拿到端口号"></a>控制层拿到端口号</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为了更清楚的看出来，访问user是通过不同的端口号进行访问，所以我们在控制层拿到端口号并且进行打印，这一步其实为了看出来，没必要必须配置，通过下面的方式获取</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件里面的端口值注入给这个端口</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br></pre></td></tr></table></figure><h2 id="消费者Order-server集成Ribbon"><a href="#消费者Order-server集成Ribbon" class="headerlink" title="消费者Order-server集成Ribbon"></a>消费者Order-server集成Ribbon</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="开启负载均衡"><a href="#开启负载均衡" class="headerlink" title="开启负载均衡"></a>开启负载均衡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改RestTemplate的Bean的定义方法，加上Ribbon的负载均衡注解<span class="meta">@LoadBalanced</span>赋予RestTemplate有负债均衡的能力。</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//配置一个RestTemplate ，Spring封装的一个机遇Restful风格的http客户端 工具</span></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//注入到容器中，相当于之前在Spring配置文件中写的《bean》 标签</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">//@LoadBalanced :让RestTemplate有负载均衡的功能</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="修改controller"><a href="#修改controller" class="headerlink" title="修改controller"></a>修改controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在 RestTemplate 调用用户服务是通过用户服务的主机加上端口“localhost:<span class="number">1020</span>”的调用方式，现在把 “localhost:<span class="number">1020</span>” 修改为 用户服务的服务名 。底层会通过服务发现的方式使用Ribbin进行负载均衡调用。</span><br><span class="line">    </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要配置成Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate  restTemplate ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浏览器调用该方法</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/order/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123; </span><br><span class="line">           <span class="comment">//通过orderId 查到对应的Order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(id, <span class="string">&quot;asd123asdasd12312&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">130.23</span>), id, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//通过user-serve 发起请求查询对应的用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接改成服务名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://user-server/user/&quot;</span> + userId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用restTemplate 发送http请求</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">分别启动服务，然后去访问消费者Order的方法</span><br><span class="line">观察响应的结果中的端口变化 - 端口会交替出现<span class="number">1020</span>，,<span class="number">1021</span>我们可以推断出Ribbon默认使用的是轮询策略。</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>Ribbon内置7种负载均衡算法，每种算法对应了一个算法类如下：</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607204559457-9d4698.png" alt="image-20230607204559457"></p><h3 id="配置负载均衡算法"><a href="#配置负载均衡算法" class="headerlink" title="配置负载均衡算法"></a>配置负载均衡算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ribbon可以进行全局负载均衡算法配置，也可以针对于具体的服务做不同的算法配置。同时可以使用注解方式和yml配置方式来实现上面两种情况。</span><br></pre></td></tr></table></figure><h4 id="注解方式配置"><a href="#注解方式配置" class="headerlink" title="注解方式配置"></a>注解方式配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">只需要RandomRule配置成Bean即可，在RestTemplate 申明的地方一样注入</span><br><span class="line"></span><br><span class="line">  <span class="comment">//配置一个RestTemplate ，Spring封装的一个机遇Restful风格的http客户端 工具</span></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//注入到容器中，相当于之前在Spring配置文件中写的《bean》 标签</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">//@LoadBalanced :让RestTemplate有负载均衡的功能</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//负载均衡算法---随机算法的对象，交给spring管理</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RandomRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">一个是配置RestTemplate 和Ribbon负载均衡，第二个是设置负载均衡算法，之后就可以进行测试了</span><br></pre></td></tr></table></figure><h4 id="yml进行配置"><a href="#yml进行配置" class="headerlink" title="yml进行配置"></a>yml进行配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">配置全局Ribbon算法</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">   <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">配置某个服务的Ribbon算法</span></span><br><span class="line"><span class="comment">#随机的在这里进行配置</span></span><br><span class="line"><span class="attr">user-server:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line">    </span><br><span class="line"><span class="string">之后也可以进行测试</span></span><br></pre></td></tr></table></figure><h2 id="Ribbon调优配置（了解，没仔细看）"><a href="#Ribbon调优配置（了解，没仔细看）" class="headerlink" title="Ribbon调优配置（了解，没仔细看）"></a>Ribbon调优配置（了解，没仔细看）</h2><h3 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用Ribbon进行服务通信时为了防止网络波动造成服务调用超时，我们可以针对Ribbon配置超时时间以及重试机制</span><br><span class="line">    </span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">3000</span>#读取超时时间</span><br><span class="line">  ConnectTimeout: <span class="number">3000</span>#链接超时时间</span><br><span class="line">  MaxAutoRetries: <span class="number">1</span> #重试机制：同一台实例最大重试次数，失败了一台机</span><br><span class="line">  MaxAutoRetriesNextServer: <span class="number">1</span> #重试负载均衡其他的实例最大重试次数</span><br><span class="line">  OkToRetryOnAllOperations: <span class="literal">false</span>  #是否所有操作都重试，因为针对post请求如果没做幂等处理可能会造成数据多次添加/修改</span><br></pre></td></tr></table></figure><h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在启动服务使用Ribbon发起服务调用的时候往往会出现找不到目标服务的情况，这是因为Ribbon在进行客户端负载均衡的时候并不是启动时就创建好的，而是在实际请求的时候才会去创建，所以往往在发起第一次调用的时候会出现超时导致服务调用失败，可以通过设置Ribbon的饥饿加载来改善此情况，即在服务启动时就把Ribbon相关内容创建好。</span><br><span class="line">    </span><br><span class="line"> ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span> #开启饥饿加载</span><br><span class="line">    clients: user-server #针对于哪些服务需要饥饿加载</span><br></pre></td></tr></table></figure><h1 id="OpenFeign-通讯以及负载均衡"><a href="#OpenFeign-通讯以及负载均衡" class="headerlink" title="OpenFeign -通讯以及负载均衡"></a>OpenFeign -通讯以及负载均衡</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feign是一个声明式的http客户端，使用Feign可以实现声明式REST调用，它的目的就是让WebService调用更加简单。Feign整合了Ribbon和SpringMvc注解，这让Feign的客户端接口看起来就像一个Controller。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。同时Feign整合了Hystrix，可以很容易的实现服务熔断和降级(关于Hystrix我们后面再讲)。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607205858232-bcba69.png" alt="image-20230607205858232"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所以对于上面两个方法，这个一个就解决了，所以大部分用这个，所以从头到尾讲一下配置过程</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1.</span>导入EurekaClient的包--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--<span class="number">2.</span>导入Feign的包--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--web包--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--user-common--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-common&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="启动类配置"><a href="#启动类配置" class="headerlink" title="启动类配置"></a>启动类配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主配置类增加<span class="meta">@EnableFeignClients</span>标签 , 其value属性可以指定Feign的客户端接口的包,当然也可以省略value属性</span><br><span class="line"><span class="meta">@EnableFeignClients</span> :开启Feign支持</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> </span><br><span class="line"><span class="comment">//注意后面的路径</span></span><br><span class="line"><span class="meta">@EnableFeignClients(value=&quot;cn.neusoft.feignclient&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServerApplication1040</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PayServerApplication1040.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注册到EurekaServer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment">#  注意必须要带 /eureka/ 不带会报错</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1010/eureka/</span></span><br><span class="line">  <span class="comment">#  注册到上面使得注册中心用IP地址,允许用ip注册</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#使用ip地址进行注册</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span>    <span class="comment">#实例ID</span></span><br><span class="line"><span class="comment">#注册到服务端的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pay-server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1040</span></span><br></pre></td></tr></table></figure><h3 id="Feign的客户端接口"><a href="#Feign的客户端接口" class="headerlink" title="Feign的客户端接口"></a>Feign的客户端接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feign的客户端接口是用来调用微服务的，编写了一个用来调用用户服务的客户端接口，相当于模块间通讯的</span><br><span class="line"><span class="comment">//标记为FeignClient  就可以调用其他服务的接口了</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//直接将UserController上面的接口复制过来，注意如果Usercontroller上面有路径记得该路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-server&quot;)</span> : user-server是用户服务的服务名字，Feign根据服务名能够在注册中心找到目标服务的通信地址</span><br><span class="line">    </span><br><span class="line">方法：把要调用的目标服务的controller方法拷贝过来，然后去掉方法体即可。</span><br><span class="line"></span><br><span class="line"> 即：服务名要一致 ， url路径要一致 ， 参数要一致 ， 返回值类型要一致。</span><br><span class="line">建议 ：服务名直接去目标服务配置中拷贝 ， 方法直接从目标服务controller中拷贝</span><br></pre></td></tr></table></figure><h3 id="编写Controller使用Feign接口"><a href="#编写Controller使用Feign接口" class="headerlink" title="编写Controller使用Feign接口"></a>编写Controller使用Feign接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支付服务的controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserFeignClient userFeignClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浏览器来掉</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pay/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//使用Feign调用用户服务获取User</span></span><br><span class="line">        <span class="keyword">return</span> userFeignClient.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接用浏览器访问这个方法的地址，</span><br><span class="line"></span><br><span class="line">多次请求发现依然默认使用了轮询策略</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">要使用Feign，除了导入依赖之外，需要主配置类通过<span class="meta">@EnableFeignClients(value=&quot;&quot;)</span>注解开启Feign,通过value属性指定了Feign的扫描包。</span><br><span class="line">   同时需要为Feign编写客户端接口，接口上需要注解<span class="meta">@FeignClient</span>标签。 当程序启动，注解了<span class="meta">@FeignClient</span>的接口将会被扫描到然后交给Spring管理。</span><br><span class="line"></span><br><span class="line">当请求发起，会使用jdk的动态代理方式代理接口，生成相应的RequestTemplate，Feign会为每个方法生成一个RequestTemplate同时封装好http信息，如：url，请求参数等等</span><br><span class="line"></span><br><span class="line">       最终RequestTemplate生成request请求，交给Http客户端(UrlConnection,HttpClient,OkHttp)。然后Http客户端会交给LoadBalancerClient，使用Ribbon的负载均衡发起调用。</span><br></pre></td></tr></table></figure><h2 id="Feign的参数配置-扩展"><a href="#Feign的参数配置-扩展" class="headerlink" title="Feign的参数配置(扩展)"></a>Feign的参数配置(扩展)</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feign已经集成了Ribbon，所以它的负载均衡配置基于Ribbon配置即可，这里使用xml简单配置负载均衡策略如下</span><br><span class="line"></span><br><span class="line">user-server:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><h3 id="Feign的超时配置"><a href="#Feign的超时配置" class="headerlink" title="Feign的超时配置"></a>Feign的超时配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果在服务调用时出现了 “feign.RetryableException : Read timed out...”错误日志，说明Ribbon处理超时 ，我们可以配置Ribbon的超时时间：</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">ConnectTimeout: <span class="number">3000</span></span><br><span class="line">    ReadTimeout: <span class="number">6000</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"> 如果服务调用出现“com.netflix.hystrix.exception.HystrixRuntimeException：.. timed - out and no fallback available” 错误日志，是因为Hystrix超时，默认Feign集成了Hystrix，但是高版本是关闭了Hystrix，我们可以配置Hystrix超时时间：</span><br><span class="line">        </span><br><span class="line">feign:</span><br><span class="line">   hystrix:</span><br><span class="line">       enabled: <span class="literal">true</span> #开启熔断支持</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        execution:</span><br><span class="line">          isolation:</span><br><span class="line">            thread:</span><br><span class="line">              timeoutInMilliseconds: <span class="number">6000</span>   #hystrix超时时间      </span><br></pre></td></tr></table></figure><h3 id="Feign开启日志调试"><a href="#Feign开启日志调试" class="headerlink" title="Feign开启日志调试"></a>Feign开启日志调试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">有的时候我们需要看到Feign的调用过程中的参数及相应，我们可以对Feign的日志进行配置，Feign支持如下几种日志模式来决定日志记录内容多少：</span><br><span class="line"></span><br><span class="line">- NONE，不记录（DEFAULT）。</span><br><span class="line">- BASIC，仅记录请求方法和URL以及响应状态代码和执行时间。</span><br><span class="line">- HEADERS，记录基本信息以及请求和响应标头。</span><br><span class="line">- FULL，记录请求和响应的标题，正文和元数据。</span><br></pre></td></tr></table></figure><h4 id="创建Feign配置类"><a href="#创建Feign配置类" class="headerlink" title="创建Feign配置类"></a>创建Feign配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;<span class="comment">//打印Feign的所有日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置日志打印级别"><a href="#配置日志打印级别" class="headerlink" title="配置日志打印级别"></a>配置日志打印级别</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置UserFeignClient的日志打印级别，上面的配置打印Feign的那些内容，下面这个是配置日志框架打印日志的级别，不修改可能打印不出来日志，DEBUG打印日志调试信息。</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    cn.neusoft: debug</span><br></pre></td></tr></table></figure><h3 id="Feign开启GZIP"><a href="#Feign开启GZIP" class="headerlink" title="Feign开启GZIP"></a>Feign开启GZIP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以通过开启Feign的数据压缩传输来节省网络开销，但是压缩数据会增加CPU的开销，所以太小的数据没必要压缩，可以通过压缩大小阈值来控制，配置如下：</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  compression:</span><br><span class="line">    request:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">      min-request-size: <span class="number">1024</span> #最小阈值，小于这个不压缩</span><br><span class="line">      mime-types: text/xml,application/xml,application/json #压缩哪些类型的数据</span><br><span class="line">    response:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="Hystrix熔断器"><a href="#Hystrix熔断器" class="headerlink" title="Hystrix熔断器"></a>Hystrix熔断器</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">熔断机制是对服务链路的保护机制，如果链路上的某个服务不可访问，调用超时，发生异常等，服务会触发降级返回托底数据，然后熔断服务的调用(失败率达到某个阀值服务标记为短路状态)，当检查到该节点能正常使用时服务会快速恢复。</span><br><span class="line"></span><br><span class="line">简单理解就是当服务不可访问了或者服务器报错了或者服务调用超过一定时间没返回结果，就立马触发熔断机制配合降级返回预先准备的兜底数据返回，不至于长时间的等待服务的相应造成大量的请求阻塞，也不至于返回一些错误信息给客户端，而是返回一些兜底数据。</span><br><span class="line">    </span><br><span class="line">超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。</span><br><span class="line">简单理解就是服务降级就是当服务因为网络故障，服务器故障，读取超时等原因造成服务不可达的情况下返回一些预先准备好的数据给客户端。</span><br></pre></td></tr></table></figure><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--    导入hystrix依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主配置类通过 <span class="meta">@EnableCircuitBreaker</span> 标签开启熔断功能</span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span> <span class="comment">//允许熔断</span></span><br></pre></td></tr></table></figure><h3 id="熔断两种方法"><a href="#熔断两种方法" class="headerlink" title="熔断两种方法"></a>熔断两种方法</h3><h4 id="方法熔断"><a href="#方法熔断" class="headerlink" title="方法熔断"></a>方法熔断</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过 <span class="meta">@HystrixCommand</span> 标签标记方法熔断，标签的fallbackMethod属性指定拖地方法。那么当该方法在像远程服务发起调用出现异常，或是方法本身出现异常都会触发托底方法的执行，最终结果是托底方法的返回结果。</span><br><span class="line"></span><br><span class="line"> <span class="comment">//浏览器调用该方法</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="comment">//方法熔断，即如果方法访问不到，那么就去执行这个里面的方法</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;fallbackMethod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserByOrderId</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//通过orderId 查到对应的Order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(id, <span class="string">&quot;asd123asdasd12312&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">130.23</span>), id, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//通过user-serve 发起请求查询对应的用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> order.getUserId();</span><br><span class="line">        <span class="comment">//String url = &quot;http://localhost:1020/user/&quot; + userId;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接改成服务名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://user-server/user/&quot;</span> + userId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用restTemplate 发送http请求</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//降级方法,参数和返回值必须和被熔断的方法一致 ，方法名要和  fallbackMethod 的值一致</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">fallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//返回托底数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1L</span> ,<span class="string">&quot;无此用户&quot;</span>,<span class="string">&quot;用户服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如上所示，如果去访问user的方法访问不了，<span class="meta">@HystrixCommand(fallbackMethod = &quot;fallbackMethod&quot;)</span>通过这个注解去寻找拖地方法fallbackMethod  从而去运行这个方法，注意这个方法  降级方法,参数和返回值必须和被熔断的方法一致 ，方法名要和  fallbackMethod 的值一致</span><br></pre></td></tr></table></figure><h4 id="统一熔断"><a href="#统一熔断" class="headerlink" title="统一熔断"></a>统一熔断</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">也可以在Controller使用 <span class="meta">@DefaultProperties</span>做统一配置</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback =&quot;fallbackMethod&quot;)</span><span class="comment">//统一降级配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span>   <span class="comment">//方法熔断</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/order/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span><br></pre></td></tr></table></figure><h2 id="Hystrix参数配置"><a href="#Hystrix参数配置" class="headerlink" title="Hystrix参数配置"></a>Hystrix参数配置</h2><h3 id="熔断参数配置"><a href="#熔断参数配置" class="headerlink" title="熔断参数配置"></a>熔断参数配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>个参数放在一起，所表达的意思就是： </span><br><span class="line">     每当<span class="number">20</span>个请求中，有<span class="number">50</span>%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。直到5s钟之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。</span><br><span class="line"></span><br><span class="line">hystrix: </span><br><span class="line">  command:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      circuitBreaker:</span><br><span class="line">        requestVolumeThreshold: <span class="number">20</span> #<span class="number">20</span>个请求中</span><br><span class="line">        errorThresholdPercentage: <span class="number">50</span> #出错百分比阈值</span><br><span class="line">        sleepWindowInMilliseconds: <span class="number">50000</span> #短路<span class="number">5</span>秒钟，尝试恢复</span><br></pre></td></tr></table></figure><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们知道在服务的远程调用过程中，如果调用时间过久会触发Ribbon的超时，Hystrix也有超时配置 hystrix.command.<span class="keyword">default</span>.execution.isolation.thread.timeoutInMilliseconds</span><br><span class="line">我们往往会把Ribbon和Hystrix的超时配合起来配置：</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  MaxAutoRetries: <span class="number">1</span> #最大重试次数</span><br><span class="line">  MaxAutoRetriesNextServer: <span class="number">1</span> #切换实例的重试次数</span><br><span class="line">  OkToRetryOnAllOperations: <span class="literal">false</span> # 对所有的操作请求都进行重试，</span><br><span class="line">  ConnectTimeout: <span class="number">1000</span> #请求连接的超时时间</span><br><span class="line">  ReadTimeout: <span class="number">1800</span> #请求处理的超时时间</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: <span class="number">3000</span> #hystrix超时,置thread和semaphore两种隔离策略的超时时间</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">需要注意的是,我们设置了重试机制就需要Hystrix超时时间大于Ribbon超时时间，因为Hystrix超时后会直接熔断就不会再出发重试</span><br></pre></td></tr></table></figure><h3 id="资源隔离模式"><a href="#资源隔离模式" class="headerlink" title="资源隔离模式"></a>资源隔离模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在Hystrix可以通过execution.isolation.strategy配置切换资源隔离模式：线程池或者信号量</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD #默认是线程池，可以修改为信号量： SEMAPHORE</span><br></pre></td></tr></table></figure><h3 id="最大请求设置"><a href="#最大请求设置" class="headerlink" title="最大请求设置"></a>最大请求设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过 execution.isolation.semaphore.maxConcurrentRequests 配置信号量模式下的最大请求数量(并发)</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  threadpool:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      coreSize: <span class="number">10</span> #最大线程数 , 并发执行的最大线程数，默认<span class="number">10</span></span><br><span class="line">      maxQueueSize: -<span class="number">1</span> #最大排队长度。默认-<span class="number">1</span>，使用SynchronousQueue。其他值则使用 LinkedBlockingQueue。</span><br><span class="line">      queueSizeRejectionThreshold: <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="Fallback设置"><a href="#Fallback设置" class="headerlink" title="Fallback设置"></a>Fallback设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">并发达到 hystrix.command.<span class="keyword">default</span>.fallback.isolation.semaphore.maxConcurrentRequests`配置的值时，fallback会被被调用，模式<span class="number">10</span></span><br><span class="line"></span><br><span class="line">通过配置hystrix.command.<span class="keyword">default</span>.fallback.enabled开启fallback ，即请求失败尝试走托底</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fallback:</span><br><span class="line">        enabled: <span class="literal">true</span> #请求失败时是否要走托底</span><br><span class="line">         isolation:</span><br><span class="line">           semaphore:</span><br><span class="line">             maxConcurrentRequests: <span class="number">10</span> #fallback最大并发数量</span><br></pre></td></tr></table></figure><h1 id="OpenFeign使用Hystrix"><a href="#OpenFeign使用Hystrix" class="headerlink" title="OpenFeign使用Hystrix"></a>OpenFeign使用Hystrix</h1><h2 id="开启Hystrix"><a href="#开启Hystrix" class="headerlink" title="开启Hystrix"></a>开启Hystrix</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="literal">true</span> #开启熔断支持</span><br></pre></td></tr></table></figure><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务通过Feign接口调用异常或超时需要触发降级，返回托底数据。这里有两种方式，分别是通过<span class="meta">@FeignClient(fallback=..)</span> ,以及<span class="meta">@FeignClient(fallbackFactory=..)</span> 来指定托底类，区别在于通过fallback的方式编写的托底是没办法打印出异常日志的 ，而fallbackFactory方式是可以打印出异常日志</span><br></pre></td></tr></table></figure><h2 id="Fiegn接口熔断-fallback方式"><a href="#Fiegn接口熔断-fallback方式" class="headerlink" title="Fiegn接口熔断-fallback方式"></a>Fiegn接口熔断-fallback方式</h2><h3 id="拖地实现类"><a href="#拖地实现类" class="headerlink" title="拖地实现类"></a>拖地实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">托底类需要交给Spirng管理，类上需要打 <span class="meta">@Component</span> 注解 ， 拖地类需要实现 Feign接口，复写接口中的方法作为托底方法返回拖地数据。当Fiegn调用失败就会以拖地方法返回的结果返回给用户</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//让Spring扫描到该托底类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//UserFeignClientFallback 为它创建实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFeignClientFallback</span> <span class="keyword">implements</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志打印器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UserFeignClientFallback.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;用户服务不可用&quot;</span>);</span><br><span class="line">        <span class="comment">//托底数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1l</span>, <span class="string">&quot;无此用户&quot;</span>, <span class="string">&quot;用户服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置托底类"><a href="#配置托底类" class="headerlink" title="配置托底类"></a>配置托底类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先在客户端接口配置fallback  <span class="meta">@FeignClient</span>里面加入参数fallback = UserFeignClientFallback.class  后面的参数就是拖地类的字节码文件，之后就可以测试了</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;user-server&quot;,fallback = UserFeignClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订单服务来调用这个方法      http://localhost:1020/user/10</span></span><br><span class="line">    <span class="comment">// @GetMapping(value = &quot;/user/&#123;id&#125;&quot; )</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fiegn接口熔断-fallbackFactory方式"><a href="#Fiegn接口熔断-fallbackFactory方式" class="headerlink" title="Fiegn接口熔断-fallbackFactory方式"></a>Fiegn接口熔断-fallbackFactory方式</h2><h3 id="拖地实现工厂"><a href="#拖地实现工厂" class="headerlink" title="拖地实现工厂"></a>拖地实现工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">工程方式的托底类需要去实现 FallbackFactory接口 ，并指定泛型为Feign客户端接口(UserFeignClient)。FallbackFactory的create方法返回了Feign客户端接口的实例，该方法的throwable是参数是Feign调用失败的异常信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂方式的 ， 托底类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFeignClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;UserFeignClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拖地方法 ： throwable，异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserFeignClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回UserFeignClient 接口的实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserFeignClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把异常信息打印到控制台</span></span><br><span class="line">                log.error(throwable.getMessage());</span><br><span class="line">                <span class="comment">// throwable.printStackTrace();</span></span><br><span class="line">                <span class="comment">//真正拖地方法 ， 这里的数据是托底数据</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1L</span>, <span class="string">&quot;无此用户&quot;</span>, <span class="string">&quot;工厂服务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置托底工厂"><a href="#配置托底工厂" class="headerlink" title="配置托底工厂"></a>配置托底工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置方式类似托底类</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;user-server&quot;, fallbackFactory = UserFeignClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接将UserController上面的接口复制过来，注意如果Usercontroller上面有路径记得该路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务网关-spring-cloud-zuul"><a href="#服务网关-spring-cloud-zuul" class="headerlink" title="服务网关-spring cloud zuul"></a>服务网关-spring cloud zuul</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zuul 是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet(filter)应用。Zuul 在云平台上提供动态路由(请求分发)，监控，弹性，安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门，也要注册入Eureka</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607224020039-cc3633.png" alt="image-20230607224020039"></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="引入依赖-4"><a href="#引入依赖-4" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="启动类-2"><a href="#启动类-2" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的启动类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableEurekaClient</span>： 标记该应用是 Eureka客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableZuulProxy</span> ： 开启zuul 可以看做是 <span class="doctag">@EnableZuulServer</span> 的增强版 ，一般用这个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableZuulServer</span> : 这个标签也可以开启zuul，但是这个标签开启的Filter更少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulServerApplication1060</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(ZuulServerApplication1060.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件配置zuul"><a href="#配置文件配置zuul" class="headerlink" title="配置文件配置zuul"></a>配置文件配置zuul</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注册到EurekaServer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment">#  注意必须要带 /eureka/ 不带会报错</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1010/eureka/</span></span><br><span class="line">  <span class="comment">#  注册到上面使得注册中心用IP地址,允许用ip注册</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#使用ip地址进行注册</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span>    <span class="comment">#实例ID</span></span><br><span class="line"><span class="comment">#注册到服务端的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul-server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1060</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置网关</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">&quot;/servers&quot;</span>  <span class="comment">#统一访问前缀</span></span><br><span class="line">  <span class="attr">ignoredServices:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#禁用掉使用浏览器通过服务名的方式访问服务</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="comment">#注意地址重复，别少加地址</span></span><br><span class="line">    <span class="attr">pay-server:</span> <span class="string">&quot;/payserver/**&quot;</span>   <span class="comment">#指定pay-server这个服务使用 /payserver路径来访问  - 别名  相当于访问前需要加上 /servers/ payserver +自己的映射地址</span></span><br><span class="line">    <span class="attr">order-server:</span> <span class="string">&quot;/order/**&quot;</span>   <span class="comment">#指定order-server这个服务使用 /order路径来访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- zuul.prefix  ： 作为统一的前缀，在浏览器访问的时候需要加上该前缀 </span><br><span class="line">- zuul.ignoredServices ： 忽略使用服务名方式访问服务，而是通过routes指定的路径进行访问</span><br><span class="line">- zuul.routes :  配置服务的访问路径</span><br></pre></td></tr></table></figure><h3 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">去进行访问测试即可</span><br></pre></td></tr></table></figure><h2 id="自定义zuul的Filter"><a href="#自定义zuul的Filter" class="headerlink" title="自定义zuul的Filter"></a>自定义zuul的Filter</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于zuul本质上是一个Filter  所以我们可以尝试自己写一个过滤器  </span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607225005895-4bf948.png" alt="image-20230607225005895"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正常流程：请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</span><br><span class="line"></span><br><span class="line">异常流程：</span><br><span class="line">整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</span><br><span class="line">如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。</span><br><span class="line">如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。</span><br></pre></td></tr></table></figure><h3 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Zuul提供了一个抽象的Filter:ZuulFilter我们可以通过该抽象类来自定义Filter，该Filter有四个核心方法，如下：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ZuulFilter</span> <span class="keyword">implements</span> <span class="title class_">IZuulFilter</span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面两个方法是 IZuulFilter 提供的 </span></span><br><span class="line">       <span class="comment">//返回结果决定 是否要执行run方法  返回true，要进行验证，不验证的返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- filterType ：是用来指定filter的类型的（类型见常量类：FilterConstants）</span><br><span class="line">- filterOrder ：是filter的执行顺序，越小越先执行</span><br><span class="line">- shouldFilter ：是其父接口IZuulFilter的方法，用来决定run方法是否要被执行</span><br><span class="line">- run ：是其父接口IZuulFilter的方法，该方法是Filter的核心业务方法</span><br></pre></td></tr></table></figure><h4 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h4><p>我们来演示一个案例，在Zuul层实现统一的登录检查：如果请求头中有“token”属性，我们就认为已经登录成功，可以继续往下游的服务执行，否则就视为请求未登录，直接返回错误信息，这一需求需要自定义Filter继承ZuulFilter类来实现，具体代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itsource.springboot.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.ZuulFilter;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.context.RequestContext;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.exception.ZuulException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(LoginCheckFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ORDER</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter类型 : &quot;pre&quot;前置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;<span class="comment">//pre</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行顺序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ORDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果决定 是否要执行run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// /static/**  ，/login , /register 不需要做登录检查，返回false</span></span><br><span class="line">        <span class="comment">//1.获取request对象 ， 获取请求中的url</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> RequestContext.getCurrentContext().getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;请求地址：&quot;</span>+url);</span><br><span class="line">        <span class="comment">//2.判断是否包含在： static/**  ，/login , /register</span></span><br><span class="line">        <span class="keyword">if</span>(url.endsWith(<span class="string">&quot;/login &quot;</span>) || url.endsWith(<span class="string">&quot;/register &quot;</span>) || url.contains(<span class="string">&quot;/static/&quot;</span>) )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要做登录检查的返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心业务方法 ： 登录检查 ， 如果请求头中有token，就是登录成功</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取请求对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> RequestContext.getCurrentContext().getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//响应对象</span></span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> RequestContext.getCurrentContext().getResponse();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.如果没有token，登录检查失败 ，</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            <span class="comment">//3.1.返回登录检查失败的错误信息 :&#123; success:false, message:&quot;登录检查失败，请重新登录&quot;&#125;</span></span><br><span class="line">            Map&lt;String,Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            resultMap.put(<span class="string">&quot;success&quot;</span> , <span class="literal">false</span>);</span><br><span class="line">            resultMap.put(<span class="string">&quot;message&quot;</span> , <span class="string">&quot;登录检查失败，请重新登录&quot;</span>);</span><br><span class="line">            <span class="comment">//中文编码</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//把map转成json字符串，写到浏览器</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resultJsonString</span> <span class="operator">=</span> JSON.toJSONString(resultMap);</span><br><span class="line"></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.getWriter().print(resultJsonString);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.2.阻止filter继续往后执行</span></span><br><span class="line">            RequestContext.getCurrentContext().setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的返回结果没有任何意义，不用管</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提示:   </p><ul><li>在 filterType方法中我们返回“pre”前置filter的常量，让他成为前置filter(登录检查需要在请求的最前面来做)</li><li>在filterOrder方法中返回的顺序值是 1 ，执行顺序越小越先执行</li><li>在shouldFilter方法中通过判断请求的url来决定是否需要做登录检查，返回true就是要做然后才会执行run方法</li><li>在run方法中我们通过获取请求头中的token判断是否登录，如果没登录就返回错误信息，阻止继续执行。</li><li>RequestContext.getCurrentContext() 是一个Zuul提供的请求上下文对象</li></ul><p>注意：在返回JSON格式的错误信息时我用到了fastjson，需要在zuul工程中导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.50<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="服务网关SpringCloudGateway（没看）"><a href="#服务网关SpringCloudGateway（没看）" class="headerlink" title="服务网关SpringCloudGateway（没看）"></a>服务网关SpringCloudGateway（没看）</h1><h1 id="配置中心Spring-Cloud-Config（没看）"><a href="#配置中心Spring-Cloud-Config（没看）" class="headerlink" title=".配置中心Spring Cloud Config（没看）"></a>.配置中心Spring Cloud Config（没看）</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="一个Springboot项目启动多个端口实例"><a href="#一个Springboot项目启动多个端口实例" class="headerlink" title="一个Springboot项目启动多个端口实例"></a>一个Springboot项目启动多个端口实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于集群而言，就是一个项目有多个端口，可以在多个端口进行访问，在springboot里面，修改端口号，启动多次即可，对于启动需要修改</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607201306403-c6517b.png" alt="image-20230607201306403"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230607201339662-0450e6.png" alt="image-20230607201339662"></p><p>然后应用，去修改端口就可以发现可以启动多个实例</p><h2 id="公共模块"><a href="#公共模块" class="headerlink" title="公共模块"></a>公共模块</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一些实体类，或者一些通用的返回值，方法等，由于大家都需要，所以构建一个公共模块来进行访问</span><br></pre></td></tr></table></figure><h3 id="引入依赖-5"><a href="#引入依赖-5" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>由于实体类需要getter setter 方法，所以引入lombok依赖，还需要其他依赖按需引入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><p>创建包，创建实体</p><h3 id="其他模块引入"><a href="#其他模块引入" class="headerlink" title="其他模块引入"></a>其他模块引入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在其他模块引入这个模块的依赖就可以使用了</span><br><span class="line"></span><br><span class="line">       &lt;!-- 依赖公共模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springcloud-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC+SSM</title>
      <link href="/posts/25988.html"/>
      <url>/posts/25988.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis整合Spring"><a href="#Mybatis整合Spring" class="headerlink" title="Mybatis整合Spring"></a>Mybatis整合Spring</h1><h2 id="加入Spring的依赖"><a href="#加入Spring的依赖" class="headerlink" title="加入Spring的依赖"></a>加入Spring的依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--加入spring依赖--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="在resources中创建spring-xml"><a href="#在resources中创建spring-xml" class="headerlink" title="在resources中创建spring.xml"></a>在resources中创建spring.xml</h2><h3 id="数据源-连接池对象"><a href="#数据源-连接池对象" class="headerlink" title="数据源 连接池对象"></a>数据源 连接池对象</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 加入连接池--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.1</span><span class="number">.21</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="spring-xml中创建对象"><a href="#spring-xml中创建对象" class="headerlink" title="spring.xml中创建对象"></a>spring.xml中创建对象</h4><p>下面这先展示了一下这个整合过程中所有用的的引用</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    数据库连接的参数，已经写到jdbc文件里面，所以引入文件 classpath: 从类路径下去进行寻找，编译后的类路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--    创建数据源，连接池对象</span></span><br><span class="line"><span class="comment">  有很多连接池对象，c3p0 dbcp druid 本质上都是DataSource这个接口实现</span></span><br><span class="line"><span class="comment">       这里选择druid 引入依赖</span></span><br><span class="line"><span class="comment">   DataSource和数据库有关系，所以就需要提供数据库连接的参数</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--依赖注入，将参数注入进去--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--驱动类名，类名就是一个字符串--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--直接写成username，spring在取值的时候，有可能直接读取主机名称，所以一般不用username        --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--其他参数可配可不配，可以使用默认值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-spring的整合包中提供了一个便于创建的类型引入整合包依赖</span><br><span class="line"></span><br><span class="line">&lt;!--mybaits和spring的整合依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="spring-xml中创建对象-1"><a href="#spring-xml中创建对象-1" class="headerlink" title="spring.xml中创建对象"></a>spring.xml中创建对象</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SqlSessionFactory的创建 ，</span></span><br><span class="line"><span class="comment">   mybatis原生的SqlSessionFactory的创建太麻烦，所以，使用mybatis整合包里面的类型</span></span><br><span class="line"><span class="comment">       在mybatis-spring的整合包中，提供了一个便于创建的类型</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;SqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--本来是读取xml文件的，由于没有xml文件，那么就进行xml里面的内容进行赋值--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--配置别名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;entity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--映射配置引入--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*Mapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mapper接口的实现类对象"><a href="#Mapper接口的实现类对象" class="headerlink" title="Mapper接口的实现类对象"></a>Mapper接口的实现类对象</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mapper代理的创建，主要是去扫描mapper接口--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--定义mapper包的位置，让他去扫描--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Service层的对象"><a href="#Service层的对象" class="headerlink" title="Service层的对象"></a>Service层的对象</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> @Service  加入注解</span><br><span class="line"> public class StudentServiceImpl implements StudentService &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">&lt;!--添加注解扫描，主要就是扫描Service的对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><h3 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--jdbc和tx依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--Aop的依赖--&gt;</span><br><span class="line">       &lt;!--        Aop配置相关依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="切面类对象创建"><a href="#切面类对象创建" class="headerlink" title="切面类对象创建"></a>切面类对象创建</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring事务处理 创建事务处理的切面类对象--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--由于事务是连接池做的，所以需要注入连接池，让他明白给谁做事务处理--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启事务驱动"><a href="#开启事务驱动" class="headerlink" title="开启事务驱动"></a>开启事务驱动</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">上边的引用需要进行添加，这里直接给出总共的</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务注解驱动，相当于AOP的配置，去启动事务注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="给方法配置事务"><a href="#给方法配置事务" class="headerlink" title="给方法配置事务"></a>给方法配置事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service层的方法上添加事务注解</span><br><span class="line">给增删改的方法上添加 <span class="meta">@Transactional</span></span><br><span class="line">给查询方法上添加 <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务注解驱动,如果出错了，那么就会回滚，还可以进行具体设置</span></span><br><span class="line">    <span class="comment">//    (readOnly = true)只读的设置</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="基本测试"><a href="#基本测试" class="headerlink" title="基本测试"></a>基本测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建IOC容器，得到对象，调用方法</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">       studentService = applicationContext.getBean(StudentService.class);</span><br></pre></td></tr></table></figure><h3 id="优化整合测试"><a href="#优化整合测试" class="headerlink" title="优化整合测试"></a>优化整合测试</h3><h4 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--    Spring整合juint  注意要和上面的spring版本一致--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="加入注解"><a href="#加入注解" class="headerlink" title="加入注解"></a>加入注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//指定配置文件的位置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span></span><br><span class="line"><span class="comment">//容器不需要我们去new</span></span><br></pre></td></tr></table></figure><h4 id="获取容器对象"><a href="#获取容器对象" class="headerlink" title="获取容器对象"></a>获取容器对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StudentService studentService;</span><br></pre></td></tr></table></figure><h1 id="SpringMVC创建过程"><a href="#SpringMVC创建过程" class="headerlink" title="SpringMVC创建过程"></a>SpringMVC创建过程</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525200045030-121e12.png" alt="image-20230525200045030"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525200119955-8ba7ba.png" alt="image-20230525200119955"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用maven构建web项目</span><br><span class="line">   选择骨架 maven-a...-webapp</span><br><span class="line"></span><br><span class="line">老师在构建完成后，将这两个改成了1.8</span><br><span class="line">     &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br></pre></td></tr></table></figure><h3 id="完善项目结构"><a href="#完善项目结构" class="headerlink" title="完善项目结构"></a>完善项目结构</h3><p>由于自动创建少一些包，所以自己创建一下</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525200457946-1c52fe.png" alt="image-20230525200457946"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">手动创建：</span><br><span class="line">  src</span><br><span class="line">     main</span><br><span class="line">        java</span><br><span class="line">        resources</span><br><span class="line">        webapp  web模块   已经存在  -------【项目最终发布 发布的就是webapp中的内容】</span><br><span class="line">          WEB-INF</span><br><span class="line">            web.xml  servlet filter listener .....</span><br><span class="line">            classes  输出目录才能看到  java【编译】及resources【copy】目录下的内容编译之后会放入该目录</span><br><span class="line">     test</span><br><span class="line">        java</span><br><span class="line">  pom.xml</span><br></pre></td></tr></table></figure><h2 id="核心控制器（前端控制器）"><a href="#核心控制器（前端控制器）" class="headerlink" title="核心控制器（前端控制器）"></a>核心控制器（前端控制器）</h2><p>核心控制器：用于Web层核心功能的处理以及在所有控制器执行之前，所有的WebMvc框架都采用了这种方式，在SpringMVC中使用的是DispatcherServlet为核心控制器. DispatcherServlet核心控制器会拦截匹配的请求，把拦截下来的请求，依据相应的规则分发到目标Controller来处理；</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/wps1-cdc90c.jpg" alt="img"></p><h2 id="构建核心控制器"><a href="#构建核心控制器" class="headerlink" title="构建核心控制器"></a>构建核心控制器</h2><h3 id="引入依赖-4"><a href="#引入依赖-4" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--    引入spring的依赖--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--    SpringMVC核心包--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--    Spring对web项目的支持--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="在web-xml文件里面配置"><a href="#在web-xml文件里面配置" class="headerlink" title="在web.xml文件里面配置"></a>在web.xml文件里面配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">   前端控制器的概念是一个前段对后端进行一个请求，后端一个中央进行控制，中央来决定这个请求去访问那个方法，这个中央就叫前端控制器</span><br><span class="line">   配置Servlet 前端控制器</span><br><span class="line">     前端控制器需要读取springmvc.xml</span><br><span class="line">     --&gt;</span><br><span class="line">   &lt;servlet&gt;</span><br><span class="line">       &lt;!--        通过名称将两个连接起来，和下面的servlet-mapping--&gt;</span><br><span class="line">       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!--         前端控制器需要读取springmvc.xml,这里配置来进行读取--&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!--  服务器启动过程中，帮我们去创建前端控制器，而不是在第一次访问的时候创建--&gt;</span><br><span class="line">       &lt;!--相当于提前去创建前端控制器--&gt;</span><br><span class="line">       &lt;load-on-startup&gt;<span class="number">1</span>&lt;/load-on-startup&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">       &lt;!--    路径使用.可以拦截所有请求，但不包括jsp 静态资源 控制器的访问都会拦截--&gt;</span><br><span class="line">         这里这种方式会将静态资源拦截，在下面会有处理办法</span><br><span class="line">       &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">       / 【三种方式：/  <span class="comment">/* *.xxx】</span></span><br><span class="line"><span class="comment">       /  拦截所有请求不包含.jsp----&gt; 处理静态资源放行</span></span><br><span class="line"><span class="comment">       /*  拦截所有请求</span></span><br><span class="line"><span class="comment">       *.xxx   使用restful风格的请求会有影响</span></span><br><span class="line"><span class="comment">   &lt;/servlet-mapping&gt;</span></span><br></pre></td></tr></table></figure><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在进行配置的时候，发现报错 web.xml报错 org.springframework.web.servlet.DispatcherServlet&#x27; is not assignable to javax.servlet.Servlet</span><br><span class="line"></span><br><span class="line">解决ProjectStructure-Dependencies-右上角绿色小加号-添加Tomcat的包即可</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/ef8efbee96b7c5929bcc4b8c35bf7d00-14eb8f.png" alt="image-20210330234424862"></p><h2 id="开发Controller"><a href="#开发Controller" class="headerlink" title="开发Controller"></a>开发Controller</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  普通类 + @Controller</span><br><span class="line">  普通方法 + @RequestMapping(&quot;访问路径&quot;)  ----&gt; 可以通过访问路径访问</span><br><span class="line">  </span><br><span class="line">   * 控制器的开发：</span><br><span class="line">* 1.加注解@Controller</span><br><span class="line">* 2.编写提供请求响应的方法，需要给访问路径  @RequestMapping(value=&quot;&quot;)</span><br></pre></td></tr></table></figure><h2 id="Controller中添加的注解谁来扫描"><a href="#Controller中添加的注解谁来扫描" class="headerlink" title="Controller中添加的注解谁来扫描"></a>Controller中添加的注解谁来扫描</h2><p>  在resources中创建springmvc.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:mvc=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;!--开启注解扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;Controller&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启mcv的注解驱动--&gt;</span><br><span class="line">    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="springmvc-xml文件谁来读"><a href="#springmvc-xml文件谁来读" class="headerlink" title="springmvc.xml文件谁来读"></a>springmvc.xml文件谁来读</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前端控制器来加载，配置初始化参数来创建，上面已经写过</span><br><span class="line"> &lt;!--         前端控制器需要读取springmvc.xml,这里配置来进行读取--&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;!--  服务器启动过程中，帮我们去创建前端控制器，而不是在第一次访问的时候创建--&gt;</span><br><span class="line">        &lt;!--相当于提前去创建前端控制器--&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br></pre></td></tr></table></figure><h2 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行配置中 添加tomcat</span><br><span class="line">             发布项目</span><br><span class="line">             修改项目访问路径 【注意在deployment模块中去修改--修改之后server中完整路径也跟着变化】</span><br><span class="line">             确定之后退出：services面板中或者右上部门能看到Tomcat的图标 run</span><br><span class="line"></span><br><span class="line">   造成端口占用的场景：</span><br><span class="line">      服务器没有关闭的情况下直接关闭了idea</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525205435596-698413.png" alt="image-20230525205435596"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525205459577-d8f5f9.png" alt="image-20230525205459577"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525205614121-f92c4b.png" alt="image-20230525205614121"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525205702306-cf65c8.png" alt="image-20230525205702306"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230525205727163-689c81.png" alt="image-20230525205727163"></p><h1 id="SpringMVC使用"><a href="#SpringMVC使用" class="headerlink" title="SpringMVC使用"></a>SpringMVC使用</h1><h2 id="控制层返回JSON数据"><a href="#控制层返回JSON数据" class="headerlink" title="控制层返回JSON数据"></a>控制层返回JSON数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于控制层的一个方法来说，默认的返回，是一个返回地址，相当于要进行跳转</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/hi&quot;)</span><br><span class="line"> public String sayHi() &#123;</span><br><span class="line">     System.out.println(&quot;你好！！&quot;);</span><br><span class="line">     // 返回的字符串，其实是我们访问之后的转发路径，相当于进行跳转，</span><br><span class="line">     return &quot;/WEB-INF/success.jsp&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">那么如果要将返回值转化为JSON数据传递给前端的话，就需要添加一个注解<span class="meta">@ResponseBody</span> </span><br><span class="line"></span><br><span class="line">转化为JSON数据这个事情需要第三方jar包操作jackson 依赖 jackson-core   jackson-databind   jackson-annotations</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">转化为JSON数据第三方jar包操作jackson 依赖 jackson-core   jackson-databind   jackson-annotations</span><br><span class="line">&lt;!--        添加jsckson--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.13</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.13</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.13</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><h3 id="端口占用问题"><a href="#端口占用问题" class="headerlink" title="端口占用问题"></a>端口占用问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">命令行： netstat -ano | findstr 端口</span><br><span class="line">如果有占用的进程id 在任务管理器中找到相同pid关闭即可</span><br></pre></td></tr></table></figure><h3 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="RequestParam注解"></a>RequestParam注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestParam注解加上后，必须要进行传参，而且可以更改传递名称</span><br></pre></td></tr></table></figure><h3 id="日期参数的传递以及绑定"><a href="#日期参数的传递以及绑定" class="headerlink" title="日期参数的传递以及绑定"></a>日期参数的传递以及绑定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于日期数据，从前端获取是一个字符串，没办法进行绑定，所以可以用一个注解进行绑定</span><br><span class="line">进行日期转换</span><br><span class="line"><span class="comment">//    需要配置pattern，相当于说明传来的字符串是什么格式</span></span><br><span class="line"><span class="comment">//    2023-01-01  yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于日期传递</span><br><span class="line">对于返回给前端的日期，是一个时间戳，到<span class="number">1970</span>年的毫秒数，所以为了解决这个问题,也去加一个注解</span><br><span class="line"></span><br><span class="line">需要添加依赖 上面有，将返回值转化为JSON格式的字符串转递给前端</span><br><span class="line">jackson-core</span><br><span class="line">   jackson-databind</span><br><span class="line">   jackson-annotations</span><br><span class="line"></span><br><span class="line"><span class="comment">//  timezone  设置时区，固定的，返回前端成为json的参数</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="访问静态资源"><a href="#访问静态资源" class="headerlink" title="访问静态资源"></a>访问静态资源</h3><p>访问不到静态资源报错     net::ERR_ABORTED 404</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于     &lt;servlet-mapping&gt;里面的  &lt;url-pattern&gt;/&lt;/url-pattern&gt;这个配置，会将静态资源（导入的Jquery,图片等等）进行拦截，从而覆盖了让DefaultServlet，为了解决这个问题</span><br><span class="line"></span><br><span class="line">去springmvc.xml里面配置：</span><br><span class="line"> &lt;!-- 静态资源放行</span><br><span class="line">        让DefaultServlet该干嘛干嘛，本来就是处理静态资源访问的</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;</span><br></pre></td></tr></table></figure><h3 id="Post中文乱码处理"><a href="#Post中文乱码处理" class="headerlink" title="Post中文乱码处理"></a>Post中文乱码处理</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在Post在进行数据传输的时候，会出现中文乱码的情况，而Servlet，可以使用request..Encodeing(&quot;UFT-8&quot;)解决乱码,相当于每次请求都要进行这样的设置，那么就可以使用过滤器来进行处理，用自定义过滤器每次自动进行设置</span><br><span class="line"></span><br><span class="line">在web.xml里面设置如下：</span><br><span class="line"><span class="comment">&lt;!--    post请求的中文乱码问题</span></span><br><span class="line"><span class="comment">            本质上Servlet中，用这个request.Encodeing(&quot;UFT-8&quot;)解决乱码</span></span><br><span class="line"><span class="comment">            可以将这个乱码处理放入过滤器中</span></span><br><span class="line"><span class="comment">            可以自定义过滤器</span></span><br><span class="line"><span class="comment">            Springmvc以及编写好了一个处理乱码的Filter</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="SpringMVC和mybatis-基本-整合"><a href="#SpringMVC和mybatis-基本-整合" class="headerlink" title="SpringMVC和mybatis(基本)整合"></a>SpringMVC和mybatis(基本)整合</h1><h2 id="导入srpingMVC依赖"><a href="#导入srpingMVC依赖" class="headerlink" title="导入srpingMVC依赖"></a>导入srpingMVC依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--    SpringMVC核心包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--    Spring对web项目的支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Springmvc配置文件"><a href="#Springmvc配置文件" class="headerlink" title="Springmvc配置文件"></a>Springmvc配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其实 Springmvc配置文件和spring配置文件一样，但是spring配置文件是用来管理mybatis整合来完成Service层的功能，事务处理，SpringMVC里面配置的是静态资源处理以及一些Controller包的扫描</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置前端控制器"><a href="#配置前端控制器" class="headerlink" title="配置前端控制器"></a>配置前端控制器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">在web.xml文件里面进行配置</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    前端控制器的概念是一个前段对后端进行一个请求，后端一个中央进行控制，中央来决定这个请求去访问那个方法，这个中央就叫前端控制器</span></span><br><span class="line"><span class="comment">    配置Servlet 前端控制器</span></span><br><span class="line"><span class="comment">      前端控制器需要读取springmvc.xml</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        通过名称将两个连接起来，和下面的servlet-mapping--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--         前端控制器需要读取springmvc.xml,这里配置来进行读取--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmcv.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  服务器启动过程中，帮我们去创建前端控制器，而不是在第一次访问的时候创建--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--相当于提前去创建前端控制器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    路径使用.可以拦截所有请求，但不包括jsp 静态资源 控制器的访问都会拦截--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置监听器来读取Spring-xml-管理mybatis和service服务层"><a href="#配置监听器来读取Spring-xml-管理mybatis和service服务层" class="headerlink" title="配置监听器来读取Spring.xml(管理mybatis和service服务层)"></a>配置监听器来读取Spring.xml(管理mybatis和service服务层)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">注意web.xml对文件的先后顺序有一个要求</span><br><span class="line"></span><br><span class="line">在web.xml来配置下面的一个监听器，来去读取spring.xml文件，</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方案1：独立容器方案，Spring和SpringMVC都有自己配置文件，实现责任分离 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1.1 Spring容器初始化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">全局的初始化参数</span><br><span class="line">    <span class="comment">&lt;!-- 1.1 Spring容器初始化，去读取 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="解决post中文乱码"><a href="#解决post中文乱码" class="headerlink" title="解决post中文乱码"></a>解决post中文乱码</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    post请求的中文乱码问题</span></span><br><span class="line"><span class="comment">        本质上Servlet中，用这个request.Encodeing(&quot;UFT-8&quot;)解决乱码</span></span><br><span class="line"><span class="comment">        可以将这个乱码处理放入过滤器中</span></span><br><span class="line"><span class="comment">        可以自定义过滤器</span></span><br><span class="line"><span class="comment">        Springmvc以及编写好了一个处理乱码的Filter</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置SpringMVC文件"><a href="#配置SpringMVC文件" class="headerlink" title="配置SpringMVC文件"></a>配置SpringMVC文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启注解扫描，去扫描MCV包--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--开启mcv的注解驱动--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 静态资源放行</span></span><br><span class="line"><span class="comment">     让DefaultServlet该干嘛干嘛，本来就是处理静态资源访问的</span></span><br><span class="line"><span class="comment">  net::ERR_ABORTED 404</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:default-servlet-handler</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开发Controller-1"><a href="#开发Controller-1" class="headerlink" title="开发Controller"></a>开发Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于所有返回值都需要返回JSON的，所以直接使用RestController注解</span><br><span class="line"><span class="comment">//@Controller + @ResponseBody  由于每一个方法都返回JSON。可以在类上直接@RestController，相当于每个方法上都加了@ResponseBody</span></span><br><span class="line">    </span><br><span class="line"> 自动装入Service类</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于要转化为JSON数据，所以需要有包转化为JSON数据，导入JackSon依赖</span><br><span class="line">    &lt;!--        添加jsckson--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.13</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.13</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.13</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="部署Tomcat"><a href="#部署Tomcat" class="headerlink" title="部署Tomcat"></a>部署Tomcat</h2><p>上面有详解，看上面文档</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">文件上传三要素：</span><br><span class="line">(<span class="number">1</span>) 表单的提交的方式必须是POST请求（get请求对提交的数据）</span><br><span class="line">(<span class="number">2</span>) 表单中必须有一个文件上传项:&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>/&gt;，文件上传项必须有name属性和值；</span><br><span class="line">(<span class="number">3</span>) 表单的enctype属性的值必须是multipart/form-data</span><br></pre></td></tr></table></figure><h2 id="引入依赖-5"><a href="#引入依赖-5" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        加入文件上传的依赖--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="设置表单"><a href="#设置表单" class="headerlink" title="设置表单"></a>设置表单</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        文件上传</span></span><br><span class="line"><span class="comment">    表单 首先必须得是post请求</span></span><br><span class="line"><span class="comment">  enctype属性默认是application/x-www-form-urlencoded，根据input和value组成一个键值对，拼接到地址栏后面</span></span><br><span class="line"><span class="comment">   multipart/form-data --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upFile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置上传解析器"><a href="#配置上传解析器" class="headerlink" title="配置上传解析器"></a>配置上传解析器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">上传解析器是，上传上去一个文件的话，SpringMVC会直接把这个文件封装成一个对象的形式，不需要从请求对象里面再一个个获取了，所以配置类型</span><br><span class="line"></span><br><span class="line">配置在springMVC.xml里面，</span><br><span class="line"><span class="comment">&lt;!--    文件解析器。将文件转化为一个对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文件上传 ，这里面的id值不可以随便写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置上传文件的最大尺寸为1MB --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- spring el写法：1MB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>#&#123;1024*1024&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 效果同上 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Controller写"><a href="#Controller写" class="headerlink" title="Controller写"></a>Controller写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MultipartFile  upFile这个名字，要和前端定义的  &lt;input type=&quot;file&quot; name=&quot;upFile&quot;&gt;一致</span></span><br><span class="line"><span class="comment">//HttpServletRequest 是用来获取输出流路径</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile upFile, HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line">     System.out.println(upFile.isEmpty());<span class="comment">//是否为空</span></span><br><span class="line">        System.out.println(upFile.getOriginalFilename());<span class="comment">//原来文件名</span></span><br><span class="line">        System.out.println(upFile.getSize());<span class="comment">//大小</span></span><br><span class="line">        System.out.println(upFile.getContentType());<span class="comment">//文件类型</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 上传的本质是复制，</span></span><br><span class="line"><span class="comment">        * 从哪里复制到哪里</span></span><br><span class="line"><span class="comment">        * 从upFile.getInputStream() 复制到 服务器当前项目找一个目录，放到这个目录里面</span></span><br><span class="line"><span class="comment">        * 这样目录里面会有一个新文件，这个新文件和旧文件会同名（扩展名）</span></span><br><span class="line"><span class="comment">        * 输入流中的内容，会写到对应的输出流  --需要request对象，引入依赖</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="得到输入流"><a href="#得到输入流" class="headerlink" title="得到输入流"></a>得到输入流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到文件的输入流</span></span><br><span class="line">         <span class="type">InputStream</span> <span class="variable">from</span> <span class="operator">=</span> upFile.getInputStream();</span><br></pre></td></tr></table></figure><h3 id="修改名称"><a href="#修改名称" class="headerlink" title="修改名称"></a>修改名称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于有一些文件会因为名字相同内容不同出现这种问题，所以为了解决这种问题，对文件进行重新命名，加上UUID，UUID生成一个独一无二的ID</span><br><span class="line">    <span class="comment">//原来的名字可能存在不同的文件，但是同名的，所以对原来的文件名进行修改</span></span><br><span class="line">            <span class="comment">//加上UUID+abc.jpeg</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> upFile.getOriginalFilename();</span><br><span class="line">            fileName = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).concat(fileName);</span><br></pre></td></tr></table></figure><h3 id="得到输出流地址"><a href="#得到输出流地址" class="headerlink" title="得到输出流地址"></a>得到输出流地址</h3><p>引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        引入servlet的api--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;!--源码包是要的，但是发布运行的时候，不会带这个包--&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在webApp中创建一个文件夹，webapp中的内容都会发布到服务器，得到updir的路径,</span></span><br><span class="line">          <span class="comment">//引入依赖</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> httpServletRequest.getServletContext().getRealPath(<span class="string">&quot;/upDir&quot;</span>);</span><br><span class="line">          <span class="comment">//目标文件的构建</span></span><br><span class="line">          <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath, fileName);</span><br></pre></td></tr></table></figure><h3 id="构建文件"><a href="#构建文件" class="headerlink" title="构建文件"></a>构建文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存中对目标文件的构建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath, fileName);</span><br></pre></td></tr></table></figure><h3 id="判断父路径是否存在"><a href="#判断父路径是否存在" class="headerlink" title="判断父路径是否存在"></a>判断父路径是否存在</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断父文件夹是否存在，</span></span><br><span class="line">           <span class="keyword">if</span> (!targetFile.getParentFile().exists()) &#123;</span><br><span class="line">           <span class="comment">// mkdirs，创建多个文件夹</span></span><br><span class="line">               targetFile.getParentFile().mkdirs();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h3 id="进行写入"><a href="#进行写入" class="headerlink" title="进行写入"></a>进行写入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标文件关联输出流，不存在的情况下，输出流会创建</span></span><br><span class="line">          <span class="type">OutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile);</span><br><span class="line">          IOUtils.copy(from, to);</span><br></pre></td></tr></table></figure><h3 id="完整Controller"><a href="#完整Controller" class="headerlink" title="完整Controller"></a>完整Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/up&quot;)</span></span><br><span class="line"><span class="comment">//  MultipartFile  upFile这个名字，要和前端定义的  &lt;input type=&quot;file&quot; name=&quot;upFile&quot;&gt;一致</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile upFile, HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(upFile.isEmpty());<span class="comment">//是否为空</span></span><br><span class="line">        System.out.println(upFile.getOriginalFilename());<span class="comment">//原来文件名</span></span><br><span class="line">        System.out.println(upFile.getSize());<span class="comment">//大小</span></span><br><span class="line">        System.out.println(upFile.getContentType());<span class="comment">//文件类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上传的本质是复制，</span></span><br><span class="line"><span class="comment">         * 从哪里复制到哪里</span></span><br><span class="line"><span class="comment">         * 从upFile.getInputStream() 复制到 服务器当前项目找一个目录，放到这个目录里面</span></span><br><span class="line"><span class="comment">         * 这样目录里面会有一个新文件，这个新文件和旧文件会同名（扩展名）</span></span><br><span class="line"><span class="comment">         * 输入流中的内容，会写到对应的输出流  --需要request对象，引入依赖</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到文件的输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">from</span> <span class="operator">=</span> upFile.getInputStream();</span><br><span class="line">            <span class="comment">//原来的名字可能存在不同的文件，但是同名的，所以对原来的文件名进行修改</span></span><br><span class="line">            <span class="comment">//加上UUID+abc.jpeg</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> upFile.getOriginalFilename();</span><br><span class="line">            fileName = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).concat(fileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在webApp中创建一个文件夹，webapp中的内容都会发布到服务器，得到updir的路径，</span></span><br><span class="line">            <span class="comment">//需要使用request对象 引入servlet-api的依赖</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> httpServletRequest.getServletContext().getRealPath(<span class="string">&quot;/upDir&quot;</span>);</span><br><span class="line">            <span class="comment">//内存中对目标文件的构建</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath, fileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断父文件夹是否存在，</span></span><br><span class="line">            <span class="keyword">if</span> (!targetFile.getParentFile().exists()) &#123;</span><br><span class="line">            <span class="comment">// mkdirs，创建多个文件夹</span></span><br><span class="line">                targetFile.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//目标文件关联输出流，不存在的情况下，输出流会创建</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile);</span><br><span class="line">            IOUtils.copy(from, to);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于文件复制地址，可以用realpath查看，可以发现是在target，是在发布目录，而不会直接在原来的文件下，由于这个地址，放置在target下，如果服务器清空了，关闭了，那么文件就丢了</span><br><span class="line">所以一般会有专门的文件服务器进行部署，</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring两大技术</title>
      <link href="/posts/61218.html"/>
      <url>/posts/61218.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IOC   IOC（Inverse of control - 控制反转）：将创建对象的权利和依赖关系维护（字段赋值）交给Spring容器（不再使用以前new关键字创建对象）。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转；</span><br><span class="line"></span><br><span class="line">简单来说就是帮我们创建对象以及处理对象之间的关系</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AOP切面技术</span><br><span class="line">AOP（Aspect Oriented Programming）：将相同的逻辑抽取出来，即将业务逻辑从应用服务中分离出来。然后以拦截的方式作用在一个方法的不同位置。例如日志，事务的处理；</span><br><span class="line">简单来说就是处理相同的事务操作它抽取出来</span><br></pre></td></tr></table></figure><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="使用Spring-在maven结构里面"><a href="#使用Spring-在maven结构里面" class="headerlink" title="使用Spring 在maven结构里面"></a>使用Spring 在maven结构里面</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面是一个约束，schema约束--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    Spring IOC用来帮我们创建对象以及管理对象关系，这里先创建对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用来创建对象，申明创建的对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id 创建对象，class 创建对象的权限命名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取创建的对象"><a href="#获取创建的对象" class="headerlink" title="获取创建的对象"></a>获取创建的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//创建一个spring容器，里面存放的创建的对象</span></span><br><span class="line"><span class="comment">//通过读取类路径下的配置文件来进行构建的，参数是配置文件的全限定名（根据函数名）</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器构建完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的参数是xml定义 bean对象的的id值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">birthday</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在获取的时候，也可以传入一个字节码文件类型进行获取</span></span><br><span class="line"> <span class="comment">//UserController bean = applicationContext.getBean(UserController.class);</span></span><br><span class="line">        System.out.println(birthday);</span><br></pre></td></tr></table></figure><h2 id="Spring配置细节"><a href="#Spring配置细节" class="headerlink" title="Spring配置细节"></a>Spring配置细节</h2><h3 id="Bean对象的作用域"><a href="#Bean对象的作用域" class="headerlink" title="Bean对象的作用域"></a>Bean对象的作用域</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">对于创建注册元素，通过Bean元素中的scope属性指定：</span><br><span class="line">singleton：默认值，单例</span><br><span class="line">prototype：多例</span><br><span class="line"></span><br><span class="line">单例</span><br><span class="line"><span class="comment">&lt;!--默认是单例模式进行创建--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单例的构造创建实在容器构建完成前进行创建，即容器创建完成单例模式构建成功了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> 多例：   </span><br><span class="line">    <span class="comment">&lt;!--创建一个非单例的模式,获取一次就创建一个对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非单例模式实在容器进行调用的时候进行创建，获取一个创建一个，没获取就不会创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean对象的懒加载"><a href="#Bean对象的懒加载" class="headerlink" title="Bean对象的懒加载"></a>Bean对象的懒加载</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--延迟加载--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--还是单例模式，但是不是在构建的时候创建，而是调用的时候创建，即延迟创建懒加载--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.User&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="xml注入"><a href="#xml注入" class="headerlink" title="xml注入"></a>xml注入</h3><h4 id="通过setter方法注入"><a href="#通过setter方法注入" class="headerlink" title="通过setter方法注入"></a>通过setter方法注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--property相当于调用setter方法进行赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;你好啊&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">如果这里是一个对象，那么可以用ref进行引用，如下所示：</span><br><span class="line"> <span class="comment">&lt;!--创建对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;di1.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;di1.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--构造方法进行赋值，必须要把属性原来的构造方法值都选上--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--index选择第几个参数进行赋值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ref是用来引用，如果赋值是一个对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user04&quot;</span> <span class="attr">class</span>=<span class="string">&quot;entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">属性里面有一个对象，但是这个对象没有创建，那么就可以在property里面创建所需要的bean对象进行使用</span><br><span class="line"><span class="comment">&lt;!-- 内部bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hxj._01hello.MyBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;otherBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hxj._01hello.OtherBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--根据名字进行自动装配，--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自动去IOC容器中找与属性名同名的引用的对象，并自动注入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--本质来讲，byName是去寻找Setter后面的单词首字母小写（属性名），然后去IOC容器中去进行寻找--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;di1.UserService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据类型进行自动装配--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--必须确保改类型在IOC容器中只有一个对象；否则报错。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;di1.UserService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">对于自动装配也可以在全局进行配置</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">default-autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span>  </span><br><span class="line">    查看最后一行代码</span><br></pre></td></tr></table></figure><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component   指定把一个对象加入IOC容器</span><br><span class="line">@Resource     属性注入</span><br><span class="line">@Autowired    自动装配</span><br></pre></td></tr></table></figure><h4 id="第一步进行对象注入和属性输入"><a href="#第一步进行对象注入和属性输入" class="headerlink" title="第一步进行对象注入和属性输入"></a>第一步进行对象注入和属性输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象注入上加 @Component</span><br><span class="line">//等同与配置bean id class</span><br><span class="line">//id不写默认是类名首字母小写</span><br><span class="line">//class都用到类上了就是这个类</span><br><span class="line"></span><br><span class="line">属性注入加上@Autowired或者@Resource</span><br></pre></td></tr></table></figure><h4 id="第二步配置扫描包"><a href="#第二步配置扫描包" class="headerlink" title="第二步配置扫描包"></a>第二步配置扫描包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">创建包application.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;要扫描的包名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了区分业务层，数据层，逻辑层，一般用不同的注解，但是它们的作用和 @Component是一样的</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">//和Component功能一致，但是是持久层的</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">//和component功能一致，但是表示业务层</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">//Component和一致，但是表示控制层</span><br></pre></td></tr></table></figure><h4 id="两个注解的对比"><a href="#两个注解的对比" class="headerlink" title="两个注解的对比"></a>两个注解的对比</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@Autowired 默认按照名称,名称找不到类型匹配</span><br><span class="line"></span><br><span class="line">    //  Resource是JDK自带的，默认按照名字匹配【名字对了，类型也必须一致】，然后按照类型匹配</span><br><span class="line">    //  Autowired是spring带的</span><br><span class="line">    //  一般都用Autowired</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关于注解@Autowired和@Resource的匹配方式对比：</span><br><span class="line">     * (1) @Autowired：默认按照类型【子类也可以】匹配，如果有多个类型一样的Bean，按照名字匹配，匹配不上报错</span><br><span class="line">     * (2) @Resource：默认按照名字取匹配，但是类型必须对应</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><h3 id="构建配置类"><a href="#构建配置类" class="headerlink" title="构建配置类"></a>构建配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当要配置的bean类过于复杂，写xml过于繁琐的时候，就可以使用配置类来进行bean对象的声明</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决类里面属性太多</span></span><br><span class="line"><span class="comment">//等同于配置文件，多用于对象的创建比较复杂的情况下</span></span><br><span class="line"><span class="comment">//配置了需要添加相应的注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//等同于Bean标签,对象的注入</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;配置类创建的User对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>用AnnotationConfigApplicationContext来获取注解配置类构成的spring容器     </span><br><span class="line"><span class="number">2</span> 将配置类注册在上面</span><br><span class="line"><span class="number">3</span>刷新</span><br><span class="line"><span class="number">4</span>获取对象</span><br><span class="line">    </span><br><span class="line"><span class="comment">//用注解来进行获取创建spring容器</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">annotationConfigApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        <span class="comment">//注册AppConfig</span></span><br><span class="line">        annotationConfigApplicationContext.register(AppConfig.class);</span><br><span class="line">        <span class="comment">//刷新一下</span></span><br><span class="line">        annotationConfigApplicationContext.refresh();</span><br><span class="line">        <span class="comment">//可以获取配置类中创建的对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">bean</span> <span class="operator">=</span> annotationConfigApplicationContext.getBean(User.class);</span><br><span class="line">        System.out.println(bean);</span><br></pre></td></tr></table></figure><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先要清楚一点，共同的事务我们可以叫关注点代码</span><br><span class="line">自己的业务逻辑叫业务代码</span><br><span class="line"></span><br><span class="line">代理实际上就是把关注点代码和业务代码分离开来，关注点代码交给代理来做</span><br></pre></td></tr></table></figure><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">相当于把关注点代码和业务代码分离开，观察下面是一个简单的静态代理，在静态代理里面实现了目标类里面的所有方法，然后代理类实现关注点代码，调用业务代码，从而实现代理</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理的本质</span></span><br><span class="line"><span class="comment"> *  本质是接口代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1代理类（StudentServiceProxy）需要实现和 目标类（StudentServiceImp）相同的接口</span></span><br><span class="line"><span class="comment"> *  2需要目标类的对象来实现核心业务，代理类中就需要维护目标类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标类的对象</span></span><br><span class="line">    StudentService  studentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentServiceProxy</span><span class="params">(StudentService studentService)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.studentService=studentService;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//代理方法，其中的业务又自己实现，其他事务由代理实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);<span class="comment">//关注点代码</span></span><br><span class="line">        studentService.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务&quot;</span>);<span class="comment">//关注点代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);<span class="comment">//关注点代码</span></span><br><span class="line">        studentService.update();</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务&quot;</span>);<span class="comment">//关注点代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过反射工厂，来进行代理对象的创建</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个动态代理工厂，</span></span><br><span class="line"><span class="comment"> * 可以通过反射的方式，为任何接口创建代理对象</span></span><br><span class="line"><span class="comment"> * 也需要根据目标类来进行创建</span></span><br><span class="line"><span class="comment"> * 需要维护目标类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//定义目标类</span></span><br><span class="line">    Object target;</span><br><span class="line">    <span class="comment">//设置目标类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理对象,并且返回</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">//目标类的类加载器，有了这个参数就知道这个类是谁加载的</span></span><br><span class="line">                target.getClass().getInterfaces(),<span class="comment">//目标类所实现的接口</span></span><br><span class="line">                <span class="comment">//进行处理</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//给核心业务前后加上代理内容</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;开启事务。。。&quot;</span>);</span><br><span class="line">                        <span class="comment">//method就是核心业务，核心方法</span></span><br><span class="line">                        <span class="comment">//使用反射的方式执行这个方法  传递一个对象和参数</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;提交事务....&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建目标类的对象</span></span><br><span class="line">     <span class="type">StudentService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentServiceImp</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建工厂对象</span></span><br><span class="line">     <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//告诉工厂目标类对象是谁</span></span><br><span class="line">     proxyFactory.setTarget(target);</span><br><span class="line"></span><br><span class="line">     <span class="type">StudentService</span> <span class="variable">proxy</span> <span class="operator">=</span> (StudentService)proxyFactory.getProxy();</span><br><span class="line">     proxy.add();</span><br></pre></td></tr></table></figure><p>值得注意的是，这里的代理使用的是JDK代理，它只能为实现接口的实体类进行代理，对于没实现的，不可以</p><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设置工厂</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有实现接口的目标类，只能使用cglib创建代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">                System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//为目标类创建一个代理子类对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OrderService</span> <span class="variable">orderService</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>();</span><br><span class="line">       <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line"></span><br><span class="line">       proxyFactory.setTarget(orderService);</span><br><span class="line"></span><br><span class="line">       <span class="type">OrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (OrderService)proxyFactory.getProxy();</span><br><span class="line">       proxy.add();</span><br></pre></td></tr></table></figure><h2 id="Spring的AOP代理"><a href="#Spring的AOP代理" class="headerlink" title="Spring的AOP代理"></a>Spring的AOP代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是通过切面的方法实现，相当于将关注点代码写到一个函数里面，然后嵌套业务代码，本质上是动态代理，但是如果没有实现接口进行代理，那么就是cglib代理，spring相当于将两个代理进行了整合</span><br></pre></td></tr></table></figure><h3 id="xml进行配置代理"><a href="#xml进行配置代理" class="headerlink" title="xml进行配置代理"></a>xml进行配置代理</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        Aop配置相关依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="构建切面类"><a href="#构建切面类" class="headerlink" title="构建切面类"></a>构建切面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类中。</span></span><br><span class="line"><span class="comment"> *  集合了所有的关注点代码</span></span><br><span class="line"><span class="comment"> 相当于把关注点代码拿出来，要放在业务代码哪里需要代理进行配置，业务代码分别写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 创建目标类的对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aopxml.BookServiceImp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    创建切面类对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aop&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aopxml.Aop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    进行切面的配置，由spring AOP帮助我们创建代理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    切入点表达式，那些类的那些方法来配置切面类的方法--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &quot;execution(返回值  包名.类名.方法（参数)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* aopxml.*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--        切面类配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;aop&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--说明白切面中的方法，谁是前置，谁是后置--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- method 放置在什么位置，pointcut-ref 切入点表达式是什么--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="调用-2"><a href="#调用-2" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其实通过上面的配置，在IOC容器里面配置好的以及有切面方法了，所以直接调用就可以</span><br><span class="line"></span><br><span class="line"> ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application_aopxml.xml&quot;);</span><br><span class="line">        BookService bean = applicationContext.getBean(BookService.class);</span><br><span class="line">        bean.add();</span><br></pre></td></tr></table></figure><h3 id="注解进行配置代理"><a href="#注解进行配置代理" class="headerlink" title="注解进行配置代理"></a>注解进行配置代理</h3><h4 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        Aop配置相关依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.9</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;aopanno&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启aop注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//注册到IOC容器里面</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//指定为一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个函数没有用，相当于设置切入点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* aopxml.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将业务代码也注册到IOC容器里面就可以用了</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application_aopanno.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(BookService.class);</span><br><span class="line">        bean.add();</span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">除了指定的before after方法外，还有其他方法如下所示，但是这四个可能会出现顺序问题，要用几个配合，用环绕通知</span><br><span class="line"></span><br><span class="line">&lt;!--方法返回后通知--&gt;</span><br><span class="line">            &lt;aop:after-returning method=<span class="string">&quot;afterReturn&quot;</span> pointcut-ref=<span class="string">&quot;pt&quot;</span>&gt;&lt;/aop:after-returning&gt;</span><br><span class="line">            &lt;!--方法抛出错误异常--&gt;</span><br><span class="line">            &lt;aop:after-throwing method=<span class="string">&quot;afterThrowing&quot;</span> pointcut-ref=<span class="string">&quot;pt&quot;</span>&gt;&lt;/aop:after-throwing&gt;</span><br><span class="line">                </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">环绕通知一般不和四个混用</span><br><span class="line">环绕通知 </span><br><span class="line">    &lt;aop:around method=<span class="string">&quot;arount&quot;</span> pointcut-ref=<span class="string">&quot;pt&quot;</span>&gt;&lt;/aop:around&gt;</span><br><span class="line">        </span><br><span class="line">关注点代码：</span><br><span class="line">        </span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  环绕通知</span></span><br><span class="line"><span class="comment">     *   可以写异常处理</span></span><br><span class="line"><span class="comment">     * 传入参数 ProceedingJoinPoint 一个切入点</span></span><br><span class="line"><span class="comment">     * 返回值 Object 这就是业务方法执行后的一个返回值</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">arount</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务方法执行</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;回滚事务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="案例：日志处理"><a href="#案例：日志处理" class="headerlink" title="案例：日志处理"></a>案例：日志处理</h2><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元注解</span></span><br><span class="line"><span class="comment"> *   <span class="doctag">@Target</span>(&#123;ElementType.METHOD&#125;)         应用的范围，可以应用在类上、方法、属性，为了设置在哪里加</span></span><br><span class="line"><span class="comment"> *   <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME)  存在的生命周期</span></span><br><span class="line"><span class="comment">*<span class="doctag">@Documented</span> 提取成文档是否有注解，加上会有这个注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">module</span><span class="params">()</span>;  <span class="comment">//操作的类型</span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">operator</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;  <span class="comment">//操作名称</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切面类-1"><a href="#切面类-1" class="headerlink" title="切面类"></a>切面类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.neusoft.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.neusoft.annotation.LogAnnotation;</span><br><span class="line"><span class="keyword">import</span> cn.neusoft.domain.MyLog;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.java.Log;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.neusoft.annotation.LogAnnotation)&quot;)</span></span><br><span class="line"><span class="comment">//找存在这个注解的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt() &amp;&amp; execution(* cn.neusoft.controller.*Controller.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">log</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取切入点所在的方法</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取操作，获取到注解信息</span></span><br><span class="line">        <span class="type">LogAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(LogAnnotation.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">MyLog</span> <span class="variable">myLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLog</span>();</span><br><span class="line">        myLog.setName(annotation.operator());</span><br><span class="line">        myLog.setType(annotation.<span class="keyword">module</span>());</span><br><span class="line">        myLog.setUid(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//业务方法执行</span></span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            log.error(throwable.getMessage());</span><br><span class="line">            myLog.setError(throwable.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis()-startTime;</span><br><span class="line">            myLog.setOperationTime(time);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//日志输出</span></span><br><span class="line">            log.info(<span class="string">&quot;执行&quot;</span>+myLog.getName()+<span class="string">&quot;操作，耗时：&quot;</span>+ myLog.getOperationTime()+<span class="string">&quot;毫秒，用户id=&quot;</span>+ myLog.getUid()</span><br><span class="line">            +<span class="string">&quot;, 操作类型：&quot;</span>+ myLog.getType()+<span class="string">&quot;,错误：&quot;</span>+myLog.getError());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存数据库</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//存文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LogAnnotation(module = 1,operator = &quot;添加学生&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加学生&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LogAnnotation(module = 2,operator = &quot;修改学生&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span><span class="comment">//这个注解是否定掉lombok里面的自动生成的Equals方法和HashCode方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//日志名称</span></span><br><span class="line">    <span class="keyword">private</span> Long operationTime; <span class="comment">//操作时长</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;  <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> Integer type; <span class="comment">//操作类型</span></span><br><span class="line">    <span class="keyword">private</span> String error; <span class="comment">//失败的原因</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件application-xml"><a href="#配置文件application-xml" class="headerlink" title="配置文件application.xml"></a>配置文件application.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.neusoft&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启aop注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件log4j-properties"><a href="#配置文件log4j-properties" class="headerlink" title="配置文件log4j.properties"></a>配置文件log4j.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#5.控制台输出+自定义布局</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG,my</span></span><br><span class="line"><span class="comment">#指定输出器</span></span><br><span class="line"><span class="attr">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="comment">#指定布局器(自定义布局)</span></span><br><span class="line"><span class="comment">#指定布局为自定义布局</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">#指定在自定义布局的格式，%d -- 表示当前系统时间，%t -- 执行该业务的线程名称，%p -- 日记器的级别，-5 -- 5表示输出字符的个数，符号表示右对齐</span></span><br><span class="line"><span class="comment">#%c -- 表示指定业务所在的类的完全限定名(包名.类名)，%m -- 输出额外信息，%n -- 表示换行</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout.ConversionPattern</span>=<span class="string">%-5p - %m%n</span></span><br><span class="line"><span class="comment">#设置package（可以是自定义的包也可以是api的包）输出级别，#trace - 可以看见sql查询的信息</span></span><br><span class="line"><span class="attr">log4j.logger.cn.neusoft</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/posts/33757.html"/>
      <url>/posts/33757.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建一个简单的Maven项目</p><h2 id="继承父工程"><a href="#继承父工程" class="headerlink" title="继承父工程"></a>继承父工程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--继承一个父项目--&gt;</span><br><span class="line">   &lt;!--</span><br><span class="line">SpringBoot 父节点依赖,引入这个之后相关的引入就不需要添加version配置，SpringBoot会自动选择最合适的版本进行添加。</span><br><span class="line"> --&gt;</span><br><span class="line">   &lt;parent&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">2.0</span><span class="number">.4</span>.RELEASE&lt;/version&gt;</span><br><span class="line">   &lt;/parent&gt;</span><br></pre></td></tr></table></figure><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加spring-boot-starter-web依赖</span><br><span class="line">       启动器，里面很多jar包,jackson,tomcat</span><br><span class="line">       --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意这个类和其他包放在一块，Spring启动类会默认扫描它所在的当前包，</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用SpringBoot的启动类去运行Spring程序</span></span><br><span class="line">        SpringApplication.run(HelloApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写Controller和Service等方法"><a href="#写Controller和Service等方法" class="headerlink" title="写Controller和Service等方法"></a>写Controller和Service等方法</h2><h1 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringBoot使用一个全局的配置文件，默认放在src/main/resources（可以改但是需要配置），配置文件名是固定的：</span><br><span class="line"></span><br><span class="line">application.properties：传统方式，属性文件</span><br><span class="line"></span><br><span class="line">application.yml：推荐使用，格式要求严格</span><br><span class="line"></span><br><span class="line">application.yaml：同上</span><br><span class="line"></span><br><span class="line">配置文件的作用：修改SpringBoot自动配置的默认值，SpringBoot在底层都给我们自动配置好；</span><br><span class="line">    </span><br><span class="line">注意：.properties和.yml都可以作为配置文件配置信息。相同的配置.properties说了算，优先级大于.yml</span><br></pre></td></tr></table></figure><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line"><span class="comment">#配置访问路径，</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/dev</span></span><br></pre></td></tr></table></figure><h2 id="Profile多环境配置"><a href="#Profile多环境配置" class="headerlink" title="Profile多环境配置"></a>Profile多环境配置</h2><p>一套代码要在多种环境运行（开发，测试，上线)，所以我们的配置文件要支持多种环境</p><h3 id="配置分环境"><a href="#配置分环境" class="headerlink" title="配置分环境"></a>配置分环境</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于激活，一下有三个环境，要使用哪一个就必须要激活才可以</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    </span><br><span class="line"><span class="string">---</span> <span class="string">//相当于将一个文件分割成另外一个文件</span></span><br><span class="line"><span class="comment">#开发环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="comment">#给这个环境起一个名称    </span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="string">---//相当于将一个文件分割成另外一个文件</span></span><br><span class="line"><span class="comment">#测试环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/test</span></span><br><span class="line"><span class="comment">#给这个环境起一个名称   </span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="string">---//相当于将一个文件分割成另外一个文件</span></span><br><span class="line"><span class="comment">#上线环境</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/pro</span></span><br><span class="line"><span class="comment">#给这个环境起一个名称   </span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">pro</span></span><br></pre></td></tr></table></figure><h3 id="多文件分环境"><a href="#多文件分环境" class="headerlink" title="多文件分环境"></a>多文件分环境</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">如果配置的信息越来越多，将所有配置写到一个配置文件中就不方便维护，而且容易混淆，容易出错。所以我们可以将不同的环境配置信息单独写在一个配置文件中：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">创建三个yml文件</span></span><br><span class="line">   <span class="string">application-dev.yml</span>  <span class="comment">#名称就是dev,-后面相当于多环境后面的名称</span></span><br><span class="line">   <span class="string">application-test.yml</span></span><br><span class="line">   <span class="string">application-pro.yml</span></span><br><span class="line">   </span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">application.yml中来用于激活</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#使用开发环境</span></span><br></pre></td></tr></table></figure><h1 id="SpringBoot进行测试"><a href="#SpringBoot进行测试" class="headerlink" title="SpringBoot进行测试"></a>SpringBoot进行测试</h1><p>SpringBoot也将单元测试进行了整合</p><h2 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--springBoot测试 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行Spring程序</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">//声明当前类是一个SpringBoot的测试类，并加载App，因为App上有自动配置信息</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = HelloApplication.class)</span></span><br><span class="line"><span class="comment">//这是一个Spring测试，要告诉它在哪儿加载Spring配置文件，其实告诉它应用类型就ok，主启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line"><span class="comment">//可以对Controller来进行测试</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    controller controller;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring boot测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot整合mybatis"><a href="#SpringBoot整合mybatis" class="headerlink" title="SpringBoot整合mybatis"></a>SpringBoot整合mybatis</h1><h2 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据库的jar包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">           &lt;!-- SpringBoot2<span class="number">.2</span><span class="number">.5</span>的版本中Mysql是mysql8<span class="number">.0</span>的，需要手动导入<span class="number">8</span>以下的版本。我们电脑中安装的数据库是mysql5.x的，mysql8<span class="number">.0</span>启动包都不一样，所以需要收到导入<span class="number">5.</span>x的版本。避免链接数据库出现问题 --&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">5.1</span><span class="number">.39</span>&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- mybatis与springboot的整合包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br></pre></td></tr></table></figure><h2 id="配置扫描"><a href="#配置扫描" class="headerlink" title="配置扫描"></a>配置扫描</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在启动类上面加上</span><br><span class="line"><span class="comment">//扫描mapper层接口的所在包，为接口创建代理</span></span><br><span class="line"><span class="comment">//这里和以往不一样的地方就是MapperScan的注解，这个是会扫描该包下的接口，生成Mapper的代码对象，代理之前在xml中的配置</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.neusoft.mapper&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置数据库连接信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/neu_soft?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.neusoft.entity</span> <span class="comment">#配置别名，在mapperxml的名称空间使用</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:cn/neusoft/mapper/*Mapper.xml</span> <span class="comment">#映射配置文件。由于存放位置一致，不写也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置日志</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">cn.neusoft:</span> <span class="string">trace</span> <span class="comment">#配置日志</span></span><br></pre></td></tr></table></figure><h2 id="进行开发"><a href="#进行开发" class="headerlink" title="进行开发"></a>进行开发</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行开发即可</span><br></pre></td></tr></table></figure><h1 id="PageHelper分页工具"><a href="#PageHelper分页工具" class="headerlink" title="PageHelper分页工具"></a>PageHelper分页工具</h1><p>在Service层使用</p><h2 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        pageHelper启动类--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//开启分页</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * //原生的写法：1.先查询总页数  2.再根据分页的信息查询当前页的数据</span></span><br><span class="line"><span class="comment">         * //PageHelper的写法：开启分页</span></span><br><span class="line"><span class="comment">         * PageHelper.startPage(当前页,每页显示的条数);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PageHelper.startPage(baseQuery.getPageNow(),baseQuery.getPageSize());</span><br><span class="line">        <span class="comment">//寻找数据，情况模糊查询，得到当页的集合，只需要进行一个模糊查询即可</span></span><br><span class="line">        List&lt;Student&gt; byPage = studentMapper.findByPage(baseQuery);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个分页的实体PageInfo</span></span><br><span class="line">        PageInfo&lt;Student&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(byPage);</span><br><span class="line"></span><br><span class="line">这里已经完成分页了，pageInfo里面保存着分页完成的一些数据</span><br><span class="line">    总的来说，只需要两个参数，一个是当前页，另一个是每页显示的条数，这样就可以完成分页了</span><br></pre></td></tr></table></figure><h1 id="Restful服务"><a href="#Restful服务" class="headerlink" title="Restful服务"></a>Restful服务</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * HTTP动词+路径不能重复</span><br><span class="line"> * PathVariable 请求参数只有一个的情况下，可以直接跟在路径中</span><br><span class="line"> * 请求参数如果是实体对象，都使用JSON的方式来接收  RequestBody注解来进行接收</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">根据不同的方法以及名称区分</span><br><span class="line">获取所有的部门</span><br><span class="line">eg:<span class="meta">@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)</span></span><br></pre></td></tr></table></figure><h2 id="HttpMethod"><a href="#HttpMethod" class="headerlink" title="HttpMethod"></a>HttpMethod</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum HttpMethod &#123;</span><br><span class="line"></span><br><span class="line">GET,  POST, PUT,  DELETE, PATCH , OPTIONS, TRACE,HEAD;</span><br></pre></td></tr></table></figure><p>Post:用于新增</p><p>PUT：用于修改</p><p>patch:通常用于批量操作</p><p>head:HEAD请求只会返回首部的信息，不会返回相应体。通常用于<strong>测试数据是否存在</strong>、当做<strong>心跳检测</strong>等等。</p><p>trace:可以理解成，我们为了看看一条请求在到达服务前数据发生了什么变化。可以使用这个命令，它会在最后一站返回原始信息，这样就可以观察到中间是否修改过请求。(经常会用于跨站攻击，所以有一定的安全隐患)</p><p>options:询问服务器支持的方法，通常用来解决跨域。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有路径后，请求不能重复，http动词+请求路径不重复</span><br></pre></td></tr></table></figure><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在Restful里面，对于一些只需要传递一个参数的，例如传递一个id值，一般是跟在路径后面，但是由于跟在路径后面是动态的，所以需要动态获取，需要使用注解PathVariable来获取</span><br><span class="line"></span><br><span class="line"><span class="comment">//    PathVariable注解表示值在路径里面，上面的&#123;&#125;里面的name，必须和PathVariable里面的名字一样</span></span><br><span class="line">eg:   <span class="comment">//写入地址栏中</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        studentService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请求参数如果是实体对象，都使用JSON的方式来接收  RequestBody注解来进行接收</span><br><span class="line">eg:<span class="keyword">public</span> ResultBean <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Swagger使用"><a href="#Swagger使用" class="headerlink" title="Swagger使用"></a>Swagger使用</h1><h2 id="引入依赖-4"><a href="#引入依赖-4" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--        引入Swagger依赖--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置标签，代表该类是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启Swagger</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">//创建API接口文档</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Docket，可以理解问Docket代表一个文档的构建器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())<span class="comment">//指定api相关的信息</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//对这里进行修改</span></span><br><span class="line">                <span class="comment">//【重要】对外暴露服务的包,以controller的方式暴露,所以就是controller的包.</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.neusoft.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">//什么文档</span></span><br><span class="line">                .title(<span class="string">&quot;学生管理系统&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;学生管理系统接口文档说明&quot;</span>)</span><br><span class="line">                <span class="comment">//联系人，练习方式</span></span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;stuManager&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;stuManager@neusoft.cn&quot;</span>))</span><br><span class="line">                <span class="comment">//版本</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】 RequestHandlerSelectors.basePackage(“cn.neusoft”) 这个包名一定不能错，不然找不到controller，没法生成文档</p><h2 id="Swagger测试"><a href="#Swagger测试" class="headerlink" title="Swagger测试"></a>Swagger测试</h2><p>注意 如果端口号是8080那么不用修改，其他情况都得写端口号</p><p>浏览器访问：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p><p>使用swagger测试controller接口</p><h2 id="Swagger注解"><a href="#Swagger注解" class="headerlink" title="Swagger注解"></a>Swagger注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="meta">@Api(value = &quot;部门的API&quot;,description=&quot;部门相关的CRUD功能&quot;)</span> ：打在Controller对Controller做描述</span><br><span class="line">- <span class="meta">@ApiOperation(value = &quot;通过ID查询&quot; )</span> ：打在方法上，对方法做描述</span><br><span class="line">- <span class="meta">@ApiParam(name=&quot;ID属性&quot;,required = true)</span> ：打在参数前，对参数做描述</span><br></pre></td></tr></table></figure><h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><h2 id="引入依赖-5"><a href="#引入依赖-5" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!--热部署jar--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;scope&gt;true&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>在上栏 构建-&gt;构建项目   即可，不需要重新启动项目</p><p>如果不生效</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230529194705660-5c9426.png" alt="image-20230529194705660"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230529194716890-37ab83.png" alt="image-20230529194716890"></p><h1 id="文件上传服务器"><a href="#文件上传服务器" class="headerlink" title="文件上传服务器"></a>文件上传服务器</h1><h2 id="引入依赖-6"><a href="#引入依赖-6" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--    上传文件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">1.3</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件（可写可不可"><a href="#配置文件（可写可不可" class="headerlink" title="配置文件（可写可不可"></a>配置文件（可写可不可</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#文件上传配置</span><br><span class="line">spring:</span><br><span class="line">  servlet:</span><br><span class="line">    multipart:</span><br><span class="line">      max-file-size: 5MB</span><br><span class="line">      max-request-size: 20MB</span><br></pre></td></tr></table></figure><h2 id="Controller配置"><a href="#Controller配置" class="headerlink" title="Controller配置"></a>Controller配置</h2><p>API寻找</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230529204451175-b86666.png" alt="image-20230529204451175"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230529204506283-40607e.png" alt="image-20230529204506283"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping(value = &quot;/up&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="comment">//  MultipartFile  upFile这个名字，要和前端定义的  &lt;input type=&quot;file&quot; name=&quot;upFile&quot;&gt;一致</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile upFile, HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(upFile.isEmpty());<span class="comment">//是否为空</span></span><br><span class="line">        System.out.println(upFile.getOriginalFilename());<span class="comment">//原来文件名</span></span><br><span class="line">        System.out.println(upFile.getSize());<span class="comment">//大小</span></span><br><span class="line">        System.out.println(upFile.getContentType());<span class="comment">//文件类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> upFile.getOriginalFilename();</span><br><span class="line">        fileName = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).concat(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//怎样将上传的文件传递存储到云服务器 ------下面是API，去复制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造一个带指定 Region 对象的配置类</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(Region.region1());</span><br><span class="line">        cfg.resumableUploadAPIVersion = Configuration.ResumableUploadAPIVersion.V2;<span class="comment">// 指定分片上传版本</span></span><br><span class="line"><span class="comment">//...其他参数参考类注释</span></span><br><span class="line">        <span class="type">UploadManager</span> <span class="variable">uploadManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadManager</span>(cfg);</span><br><span class="line"><span class="comment">//...生成上传凭证，然后准备上传</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">accessKey</span> <span class="operator">=</span> <span class="string">&quot;your access key&quot;</span>;<span class="comment">//公钥</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="string">&quot;your secret key&quot;</span>;<span class="comment">//秘钥</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bucket</span> <span class="operator">=</span> <span class="string">&quot;your bucket name&quot;</span>;<span class="comment">//库名称，存放照片的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认不指定key的情况下，以文件内容的hash值作为文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> fileName;</span><br><span class="line">        <span class="comment">//认证 说明访问的bucket库名称</span></span><br><span class="line">        <span class="type">Auth</span> <span class="variable">auth</span> <span class="operator">=</span> Auth.create(accessKey, secretKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">upToken</span> <span class="operator">=</span> auth.uploadToken(bucket);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用流来定义访问路径</span></span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> uploadManager.put(upFile.getInputStream(), key, upToken, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//解析上传成功的结果</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//只要上传成功，我们就可以通过外连+文件名称就可以访问到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + fileName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ajax上传文件"><a href="#ajax上传文件" class="headerlink" title="ajax上传文件"></a>ajax上传文件</h1><p>注意js版本！！！！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;文件上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;javascript:;&quot;</span> id=<span class="string">&quot;uploadForm&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upFile&quot;</span> id=<span class="string">&quot;upInput&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;img style=<span class="string">&quot;width: 300px&quot;</span> src=<span class="string">&quot;&quot;</span> alt=<span class="string">&quot;现在没有，上传之后就有图了&quot;</span> id=<span class="string">&quot;showContainer&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;js/jquery-1.7.2.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    $(function () &#123;</span><br><span class="line">        <span class="comment">//文件组件上传的变化的监听</span></span><br><span class="line">        $(<span class="string">&quot;#upInput&quot;</span>).change(function () &#123;</span><br><span class="line">        <span class="comment">//构建表单对象</span></span><br><span class="line">            <span class="type">let</span> <span class="variable">formData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormData</span>($(<span class="string">&quot;#uploadForm&quot;</span>).get(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//发送ajax请求</span></span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">                url: <span class="string">&#x27;/up&#x27;</span>,</span><br><span class="line">                data: formData,<span class="comment">//请求参数。表单对象</span></span><br><span class="line">                cache: <span class="literal">false</span>,<span class="comment">//是否使用缓存</span></span><br><span class="line">                processData: <span class="literal">false</span>,<span class="comment">//不用阐述什么类型，拿到表单会自动识别</span></span><br><span class="line">                contentType: <span class="literal">false</span>,</span><br><span class="line">                success: function (resData) &#123;</span><br><span class="line">                    $(<span class="string">&quot;#showContainer&quot;</span>).attr(<span class="string">&quot;src&quot;</span>, resData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="统一异常类型"><a href="#统一异常类型" class="headerlink" title="统一异常类型"></a>统一异常类型</h1><h2 id="统一返回类型"><a href="#统一返回类型" class="headerlink" title="统一返回类型"></a>统一返回类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设置一个统一的返回类型，里面携带成功码，信息，以及数据</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultBean</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功或者错误码  成功200 错误 根据不同的情况，有不同的错误码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//备注信息，对成功或者失败的解释，成功success  错误了根据不同的情况有不同的备注信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="comment">//比如查询所有的返回到集合，根据id返回这个实体对象，等数据存放在这个里面</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//书写静态方法，来返回成功的案例，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">success</span><span class="params">(String msg, T data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(<span class="number">200</span>,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">success</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(<span class="number">200</span>,<span class="string">&quot;success&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">success</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(<span class="number">200</span>,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(<span class="number">200</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//书写静态方法,失败的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(<span class="number">500</span>,<span class="string">&quot;服务器内部异常&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">error</span><span class="params">(Integer code,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(code,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己设置的错误信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ResultBean <span class="title function_">error</span><span class="params">(AppExceptionCodeMsg appExceptionCodeMsg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>(appExceptionCodeMsg.getCode(),appExceptionCodeMsg.getMsg(),<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//RuntimeException 运行时异常不需要处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"><span class="comment">//默认参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;服务器内部错误&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义枚举异常信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(AppExceptionCodeMsg appExceptionCodeMsg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = appExceptionCodeMsg.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = appExceptionCodeMsg.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//设置异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppException</span><span class="params">(Integer code,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举异常信息类"><a href="#枚举异常信息类" class="headerlink" title="枚举异常信息类"></a>枚举异常信息类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AppExceptionCodeMsg</span> &#123;</span><br><span class="line"><span class="comment">//枚举了三种情况</span></span><br><span class="line">    INVOID_CODE(<span class="number">10000</span>,<span class="string">&quot;验证码无效&quot;</span>),</span><br><span class="line">    USERNAME_NOT_EXISTS(<span class="number">10001</span>,<span class="string">&quot;用户名不存在&quot;</span>),</span><br><span class="line">    REQUEST_PARAM_EMPTY(<span class="number">10002</span>,<span class="string">&quot;请求参数为空&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AppExceptionCodeMsg(Integer code, String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一处理异常"><a href="#统一处理异常" class="headerlink" title="统一处理异常"></a>统一处理异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对controller层抛出的异常进行处理，进行抓取，相当于全局异常处理</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出现异常就会进入该方法</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = &#123;Exception.class&#125;)</span></span><br><span class="line">    <span class="comment">//以JSON返回</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ResultBean&lt;T&gt; <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="comment">//这里先判断拦截到的异常是不是我们自己定义的异常类型</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AppException)&#123;</span><br><span class="line">            <span class="type">AppException</span> <span class="variable">appException</span> <span class="operator">=</span> (AppException) e;</span><br><span class="line">            <span class="keyword">return</span> ResultBean.error(appException.getCode(),appException.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="创建拦截器"><a href="#创建拦截器" class="headerlink" title="创建拦截器"></a>创建拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器：</span></span><br><span class="line"><span class="comment"> *  SpringMVC中才有的，不同于过滤器</span></span><br><span class="line"><span class="comment"> *      实现接口，HandlerInterceptor</span></span><br><span class="line"><span class="comment"> *      实现方法</span></span><br><span class="line"><span class="comment"> preHandle 进入业务方法之前，判断，放行就true，不放行就false</span></span><br><span class="line"><span class="comment"> *      postHandle</span></span><br><span class="line"><span class="comment"> *      afterCompletion</span></span><br><span class="line"><span class="comment"> *      用哪一个在哪一个编写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 拦截器需要配置</span></span><br><span class="line"><span class="comment"> *      SpringMVC项目中，可以在SpringMVC.xml里面配置</span></span><br><span class="line"><span class="comment"> *      在SpringBoot项目，没有SpringMVC.xml配置文件，可以写配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//preHandle()方法在业务处理器处理请求之前被调用 ，真正起到拦截作用，在进入路径之前进行判断拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入拦截器了....&quot;</span>);</span><br><span class="line">        <span class="comment">//这里可以判断用户是否登录</span></span><br><span class="line">        <span class="comment">//没有登录可以使用 request/response跳转回登录页面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注：如果不继续执行返回false,否则返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle()方法在业务处理器处理请求之后被调用，业务请求后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// afterCompletion()方法在DispatcherServlet完全处理完请求后被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>())<span class="comment">//添加拦截对象</span></span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)<span class="comment">//拦截的路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);<span class="comment">//排除不拦截的路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora破解</title>
      <link href="/posts/19491.html"/>
      <url>/posts/19491.html</url>
      
        <content type="html"><![CDATA[<h1 id="用于管理Typora过期进行时间修改"><a href="#用于管理Typora过期进行时间修改" class="headerlink" title="用于管理Typora过期进行时间修改"></a>用于管理Typora过期进行时间修改</h1><p>参考网址</p><p><a href="https://blog.csdn.net/no_say_you_know/article/details/125806545?spm=1001.2014.3001.5502">https://blog.csdn.net/no_say_you_know/article/details/125806545?spm=1001.2014.3001.5502</a></p><h2 id="首先，需要Python环境，然后GitHub下载"><a href="#首先，需要Python环境，然后GitHub下载" class="headerlink" title="首先，需要Python环境，然后GitHub下载"></a>首先，需要Python环境，然后GitHub下载</h2><ol><li><p>第一步，安装需要的包。</p><p>进入下载好的仓库文件夹，比如我这里<code>D:\GithubRepo\typoraCracker</code>，然后右键打开终端（方式自行选择）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>2继续敲入命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python typora.py &quot;C:\Program Files\Typora\resources\app.asar&quot; .</span><br></pre></td></tr></table></figure><p>在当前文件夹下，会生成dec_app文件夹，查看 dec_app 目录的 License.js 文件，记事本或者VS Code打开都行。搜索This beta version of Typora is expired, please download and install a newer version.</p><p>将时间戳改为4102329600000 ，即2099-12-31</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/0b260a63ad6740d88537fce518ea2bdc-61cd77.png" alt="在这里插入图片描述"></p><ol><li>最后执行</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python typora.py -u dec_app/ .</span><br></pre></td></tr></table></figure><p>会在根目录下生成<code>app.asar</code>文件，将它替换到typora的安装目录<code>Typora\resources</code>，即可正常打开了。</p><h2 id="这里附录我生成的下载地址"><a href="#这里附录我生成的下载地址" class="headerlink" title="这里附录我生成的下载地址"></a>这里附录我生成的下载地址</h2><p><a href="/download/typora/app.asar" download rel="noopener noreferrer" >生成的app.asar文件</a></p><p>温馨提示：下载过程中若遇到问题，请检查网络连接以及浏览器设置等情况哦。</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统</title>
      <link href="/posts/1747.html"/>
      <url>/posts/1747.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据切分——划分为测试集合和训练集合"><a href="#数据切分——划分为测试集合和训练集合" class="headerlink" title="数据切分——划分为测试集合和训练集合"></a>数据切分——划分为测试集合和训练集合</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220908190951293-850b16.png" alt="image-20220908190951293"></p><h2 id="Ratio"><a href="#Ratio" class="headerlink" title="Ratio"></a>Ratio</h2><p>其中0.8为训练，0.2为测试，缺点——每次选择的测试集合随机</p><h2 id="Givenn"><a href="#Givenn" class="headerlink" title="Givenn"></a>Givenn</h2><p>留下N份进行测试</p><p>其中分为三种方法</p><h3 id="留一"><a href="#留一" class="headerlink" title="留一"></a>留一</h3><p>留下一份数据用来做测试，其余的都用来做训练</p><h3 id="留下用户"><a href="#留下用户" class="headerlink" title="留下用户"></a>留下用户</h3><p>留下一个用户数据里面的固定数据个数用来做测试，其余的用来做训练</p><h3 id="留下项目"><a href="#留下项目" class="headerlink" title="留下项目"></a>留下项目</h3><p>留下一个类型（项目）数据里面的固定数据个数用来做测试，其余的用来做训练</p><h2 id="kcv"><a href="#kcv" class="headerlink" title="kcv"></a>kcv</h2><p>将数据分成k份，然后选取一份用来测试，其余用来训练，然后运行K次，让每份数据都测试，然后对K次运行结果取平均值</p><h2 id="testset"><a href="#testset" class="headerlink" title="testset"></a>testset</h2><p>直接切分好测试集和训练集</p><h1 id="推荐模型"><a href="#推荐模型" class="headerlink" title="推荐模型"></a>推荐模型</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220908191445276-e0fdcd.png" alt="image-20220908191445276"></p><h1 id="非个性化推荐"><a href="#非个性化推荐" class="headerlink" title="非个性化推荐"></a>非个性化推荐</h1><p>显示反馈与隐式反馈</p><p>显示反馈相当于喜欢</p><p>隐式反馈相当于兴趣，显示反馈由于数据太少，可以用隐式反馈补充数据</p><h1 id="协同过滤-Collaborative-Filtering-根据其他人的数据进行推荐-——基于内存"><a href="#协同过滤-Collaborative-Filtering-根据其他人的数据进行推荐-——基于内存" class="headerlink" title="协同过滤(Collaborative Filtering)根据其他人的数据进行推荐 ——基于内存"></a>协同过滤(Collaborative Filtering)根据其他人的数据进行推荐 ——基于内存</h1><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220915190603450-2b3345.png" alt="image-20220915190603450"></p><p>对于memory_based还可以分为基于用户以及基于商品</p><h2 id="对于一个纯粹的协同过滤"><a href="#对于一个纯粹的协同过滤" class="headerlink" title="对于一个纯粹的协同过滤"></a>对于一个纯粹的协同过滤</h2><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>给定一个用户和商品的评分矩阵</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>得到一个评分预测或者得到未来的物品推荐</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220915191459266-8dc1b2.png" alt="image-20220915191459266"></p><h2 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h2><p>前提条件：要在一段时间内，因为用户的兴趣会随着时间变化</p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>1：计算用户与用户之间的相似度</p><p>2：用算法去计算，然后排序，得到最近邻居</p><p>3：把最近邻居的观点聚合起来，得到推荐结果</p><h3 id="具体算法-——没记"><a href="#具体算法-——没记" class="headerlink" title="具体算法  ——没记"></a><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220915192117708-57fc42.png" alt="image-20220915192117708">具体算法  ——没记</h3><p>皮尔逊系数为什么要减去均值：</p><p>消除偏移量，避免因个人打分习惯不同出现的误差</p><p>MAE和RMSE的区别：RMSE使得误差放大，平方可以放大差异 大的更大小的更小</p><p>RMSE对于大误差有权重，使得大误差显示的更明显</p><h3 id="改进步骤"><a href="#改进步骤" class="headerlink" title="改进步骤"></a>改进步骤</h3><p>1：不是所有的用户的评分都是有用的，评分应当选择不是那么著名的，选择奇异值（有的人说好有的人说不好），不应当是流行的，因为可能相同的部分大家都喜欢</p><p>2：如果相似度非常接近1，那就应该给更多的权重——平方处理</p><p>3：让相似度评分更光滑，<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220915201816771-77ad82.png" alt="image-20220915201816771"></p><h2 id="基于物品的协同过滤"><a href="#基于物品的协同过滤" class="headerlink" title="基于物品的协同过滤"></a>基于物品的协同过滤</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919162928698-f40937.png" alt="image-20220919162928698"></p><h3 id="相似度计算公式"><a href="#相似度计算公式" class="headerlink" title="相似度计算公式"></a>相似度计算公式</h3><p>对于物品过滤一般使用余弦公式进行计算，用户一般使用皮尔逊系数</p><p>原因是因为皮尔逊相关系数进行计算的时候用到是平均值，而在物品时候往往都是二进制评分（eg：买过1，没买过0）</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919163049958-83c684.png" alt="image-20220919163049958"></p><p>对于调整完成的sim，每次减去的Ru是进行发生变化的，是计算一个用户的平均评分，换用户就会发生变化，</p><h3 id="预测公式："><a href="#预测公式：" class="headerlink" title="预测公式："></a>预测公式：</h3><p>其中U代表用户，P表示物品</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919162740570-4e549a.png" alt="image-20220919162740570"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>N方 ，因为要计算相似度,N为物品的数量</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>物品过滤可以提前计算出来物品与物品之间的相似度。</p><p>用户的相似度一般会发生变化，所以需要更新相似度的计算</p><p>对于物品的相似度，一般不会发生变化，所以物品协同过滤更广用，更快</p><h4 id="可解释上"><a href="#可解释上" class="headerlink" title="可解释上"></a>可解释上</h4><p>用户：相似用户也会读这本书</p><p>物品：你读了这十本书，可能你也喜欢这些书</p><h4 id="时间复杂度上"><a href="#时间复杂度上" class="headerlink" title="时间复杂度上"></a>时间复杂度上</h4><p>进行选择，如果用户数量远小于物品，那么可以选用户推荐，如果物品数量远小于用户数量，那么选择物品推荐<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919164321887-f8c007.png" alt="image-20220919164321887"></p><h4 id="性能上"><a href="#性能上" class="headerlink" title="性能上"></a>性能上</h4><p>总体来说物品推荐比用户推荐稳定，因为物品比较简单，更能在一段时间里面保持这个特性</p><h2 id="结合着两种推荐"><a href="#结合着两种推荐" class="headerlink" title="结合着两种推荐"></a>结合着两种推荐</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919164640443-c43a27.png" alt="image-20220919164640443"></p><p>通过λ来进行调和用户CF和物品CF</p><h1 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h1><h2 id="皮尔逊相关系数PCC"><a href="#皮尔逊相关系数PCC" class="headerlink" title="皮尔逊相关系数PCC"></a>皮尔逊相关系数PCC</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919165733933-2bd9fb.png" alt="image-20220919165733933"></p><p>注意PCC的计算的时候要考虑重叠的部分</p><h3 id="PCC约束改变"><a href="#PCC约束改变" class="headerlink" title="PCC约束改变"></a>PCC约束改变</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919171802351-52fd44.png" alt="image-20220919171802351"></p><p>其中<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919171825484-ac5c79.png" alt="image-20220919171825484">表示中间值，对某些数据更好的适配数据</p><h3 id="调整PCC"><a href="#调整PCC" class="headerlink" title="调整PCC"></a>调整PCC</h3><p>为了避免出现0:0的现象（分子或者分母为零）</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919171954305-1749ea.png" alt="image-20220919171954305"></p><p>加入小变量（eg:0.001）来处理零值</p><h2 id="余弦计算"><a href="#余弦计算" class="headerlink" title="余弦计算"></a>余弦计算</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919172059972-11da83.png" alt="image-20220919172059972"></p><h2 id="相关性含义"><a href="#相关性含义" class="headerlink" title="相关性含义"></a>相关性含义</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>只能用来描述线性相关</p><p>对于离群值或者异常值敏感</p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>描述两个变量之间的关系，</p><p>相关性分析尝试解决这些问题：</p><p>两者是否线性与非线性，两者变化的趋势（一个变量发生变化，另一个变量是否变化以及变化大小），改变大小</p><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><p>计算相同个体的两个变量</p><p>对于不同的个体的同一个变量</p><h2 id="斯皮尔曼相关系数SCC"><a href="#斯皮尔曼相关系数SCC" class="headerlink" title="斯皮尔曼相关系数SCC"></a>斯皮尔曼相关系数SCC</h2><p>将数据进行排序，排序为1，2，3.然后重新使用PCC来进行计算</p><h2 id="贝叶斯计算"><a href="#贝叶斯计算" class="headerlink" title="贝叶斯计算"></a>贝叶斯计算</h2><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p>注意所有的数据都进行了标准化，对于单位进行忽略计算，即不论数据是什么单位，但是不影响相关性</p><h2 id="相关性和因果联系的关系"><a href="#相关性和因果联系的关系" class="headerlink" title="相关性和因果联系的关系"></a>相关性和因果联系的关系</h2><p>很高的相关性但是不代表他们有因果关系</p><h2 id="其他计算方法"><a href="#其他计算方法" class="headerlink" title="其他计算方法"></a>其他计算方法</h2><p>将两个之间的距离进行计算，转化为sim，eg:欧氏距离，<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919175314111-7650d2.png" alt="image-20220919175314111"></p><p>不过存在一个问题：维度诅咒，当a,b维度很大时候，辨别会很小</p><h2 id="基于集合的相似度"><a href="#基于集合的相似度" class="headerlink" title="基于集合的相似度"></a>基于集合的相似度</h2><p>Jaccard index（常用于二分数据）</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220919175611619-f78afa.png" alt="image-20220919175611619"></p><p>对于X,，和Y同时出现的sim</p><h1 id="LFM（latent-factor-model）推荐算法——基于模型"><a href="#LFM（latent-factor-model）推荐算法——基于模型" class="headerlink" title="LFM（latent factor model）推荐算法——基于模型"></a>LFM（latent factor model）推荐算法——基于模型</h1><p>基于离线预处理或者“模型学习”的阶段</p><p>同时模型会进行定期重新训练</p><h2 id="模型的四种"><a href="#模型的四种" class="headerlink" title="模型的四种"></a>模型的四种</h2><p>集群（聚类）规则</p><p>挖掘关联规则，例如决策树学习</p><p>Learning to rank ：例如逻辑回归，神经网络</p><p>隐因子分析模型：</p><h2 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922184512292-bece70.png" alt="image-20220922184512292"></p><p>给定一个矩阵可以分解成这样的式子</p><p>Σ表示奇异值，特征值，U为左奇异矩阵，V为右奇异矩阵</p><p>对于得到一个用户物品的评分矩阵R0，当然些位置是空</p><p>对于SVD分解需要满矩阵，简单的处理是填0，更好的方法是填入平均值R1，之后将矩阵中的所有值减去平均值，得到R，对R进行SVD分解</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922184919515-9fc023.png" alt="image-20220922184919515"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对于平均值来填充缺失值可能不是最优的</p><h2 id="矩阵分解模型"><a href="#矩阵分解模型" class="headerlink" title="矩阵分解模型"></a>矩阵分解模型</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922190122494-df67df.png" alt="image-20220922190122494"></p><p>把用户和物品都放在一个低维的空间表示，是一个线性的函数</p><h3 id="对于矩阵分解比较好的，损失函数"><a href="#对于矩阵分解比较好的，损失函数" class="headerlink" title="对于矩阵分解比较好的，损失函数"></a>对于矩阵分解比较好的，损失函数</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922190442308-d3d08c.png" alt="image-20220922190442308"></p><p>求得这个值的最小值，其中r ui 是已知的评分，U*V是预测出来的分数，要使得这个式子取得最小值</p><p>对于后面的两项 是为了防止过拟合</p><p>对于损失函数中U 和V 的调整，一般参与梯度下降公式，我们使用SGD梯度下降公式进行计算</p><p>SGD是每次选取一个向量来进行计算</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>将物品和用户投射在同一个潜在空间上</p><p>有利于去掉一些噪音</p><p>SVD方法中奇异值的个数怎么确定</p><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>带有交叉验证</p><p>随着时间衰减学习率</p><h2 id="BisedMF"><a href="#BisedMF" class="headerlink" title="BisedMF"></a>BisedMF</h2><p>从用户的角度和物品的角度都加上一个便宜量</p><p>其中μ是全局偏移量，Bu是用户，Bi是物品</p><p>对于他的目标向量</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922192523192-f23247.png" alt="image-20220922192523192"></p><p>其中后面两项是为了避免过拟合</p><h1 id="因子分解机-——Factorization-Machines"><a href="#因子分解机-——Factorization-Machines" class="headerlink" title="因子分解机 ——Factorization Machines"></a>因子分解机 ——Factorization Machines</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922195544313-4a5ca0.png" alt="image-20220922195544313"></p><p>使用逻辑回归，但是缺点是没有考虑用户和物品之间的交叉特征</p><h2 id="二阶多项式"><a href="#二阶多项式" class="headerlink" title="二阶多项式"></a>二阶多项式</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922195644576-e53c3b.png" alt="image-20220922195644576"></p><p>用w乘以两个维度的关联</p><p>缺点是wij 维度太多了</p><h2 id="FM模型——因子分解机模型"><a href="#FM模型——因子分解机模型" class="headerlink" title="FM模型——因子分解机模型"></a>FM模型——因子分解机模型</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922195740528-a26963.png" alt="image-20220922195740528"></p><p>缺点：每个特征域交互强度不同</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><h4 id="AFM"><a href="#AFM" class="headerlink" title="AFM"></a>AFM</h4><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220922200036156-406cde.png" alt="image-20220922200036156"></p><p>aij 表示特征与特征之间交互的重要性</p><h1 id="BPR方法——基于隐式反馈"><a href="#BPR方法——基于隐式反馈" class="headerlink" title="BPR方法——基于隐式反馈"></a>BPR方法——基于隐式反馈</h1><p>在进行评分时候，采用比较，</p><h1 id="根据内容推送"><a href="#根据内容推送" class="headerlink" title="根据内容推送"></a>根据内容推送</h1>]]></content>
      
      
      <categories>
          
          <category> 学校学习 </category>
          
          <category> 东北大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校学习 </tag>
            
            <tag> 东北大学 </tag>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言语法笔记</title>
      <link href="/posts/42926.html"/>
      <url>/posts/42926.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="首先区分大小写"><a href="#首先区分大小写" class="headerlink" title="首先区分大小写"></a>首先区分大小写</h2><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220929141213387-235aba.png" alt="image-20220929141213387"></p><p>对于R可以对话时候，临时变量会存在R的内存空间中，R解释器会加载在内存中，临时变量会存在R解释器的内存空间中，小函数默认加载在内存中，大函数不加载</p><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>R的赋值语句一般使用&lt;-, 当然可以使用&#x3D;，但是推荐使用&lt;-</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释语句用# ， 只有单行注释，没有多行</p><h2 id="管理空间函数"><a href="#管理空间函数" class="headerlink" title="管理空间函数"></a>管理空间函数</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220929142444272-979b51.png" alt="image-20220929142444272"></p><h3 id="生成脚本文件"><a href="#生成脚本文件" class="headerlink" title="生成脚本文件"></a>生成脚本文件</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220929143033973-7e68b5.png" alt="image-20220929143033973"></p><h2 id="包的安装以及载入"><a href="#包的安装以及载入" class="headerlink" title="包的安装以及载入"></a>包的安装以及载入</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;包名&quot;</span><span class="punctuation">)</span></span><br><span class="line">注意安装的时候需要加上引号</span><br></pre></td></tr></table></figure><h3 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>包名<span class="punctuation">)</span></span><br><span class="line">不加入引号</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>R可以处理的数据类型（也叫做模式（modes））包括数值型，字符型，布尔型，复数，</p><p>对于数组中（下图中第一行）存储的数据，modes必须相同</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220929144924580-ec14ef.png" alt="image-20220929144924580"></p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>存储数值型、字符型或者逻辑型数据的一维数组</p><p>使用函数c() 来进行创建向量</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">b <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;one&quot;</span><span class="punctuation">,</span><span class="string">&quot;two&quot;</span><span class="punctuation">,</span><span class="string">&quot;three&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">c</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="literal">FALSE</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">,</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>对于访问，首先初始下标不是零开始</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span> 选取a中的第三个数据</span><br><span class="line">a<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">]</span> 选择a中的<span class="number">1</span>，<span class="number">3</span>，<span class="number">5</span>数据</span><br><span class="line">a<span class="punctuation">[</span><span class="number">2</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">]</span> 选取a中第<span class="number">2</span>到第<span class="number">5</span>的元素</span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>用函数matrix来进行创建</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">y <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span> nrow<span class="operator">=</span><span class="number">5</span><span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span> <span class="comment"># 1:20 相当于c(1,2,3,....,20)</span></span><br></pre></td></tr></table></figure><p>默认按列优先填充</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cells <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">26</span><span class="punctuation">,</span><span class="number">24</span><span class="punctuation">,</span><span class="number">68</span><span class="punctuation">)</span></span><br><span class="line">rnames <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;R1&quot;</span><span class="punctuation">,</span><span class="string">&quot;R2&quot;</span><span class="punctuation">)</span></span><br><span class="line">cnames <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;C1&quot;</span><span class="punctuation">,</span><span class="string">&quot;C2&quot;</span><span class="punctuation">)</span></span><br><span class="line">mymatrix <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>cells<span class="punctuation">,</span> nrow<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> byrow<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="built_in">dimnames</span><span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>rnames<span class="punctuation">,</span> cname））</span><br></pre></td></tr></table></figure><p>对于这个函数调用算法，cells表述数据，byrow&#x3D;TRUE表示按行填充，</p><p>对于R语言一般赋值元素值的时候，要加上属性名称，eg:byrow&#x3D;TRUE,其中byrow是属性，TRUE是值</p><h3 id="矩阵下标使用"><a href="#矩阵下标使用" class="headerlink" title="矩阵下标使用"></a>矩阵下标使用</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> 只选择第二行</span><br><span class="line">x<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span>只选择第二列</span><br><span class="line">x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span>选择第一行第四列元素</span><br><span class="line">x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">]</span> 选择第一行的四五列</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220929153233408-3202a7.png" alt="image-20220929153233408"></p><p>多维数组定义</p><p>其中vector包含了数组中的数据， dimensions是一个数值型向量，给出了各个维度下标的最大值，而dimnames是可选 的、各维度名称标签的列表。 </p><p>• 从数组中选取元素的方式与矩阵相同，使用方括号。</p><h2 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20220929153542912-9186f8.png" alt="image-20220929153542912"></p><p>一般先构建四列元素，然后将四列元素填充进去</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">patientdata<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span> <span class="comment">#选取第1、2列 ，默认选择列</span></span><br><span class="line">patientdata<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;diabetes&quot;</span><span class="punctuation">,</span><span class="string">&quot;status&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span> ，直接写入属性名字</span><br><span class="line">patientdata<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="comment">#选取第2行</span></span><br><span class="line">patientdata<span class="operator">$</span>age <span class="comment">#选取age列</span></span><br><span class="line">patientdata<span class="operator">$</span>age<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="comment">#选取age列的第二个</span></span><br></pre></td></tr></table></figure><p>#记号$用来选取一个给定数据框中的某 个特定变量，相当于一般计算机语言中 的“.”</p><h2 id="attach-函数"><a href="#attach-函数" class="headerlink" title="attach()函数"></a>attach()函数</h2><p>函数attach()可将数据框添加到R的搜索路 径中。R在遇到一个变量名以后(不必再使 用$)，将检查搜索路径中的数据框，以定位到这个变量</p><h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>类别变量和有序变量叫做因子</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">diabetes <span class="operator">&lt;-</span> factor<span class="punctuation">(</span>diabetes）</span><br><span class="line">                   将一个变量赋值为factor类型</span><br></pre></td></tr></table></figure><h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><p>列表可以用来存储一系列对象的有序集合，可以包括若干向量、矩阵、数据框，甚至其他 列表的组合</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating a list</span></span><br><span class="line">g <span class="operator">&lt;-</span> <span class="string">&quot;My First List&quot;</span></span><br><span class="line">h <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">25</span><span class="punctuation">,</span> <span class="number">26</span><span class="punctuation">,</span> <span class="number">18</span><span class="punctuation">,</span> <span class="number">39</span><span class="punctuation">)</span></span><br><span class="line">j <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">,</span> nrow<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">k <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;one&quot;</span><span class="punctuation">,</span><span class="string">&quot;two&quot;</span><span class="punctuation">,</span><span class="string">&quot;three&quot;</span><span class="punctuation">)</span></span><br><span class="line">mylist <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span>title<span class="operator">=</span>g<span class="punctuation">,</span> ages<span class="operator">=</span>h<span class="punctuation">,</span> j<span class="punctuation">,</span> k<span class="punctuation">)</span></span><br><span class="line">mylist</span><br></pre></td></tr></table></figure><h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p>对于R语言的文件输入，尽量将文件都转化为CSV进行读入</p><p>读取文件，</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"> data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;filename&quot;</span> <span class="punctuation">,</span> header<span class="operator">=</span><span class="literal">TRUE</span><span class="operator">/</span>false<span class="punctuation">,</span> sep<span class="operator">=</span><span class="string">&quot;,&quot;</span><span class="punctuation">,</span>row.name<span class="operator">=</span><span class="string">&quot;name&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">对于其中的参数，header表明首行是否包含了变量名，sep指定分隔符，row.names是一个可选参数，用以指定一个或多个标识符</span><br></pre></td></tr></table></figure><p>对于Excel数据，要进行转化 另存为 &gt;CSV</p><h3 id="处理数据对象常用函数"><a href="#处理数据对象常用函数" class="headerlink" title="处理数据对象常用函数"></a>处理数据对象常用函数</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221007115115790-5a90a5.png" alt="image-20221007115115790"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221007115129279-b5fc99.png" alt="image-20221007115129279"></p><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>edit()输入，必须给予赋值</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">patientdata<span class="operator">&lt;-</span>edit<span class="punctuation">(</span>patientdata<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>fix()修改</p><p>fix修改会自动赋值给变量值</p><h2 id="str函数"><a href="#str函数" class="headerlink" title="str函数"></a>str函数</h2><p>str函数可以查看一个变量的结构</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>R语言不提供多行注释</p><p>R语言在表中不存在的元素中，用NA而不用其他元素填充</p><p>无标量，全是向量，</p><p>数组从1开始，没有0下标</p><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221007115622660-7b7c44.png" alt="image-20221007115622660"></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221007115948305-6b6cee.png" alt="image-20221007115948305"></p><h2 id="变量重编码"><a href="#变量重编码" class="headerlink" title="变量重编码"></a>变量重编码</h2><p>根据已有的数据以及变换生成一个新变量，</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">leadership<span class="operator">$</span>agecat<span class="punctuation">[</span>leadership<span class="operator">$</span>age <span class="operator">&gt;</span> <span class="number">75</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;Elder&quot;</span></span><br></pre></td></tr></table></figure><p>也可以用within进行修改</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">leadership <span class="operator">&lt;-</span> within<span class="punctuation">(</span>leadership<span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">agecat <span class="operator">&lt;-</span> <span class="literal">NA</span></span><br><span class="line">agecat<span class="punctuation">[</span>age <span class="operator">&gt;</span> <span class="number">75</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;Elder&quot;</span></span><br><span class="line">agecat<span class="punctuation">[</span>age <span class="operator">&gt;=</span> <span class="number">55</span> <span class="operator">&amp;</span> age <span class="operator">&lt;=</span> <span class="number">75</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;Middle Aged&quot;</span></span><br><span class="line">agecat<span class="punctuation">[</span>age <span class="operator">&lt;</span> <span class="number">55</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;Y&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>）</span><br></pre></td></tr></table></figure><h2 id="变量重命名"><a href="#变量重命名" class="headerlink" title="变量重命名"></a>变量重命名</h2><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;reshape&quot;</span><span class="punctuation">)</span> <span class="comment">#先安装包</span></span><br><span class="line">library<span class="punctuation">(</span>reshape<span class="punctuation">)</span><span class="comment">#包引入</span></span><br><span class="line">leadership <span class="operator">&lt;-</span>rename<span class="punctuation">(</span>leadership<span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span>manager<span class="operator">=</span><span class="string">&quot;managerID&quot;</span><span class="punctuation">,</span>date<span class="operator">=</span><span class="string">&quot;testDate&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="names"><a href="#names" class="headerlink" title="names"></a>names</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有变量名</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>leadership<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#将第二个变量重命名</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>leadership<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;testDate&quot;</span></span><br><span class="line"><span class="comment">#将q1到q5重命名为item1到item5</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>leadership<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">6</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;item1&quot;</span><span class="punctuation">,</span><span class="string">&quot;item2&quot;</span><span class="punctuation">,</span><span class="string">&quot;item3&quot;</span><span class="punctuation">,</span><span class="string">&quot;item4&quot;</span><span class="punctuation">,</span><span class="string">&quot;item5&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="缺失值异常值处理"><a href="#缺失值异常值处理" class="headerlink" title="缺失值异常值处理"></a>缺失值异常值处理</h2><p>在数据缺失值为NA，数据不可能出现值用NaN，无穷大inf</p><h3 id="检查缺失值函数"><a href="#检查缺失值函数" class="headerlink" title="检查缺失值函数"></a>检查缺失值函数</h3><p>is.na(),可以检查哪些值是缺失值</p><h3 id="重编码缺失值"><a href="#重编码缺失值" class="headerlink" title="重编码缺失值"></a>重编码缺失值</h3><p>确实的值可能被自动修复为一个值，那么就需要进行重新编码，不影响计算</p><h3 id="计算时候移除缺失值"><a href="#计算时候移除缺失值" class="headerlink" title="计算时候移除缺失值"></a>计算时候移除缺失值</h3><p>很多函数自带移除缺失值的属性，na.rm&#x3D;TRUE</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">例如y <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>x<span class="punctuation">,</span> na.rm<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>删除所有缺失数据</p><p>na.omit()可以删除所有含缺失数据的行</p><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">as.Date<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">as.Date<span class="punctuation">(</span>x<span class="punctuation">,</span><span class="string">&quot;input_format&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221013140501722-99cbf5.png" alt="image-20221013140501722"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日期内建还可以用来做加减</span><br><span class="line">计算天数</span><br><span class="line">startdate &lt;- as.Date(&quot;2004-02-13&quot;)</span><br><span class="line">enddate &lt;- as.Date(&quot;2011-01-22&quot;)</span><br><span class="line">days &lt;- enddate - startdate</span><br><span class="line"></span><br><span class="line">计算周数：today &lt;- Sys.Date()</span><br><span class="line">dob &lt;- as.Date(&quot;1956-10-12&quot;)</span><br><span class="line">difftime(today, dob, units=&quot;weeks&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据转换函数"><a href="#数据转换函数" class="headerlink" title="数据转换函数"></a>数据转换函数</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20221013141149059-ee9a17.png" alt="image-20221013141149059"></p><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">使用order<span class="punctuation">(</span>value<span class="punctuation">)</span>函数来进行排序</span><br><span class="line">order<span class="punctuation">(</span>value<span class="punctuation">)</span>会返回一个排序的先后顺序，所以需要取出来就好</span><br><span class="line"></span><br><span class="line">默认升序</span><br><span class="line">newdata <span class="operator">&lt;-</span> leadership<span class="punctuation">[</span>order<span class="punctuation">(</span>leadership<span class="operator">$</span>age<span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">降序：加个负号</span><br><span class="line">newdata <span class="operator">&lt;-</span> leadership<span class="punctuation">[</span>order<span class="punctuation">(</span><span class="operator">-</span>leadership<span class="operator">$</span>age<span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">多变量排序</span><br><span class="line">newdata <span class="operator">&lt;-</span> leadership<span class="punctuation">[</span>order<span class="punctuation">(</span>leadership<span class="operator">$</span>gender<span class="punctuation">,</span>leadership<span class="operator">$</span>age<span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">merge<span class="punctuation">(</span><span class="punctuation">)</span>  通过一个变量或者多个变量进行连接</span><br><span class="line"></span><br><span class="line">total <span class="operator">&lt;-</span> merge<span class="punctuation">(</span>dataframeA<span class="punctuation">,</span> dataframeB<span class="punctuation">,</span> by<span class="operator">=</span><span class="string">&quot;ID&quot;</span><span class="punctuation">)</span>  两个数据表通过ID来进行合并</span><br><span class="line">  也可以用多个来进行合并by<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ID&quot;</span><span class="punctuation">,</span><span class="string">&quot;Country&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">cbind<span class="punctuation">(</span><span class="punctuation">)</span>  直接进行横向合并，顺序一样两个表</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rbind<span class="punctuation">(</span><span class="punctuation">)</span>添加行  两个数据库必须要有相同的变量，但是顺序不必相同</span><br><span class="line">如果有多余的变量：删除多余变量；对少的变量创建新变量并且值设为<span class="literal">NA</span></span><br></pre></td></tr></table></figure><h2 id="数据选子集"><a href="#数据选子集" class="headerlink" title="数据选子集"></a>数据选子集</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">选入变量 ： 用<span class="punctuation">[</span>行，列<span class="punctuation">]</span>来进行选取</span><br><span class="line"><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">]</span>  前面用来创建<span class="number">1</span><span class="operator">-</span><span class="number">100</span>的数字，后面来挑选，挑选第一个，不选第二个，但由于数据长度短，会进行循环</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">丢弃变量  <span class="operator">%in%</span> </span><br><span class="line">！<span class="built_in">names</span><span class="punctuation">(</span>leadership<span class="punctuation">)</span> <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;q3&quot;</span><span class="punctuation">,</span><span class="string">&quot;q4&quot;</span><span class="punctuation">)</span>  从leadership的名字集合里面，排除q3和q4</span><br><span class="line"></span><br><span class="line">因为知道q3和q4是第<span class="number">7</span>个和第<span class="number">8</span>个变量，也可以使用语句将其剔除：</span><br><span class="line">newdata <span class="operator">&lt;-</span> leadership<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">7</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">8</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">让对象赋<span class="literal">NULL</span></span><br><span class="line">leadership<span class="operator">$</span>q3 <span class="operator">&lt;-</span> leadership<span class="operator">$</span>q4 <span class="operator">&lt;-</span> <span class="literal">NULL</span>  但是这对leadership会更改</span><br><span class="line">相当于：• leadership<span class="operator">$</span>q3 <span class="operator">&lt;-</span> <span class="literal">NULL</span></span><br><span class="line">       • leadership<span class="operator">$</span>q4 <span class="operator">&lt;-</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">选入观测</span><br><span class="line">选择了所有<span class="number">30</span>岁以上的男性  布尔类型变量进行计算</span><br><span class="line">newdata <span class="operator">&lt;-</span> leadership<span class="punctuation">[</span>leadership<span class="operator">$</span>gender<span class="operator">==</span><span class="string">&quot;M&quot;</span><span class="operator">&amp;</span>leadership<span class="operator">$</span>age <span class="operator">&gt;</span> <span class="number">30</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">subset<span class="punctuation">(</span><span class="punctuation">)</span>函数</span><br><span class="line">newdata <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>leadership<span class="punctuation">,</span> age <span class="operator">&gt;=</span> <span class="number">35</span> <span class="operator">|</span> age<span class="operator">&lt;</span> <span class="number">24</span><span class="punctuation">,</span> select<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>q1<span class="punctuation">,</span> q2<span class="punctuation">,</span>q3<span class="punctuation">,</span>q4<span class="punctuation">)</span></span><br><span class="line">    选择子集选择行，select选择列</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sample<span class="punctuation">(</span><span class="punctuation">)</span> 随机抽样  可以从数据集中（有放回或无放回的）抽取n个</span><br><span class="line">sample<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>leadership<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span>replace<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">sample<span class="punctuation">(</span><span class="punctuation">)</span>函数中的第一个参数是一个由要从中抽样的元素组成的向量。在这里，这个向量是<span class="number">1</span>到数据框中观测的数量，第二个参数是要抽取的元素数量，第三个参数表示无放回抽样</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">操作SQL语句</span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;sqldf&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>sqldf<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="数据转置"><a href="#数据转置" class="headerlink" title="数据转置"></a>数据转置</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">转置：反转行和列。使用函数t<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">分类汇总的函数为aggregate<span class="punctuation">(</span>x<span class="punctuation">,</span> by<span class="punctuation">,</span> FUN<span class="punctuation">)</span></span><br><span class="line">• 其中x是待分类汇总的数据对象；by是一个变量名组成的列表，用于对原有观测进行分类；FUN是用来计算描述性统计量的函数，它将被用来计算新观测中的值</span><br></pre></td></tr></table></figure><h2 id="数据整合和重构"><a href="#数据整合和重构" class="headerlink" title="数据整合和重构"></a>数据整合和重构</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">首先将数据melt后来dcast来整合</span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>reshape2<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># melt data</span></span><br><span class="line">md <span class="operator">&lt;-</span> melt<span class="punctuation">(</span>mydata<span class="punctuation">,</span> id<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ID&quot;</span><span class="punctuation">,</span><span class="string">&quot;Time&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#newdata &lt;- dcast(md, formula, FUN)</span></span><br><span class="line">md为已融合的数据，formula描述了想要的最后结果，而FUN是（可选的）数据整合函数</span><br><span class="line">newdata <span class="operator">&lt;-</span> dcast<span class="punctuation">(</span>md<span class="punctuation">,</span> ID<span class="operator">+</span>Time<span class="operator">~</span>vailable<span class="punctuation">)</span></span><br><span class="line">波浪线左边是不变的东西</span><br></pre></td></tr></table></figure><h2 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>cond<span class="punctuation">)</span>statement</span><br><span class="line"><span class="keyword">if</span><span class="punctuation">(</span>cond<span class="punctuation">)</span>statement <span class="keyword">else</span> statement</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>在书写时候不可以放在句首</span><br><span class="line"></span><br><span class="line">ifelse<span class="punctuation">(</span>cond<span class="punctuation">,</span>statement1<span class="punctuation">,</span>statement2<span class="punctuation">)</span> 判断条件，条件为真运行第一个语句</span><br><span class="line">条件为假运行第二个，同时有返回值，将执行语句结果返回</span><br><span class="line"></span><br><span class="line"><span class="built_in">switch</span><span class="punctuation">(</span>expr<span class="punctuation">,</span>...<span class="punctuation">)</span></span><br><span class="line">feelings <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;sad&quot;</span><span class="punctuation">,</span><span class="string">&quot;afraid&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> feelings<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span></span><br><span class="line"><span class="built_in">switch</span><span class="punctuation">(</span>i<span class="punctuation">,</span>happy <span class="operator">=</span> <span class="string">&quot;I am glad you are happy&quot;</span><span class="punctuation">,</span></span><br><span class="line">afraid <span class="operator">=</span> <span class="string">&quot;There is nothing to fear&quot;</span><span class="punctuation">,</span></span><br><span class="line">sad <span class="operator">=</span> <span class="string">&quot;Cheer up&quot;</span><span class="punctuation">,</span></span><br><span class="line">angry <span class="operator">=</span> <span class="string">&quot;Calm down now&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>var <span class="keyword">in</span> seq<span class="punctuation">)</span> statemen</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="punctuation">(</span>cond<span class="punctuation">)</span> statemen</span><br><span class="line"></span><br><span class="line">循环不能一个一个处理</span><br></pre></td></tr></table></figure><h2 id="用户自编函数"><a href="#用户自编函数" class="headerlink" title="用户自编函数"></a>用户自编函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">myfunction <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>arg1<span class="punctuation">,</span> arg2<span class="punctuation">,</span> ... <span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">statements</span><br><span class="line"><span class="built_in">return</span><span class="punctuation">(</span>object<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>如果在进行赋值的时候，不用赋值，那么值原本不会更新。</p><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="列联表"><a href="#列联表" class="headerlink" title="列联表"></a>列联表</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">table<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">:</span> 使用 N 个类别型变量（因子）创建一个 N维列联表（即频数表）</span><br><span class="line"></span><br><span class="line">将因子列出来频数</span><br></pre></td></tr></table></figure><h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">• 条形图通过垂直的或水平的条形展示了类别型变量的分布（频数）</span><br><span class="line">barplot<span class="punctuation">(</span>counts<span class="punctuation">,</span>xlab<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span> ylab<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>horiz<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">其中的counts是一个向量或一个矩阵<span class="punctuation">,</span>horiz表示水平放置</span><br><span class="line">要多个列联表（二维）beside<span class="operator">=</span><span class="literal">TRUE</span> 表示分组条形图</span><br><span class="line">默认为堆砌条形图</span><br><span class="line">col<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span><span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span><span class="string">&quot;green&quot;</span><span class="punctuation">)</span> 可以用来设置颜色</span><br><span class="line">legend<span class="operator">=</span>rownames<span class="punctuation">(</span>counts<span class="punctuation">)</span> 展示图例信息，这里展示的是counts的行信息</span><br></pre></td></tr></table></figure><h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pie<span class="punctuation">(</span>x<span class="punctuation">,</span> labels）</span><br><span class="line">    其中x是一个非负数值向量，表示每个扇形的面积，而labels则是表示各扇形标签的字符型向量。</span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;plotrix&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>plotrix<span class="punctuation">)</span></span><br><span class="line">pie3D<span class="punctuation">(</span>x<span class="punctuation">,</span> labels）</span><br></pre></td></tr></table></figure><h2 id="扇形图"><a href="#扇形图" class="headerlink" title="扇形图"></a>扇形图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>plotrix<span class="punctuation">)</span></span><br><span class="line">fan.plot<span class="punctuation">(</span>x<span class="punctuation">,</span> labels）</span><br></pre></td></tr></table></figure><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">直方图来展示连续性变量的分布</span><br><span class="line">hist<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">其中的x是一个由数据值组成的数值向量。参数freq<span class="operator">=</span><span class="literal">FALSE</span>表示根据概率密度而不是频数绘制图形。参数breaks用于控制组的数量。在定义直方图中的单元时，默认将生成等距切分。</span><br><span class="line">col<span class="operator">=</span><span class="string">&quot;red&quot;</span>  设置颜色为红色</span><br><span class="line">xlab<span class="operator">=</span><span class="string">&quot;&quot;</span> 设置x轴</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="核密度图"><a href="#核密度图" class="headerlink" title="核密度图"></a>核密度图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">核密度估计是用于估计随机变量概率密度函数的一种非参数方法。核密度估计不利用数据分布的先验知识，对数据分布不附加任何假定，是一种从数据样本本身出发研究数据分布特征的方法</span><br><span class="line"></span><br><span class="line">plot<span class="punctuation">(</span>density<span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span> 其中的x是一个数值型向量</span><br></pre></td></tr></table></figure><h2 id="lines函数"><a href="#lines函数" class="headerlink" title="lines函数"></a>lines函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span><span class="punctuation">)</span>函数会创建一幅新的图形，所以要向一幅已经存在的图形上叠加一条密度曲线，可以使用lines<span class="punctuation">(</span><span class="punctuation">)</span>函数</span><br><span class="line">lines可以叠加一条曲线，在原来图上</span><br></pre></td></tr></table></figure><h2 id="箱线图-盒装图"><a href="#箱线图-盒装图" class="headerlink" title="箱线图&#x2F;盒装图"></a>箱线图&#x2F;盒装图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">箱线图通过绘制连续型变量的五数总括，即下边缘、下四分位数、中位数、上四分位数以及上边缘，描述了连续型变量的分布</span><br><span class="line"></span><br><span class="line">boxplot（x）</span><br></pre></td></tr></table></figure><h3 id="并列箱线图进行跨组比较"><a href="#并列箱线图进行跨组比较" class="headerlink" title="并列箱线图进行跨组比较"></a>并列箱线图进行跨组比较</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>formula<span class="punctuation">,</span> data<span class="operator">=</span>dataframe<span class="punctuation">)</span></span><br><span class="line">其中的formula是一个公式，dataframe代表提供数据的数据框（或列表）。</span><br><span class="line">eg<span class="operator">:</span>boxplot<span class="punctuation">(</span>mpg<span class="operator">~</span>cyl<span class="punctuation">,</span>data<span class="operator">=</span>mtcars<span class="punctuation">,</span></span><br><span class="line">main<span class="operator">=</span><span class="string">&quot;Car Milage Data&quot;</span><span class="punctuation">,</span>xlab<span class="operator">=</span><span class="string">&quot;Number of Cylinders&quot;</span><span class="punctuation">,</span>ylab<span class="operator">=</span><span class="string">&quot;Miles Per Gallon)</span></span><br></pre></td></tr></table></figure><h2 id="点图"><a href="#点图" class="headerlink" title="点图"></a>点图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">点图提供了一种在简单水平刻度上绘制大量有标签值的方法</span><br><span class="line">dotchart<span class="punctuation">(</span>x<span class="punctuation">,</span>labels<span class="operator">=</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">用来描述两个连续型变量间的关系———最好的图</span><br><span class="line"></span><br><span class="line">是plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span>，其中，x和y是数值型向量，代表着图形中的<span class="punctuation">(</span>x<span class="punctuation">,</span>y<span class="punctuation">)</span>点</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="abline函数"><a href="#abline函数" class="headerlink" title="abline函数"></a><code>abline</code>函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">abline<span class="punctuation">(</span><span class="punctuation">)</span>函数用来添加最佳拟合的线性直线</span><br></pre></td></tr></table></figure><h2 id="散点图矩阵"><a href="#散点图矩阵" class="headerlink" title="散点图矩阵"></a>散点图矩阵</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pairs<span class="punctuation">(</span><span class="punctuation">)</span>函数可以创建基础的散点图矩阵</span><br><span class="line">eg<span class="operator">:</span>pairs<span class="punctuation">(</span><span class="operator">~</span> mpg <span class="operator">+</span> disp <span class="operator">+</span> drat <span class="operator">+</span> wt<span class="punctuation">,</span> data<span class="operator">=</span>mtcars<span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&quot;Basic Scatterplot Matrix&quot;</span></span><br></pre></td></tr></table></figure><h2 id="高密度散点图"><a href="#高密度散点图" class="headerlink" title="高密度散点图"></a>高密度散点图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">smoothScatter<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">可利用核密度估计生成用颜色密度来表示点分布的散点图</span><br><span class="line"></span><br><span class="line">hexbin<span class="punctuation">(</span><span class="punctuation">)</span> </span><br><span class="line">hexbin包中的hexbin<span class="punctuation">(</span><span class="punctuation">)</span>函数将二元变量的封箱放到六边形单元格中。</span><br><span class="line"></span><br><span class="line">IDPmisc包中的iplot<span class="punctuation">(</span><span class="punctuation">)</span>函数可通过颜色来展示点的密度（在某特定点上数据点的数目）</span><br></pre></td></tr></table></figure><h2 id="三维散点图—没用"><a href="#三维散点图—没用" class="headerlink" title="三维散点图—没用"></a>三维散点图—没用</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">scatterplot3d中的scatterplot3d<span class="punctuation">(</span><span class="punctuation">)</span>函数可绘制三维散点图。格式：</span><br><span class="line">scatterplot3d<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> z<span class="punctuation">)</span></span><br><span class="line">• x被绘制在水平轴上，y被绘制在竖直轴上，z被绘制在透视轴上</span><br></pre></td></tr></table></figure><h2 id="气泡图"><a href="#气泡图" class="headerlink" title="气泡图"></a>气泡图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">symbols<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> circle<span class="operator">=</span>radius<span class="punctuation">)</span></span><br><span class="line">• 其中x、y和radius是需要设定的向量，分别表示x、y坐标和圆圈半径。</span><br></pre></td></tr></table></figure><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">– plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> type<span class="operator">=</span><span class="punctuation">)</span> </span><br><span class="line">– lines<span class="punctuation">(</span>x<span class="punctuation">,</span>y<span class="punctuation">,</span>type<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line">由两种方式来创建</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">plot<span class="punctuation">(</span><span class="punctuation">)</span>函数是被调用时即创建一幅新图，自己创建一个图片</span><br><span class="line">lines<span class="punctuation">(</span><span class="punctuation">)</span>函数则是在已存在的图形上添加信息，并不能自己生成图形</span><br><span class="line"></span><br><span class="line">lines<span class="punctuation">(</span><span class="punctuation">)</span>函数通常是在plot<span class="punctuation">(</span><span class="punctuation">)</span>函数生成一幅图形后再被调用</span><br></pre></td></tr></table></figure><p>对于type参数</p><h2 id="相关图"><a href="#相关图" class="headerlink" title="相关图"></a>相关图</h2><p>展示两两之间的相关性</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cor<span class="punctuation">(</span><span class="punctuation">)</span>函数用来计算相关性</span><br><span class="line"></span><br><span class="line">采用corrgram<span class="punctuation">(</span><span class="punctuation">)</span>函数来绘画</span><br><span class="line">corrgram<span class="punctuation">(</span>x<span class="punctuation">,</span> order<span class="operator">=</span><span class="punctuation">,</span> panel<span class="operator">=</span><span class="punctuation">,</span> text.panel<span class="operator">=</span><span class="punctuation">,</span>diag.panel<span class="operator">=</span><span class="punctuation">)</span></span><br><span class="line">– 其中，x是一行一个观测的数据框。当order <span class="operator">=</span><span class="literal">TRUE</span>时，相关矩阵将使用主成分分析法对变量重新排序，这使得二元变量的关系模式更为明显。选项panel 设定非对角线面板使用的元素类型。可通过选项lower.panel和upper.panel来分别设置主对角线下方和上方的元素类型。text.panel和diag.panel选项控制着主对角线元素类型</span><br><span class="line"></span><br><span class="line">eg<span class="operator">:</span>lower.panel<span class="operator">=</span>panel.shade<span class="punctuation">,</span>左下角用阴影展示</span><br><span class="line">upper.panel<span class="operator">=</span>panel.pie右上角用圆形展示</span><br><span class="line">text.panel<span class="operator">=</span>panel.txt 对角线用txt展示</span><br><span class="line">panel.ellipse 用椭圆表示</span><br></pre></td></tr></table></figure><h2 id="马赛克图"><a href="#马赛克图" class="headerlink" title="马赛克图"></a>马赛克图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">马赛克图用于可视化两个以上的类别型变量</span><br><span class="line"></span><br><span class="line">mosaic<span class="punctuation">(</span>table<span class="punctuation">)</span> – 其中table是数组形式的列联表。</span><br><span class="line">– 添加选项shade <span class="operator">=</span> <span class="literal">TRUE</span>将根据拟合模型的皮</span><br><span class="line">尔逊残差值对图形上色。</span><br><span class="line">– 添加选项legend <span class="operator">=</span> <span class="literal">TRUE</span>将展示残差的图例</span><br></pre></td></tr></table></figure><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rainbow<span class="punctuation">(</span>times<span class="punctuation">)</span><span class="operator">&gt;</span> 可以取出来times个数的颜色</span><br></pre></td></tr></table></figure><h1 id="基本统计分析"><a href="#基本统计分析" class="headerlink" title="基本统计分析"></a>基本统计分析</h1><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mean<span class="punctuation">(</span>x<span class="punctuation">)</span> 平均数</span><br><span class="line"></span><br><span class="line">• median<span class="punctuation">(</span>x<span class="punctuation">)</span> 中位数</span><br><span class="line"></span><br><span class="line">• var<span class="punctuation">(</span>x<span class="punctuation">)</span> 方差（ ）</span><br><span class="line"></span><br><span class="line">• sd<span class="punctuation">(</span>x<span class="punctuation">)</span> 标准差（σ ）</span><br><span class="line"></span><br><span class="line">• <span class="built_in">range</span><span class="punctuation">(</span>x<span class="punctuation">)</span> 求值域</span><br><span class="line"></span><br><span class="line">• <span class="built_in">sum</span><span class="punctuation">(</span>x<span class="punctuation">)</span> 求和</span><br><span class="line"></span><br><span class="line">• <span class="built_in">min</span><span class="punctuation">(</span>x<span class="punctuation">)</span> 求最小值</span><br><span class="line"></span><br><span class="line">• <span class="built_in">max</span><span class="punctuation">(</span>x<span class="punctuation">)</span> 求最大值</span><br></pre></td></tr></table></figure><h2 id="summary函数"><a href="#summary函数" class="headerlink" title="summary函数"></a><code>summary</code>函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">– summary<span class="punctuation">(</span><span class="punctuation">)</span>函数提供了最小值、最大值、四分位数和数值型变量的均值，以及因子向量和逻</span><br><span class="line">辑型向量的频数统计</span><br></pre></td></tr></table></figure><h2 id="sapply函数"><a href="#sapply函数" class="headerlink" title="sapply函数"></a><code>sapply</code>函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sapply<span class="punctuation">(</span>x<span class="punctuation">,</span> FUN<span class="punctuation">,</span> options<span class="punctuation">)</span></span><br><span class="line">• 其中的x是数据框（或矩阵），FUN为一个任意的函数。sapply对每列应用函数FUN。如果指定了options，它们将被传递给FUN。在这里插入的典型函数有mean、sd、var、<span class="built_in">min</span>、<span class="built_in">max</span>、median、<span class="built_in">length</span>、<span class="built_in">range</span>和quantile</span><br></pre></td></tr></table></figure><h2 id="aggregate函数"><a href="#aggregate函数" class="headerlink" title="aggregate函数"></a><code>aggregate</code>函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">各组的描述性统计信息</span><br><span class="line">eg<span class="operator">:</span>aggregate<span class="punctuation">(</span>mtcars<span class="punctuation">[</span>myvars<span class="punctuation">]</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>am<span class="operator">=</span>mtcars<span class="operator">$</span>am<span class="punctuation">)</span><span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">第一个参数用来选择数据集合，第二个参数选定一个因子类型变量，将数据进行分组，最后一个变量将分好组的数据用该函数进行计算</span><br><span class="line"></span><br><span class="line">aggregate<span class="punctuation">(</span><span class="punctuation">)</span>仅允许在每次调用中使用平均数、标准差这样的单返回值函数。它无法一次返回若干个统计量，即这个函数只能是一个返回值</span><br></pre></td></tr></table></figure><h2 id="by函数"><a href="#by函数" class="headerlink" title="by函数"></a><code>by</code>函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">by<span class="punctuation">(</span>data<span class="punctuation">,</span> INDICES<span class="punctuation">,</span> FUN<span class="punctuation">)</span></span><br><span class="line">• 其中data是一个数据框或矩阵，INDICES是一个因子或因子组成的列表，定义了分组，FUN是任意函数：单返回值函数和多返回值函数均可</span><br></pre></td></tr></table></figure><h2 id="频数表"><a href="#频数表" class="headerlink" title="频数表"></a>频数表</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">table<span class="punctuation">(</span>value<span class="punctuation">)</span>  来计算频数</span><br><span class="line">prop.table<span class="punctuation">(</span>value<span class="punctuation">)</span>将这些频数转化为比例值</span><br></pre></td></tr></table></figure><h2 id="列联表-1"><a href="#列联表-1" class="headerlink" title="列联表"></a>列联表</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mytable <span class="operator">&lt;-</span> table<span class="punctuation">(</span>A<span class="punctuation">,</span> B<span class="punctuation">)</span> 其中的A是行变量，B是列变量</span><br><span class="line"></span><br><span class="line">xtabs<span class="punctuation">(</span><span class="punctuation">)</span>函数还可使用公式风格的输入创建列联表，格式为：</span><br><span class="line">mytable <span class="operator">&lt;-</span> xtabs<span class="punctuation">(</span><span class="operator">~</span> A <span class="operator">+</span> B<span class="punctuation">,</span> data<span class="operator">=</span>mydata<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">使用margin.table<span class="punctuation">(</span><span class="punctuation">)</span>函数生成边际和</span><br><span class="line">margin.table<span class="punctuation">(</span>mytable<span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span> <span class="comment">#row sums</span></span><br><span class="line">margin.table<span class="punctuation">(</span>mytable<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span> <span class="comment"># column sums</span></span><br><span class="line">使用prop.table<span class="punctuation">(</span><span class="punctuation">)</span>函数生成比例（小数）。</span><br><span class="line">prop.table<span class="punctuation">(</span>mytable<span class="punctuation">)</span> <span class="comment"># cell proportions</span></span><br><span class="line">prop.table<span class="punctuation">(</span>mytable<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment"># row proportions</span></span><br><span class="line">prop.table<span class="punctuation">(</span>mytable<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span> <span class="comment"># column propor</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">CrossTable<span class="punctuation">(</span><span class="punctuation">)</span>创建二维列联表</span><br><span class="line">library<span class="punctuation">(</span>gmodels<span class="punctuation">)</span></span><br><span class="line">CrossTable<span class="punctuation">(</span>Arthritis<span class="operator">$</span>Treatment<span class="punctuation">,</span></span><br><span class="line">Arthritis<span class="operator">$</span>Improved<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多维列联表"><a href="#多维列联表" class="headerlink" title="多维列联表"></a>多维列联表</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">table<span class="punctuation">(</span><span class="punctuation">)</span>和xtabs<span class="punctuation">(</span><span class="punctuation">)</span>可以基于三个或更多的类别型变量生成多维列联表。</span><br><span class="line">• margin.table<span class="punctuation">(</span><span class="punctuation">)</span>、prop.table<span class="punctuation">(</span><span class="punctuation">)</span>和addmargins<span class="punctuation">(</span><span class="punctuation">)</span>函数可以推广到高于二维的情况。</span><br><span class="line"> ftable<span class="punctuation">(</span><span class="punctuation">)</span>函数可以以一种紧凑而吸引人的方式输出多维列联表</span><br></pre></td></tr></table></figure><h2 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chisq.test()函数对二维列联表的行变量和列变量进行卡方独立性检验</span><br><span class="line">    </span><br><span class="line">   注意：卡方检验有四条假设（参考Wikipedia：Pearson<span class="string">&#x27;s chi-squared test），其</span></span><br><span class="line"><span class="string">中一条假设是每个单元频数都要大于5</span></span><br></pre></td></tr></table></figure><h2 id="fisher列联表"><a href="#fisher列联表" class="headerlink" title="fisher列联表"></a>fisher列联表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fisher精确检验的原假设是：边界固定的列联表中行和列是相互独立的。</span><br><span class="line">• 可以使用fisher.test()函数进行Fisher精确检验。其调用格式为fisher.test(mytable)，其中的mytable是一个二维列联表。</span><br><span class="line">• 注意：fisher.test()函数可以在任意行列数大于等于<span class="number">2</span>的二维列联表上使用，但不能用于<span class="number">2</span>×<span class="number">2</span>的列联表</span><br></pre></td></tr></table></figure><h2 id="Cochran-Mantel-Haenszel检验"><a href="#Cochran-Mantel-Haenszel检验" class="headerlink" title="Cochran-Mantel-Haenszel检验"></a><code>Cochran-Mantel-Haenszel</code>检验</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mantelhaen.test<span class="punctuation">(</span><span class="punctuation">)</span>函数可用来进行Cochran<span class="operator">-</span> Mantel<span class="operator">-</span>Haenszel卡方检验。</span><br><span class="line">• 其原假设是：两个名义变量在第三个变量的每一层中都是条件独立的。</span><br></pre></td></tr></table></figure><h2 id="相关性度量"><a href="#相关性度量" class="headerlink" title="相关性度量"></a>相关性度量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">的assocstats()函数可以用来计算二维列联表的</span><br><span class="line">– phi系数</span><br><span class="line">– 列联系数</span><br><span class="line">– Cramer<span class="string">&#x27;s V系</span></span><br></pre></td></tr></table></figure><h2 id="相关性检验"><a href="#相关性检验" class="headerlink" title="相关性检验"></a>相关性检验</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pearson积差相关系数衡量了两个定量变量之间的线性相关程度。</span><br><span class="line">• Spearman等级相关系数则衡量分级定序变量之间的相关程度。</span><br><span class="line">• Kendall<span class="string">&#x27;s Tau相关系数是一种非参数的等级相关度量</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cor<span class="punctuation">(</span><span class="punctuation">)</span>函数可以计算Pearson、Spearman和Kendall相关系数。</span><br><span class="line">• cov<span class="punctuation">(</span><span class="punctuation">)</span>函数可用来计算协方差。默认是皮尔逊相关系数，</span><br><span class="line">cor<span class="punctuation">(</span>states<span class="punctuation">,</span> method<span class="operator">=</span><span class="string">&quot;spearman&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="偏向关"><a href="#偏向关" class="headerlink" title="偏向关"></a>偏向关</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">偏相关是指在控制一个或多个定量变量（要排除影响的定量变量）时，另外两个</span><br><span class="line">定量变量之间的相互关系。</span><br><span class="line">• 可以使用ggm包中的pcor<span class="punctuation">(</span><span class="punctuation">)</span>函数计算偏相关系数。</span><br><span class="line">pcor<span class="punctuation">(</span><span class="punctuation">)</span>函数调用格式为：pcor<span class="punctuation">(</span>u<span class="punctuation">,</span> S<span class="punctuation">)</span></span><br><span class="line">其中的u是一个数值向量，前两个数值表示要计算相关系数的变量下标，其余的数值为条件变量（即要排除影响的变量）的下标。S为变量的协方差阵</span><br></pre></td></tr></table></figure><h2 id="相关性的显著性检验"><a href="#相关性的显著性检验" class="headerlink" title="相关性的显著性检验"></a>相关性的显著性检验</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cor.test<span class="punctuation">(</span><span class="punctuation">)</span>函数</span><br><span class="line"></span><br><span class="line">cor.test<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> alternative <span class="operator">=</span></span><br><span class="line"><span class="punctuation">,</span> method <span class="operator">=</span> <span class="punctuation">)</span> – 其中的x和y为要检验相关性的变量</span><br><span class="line">– alternative用来指定进行双侧检验或单侧检验（取值为<span class="string">&quot;two.side&quot;</span>、<span class="string">&quot;less&quot;</span>或<span class="string">&quot;greater&quot;</span>），</span><br><span class="line">– method用以指定要计算的相关类型（<span class="string">&quot;pearson&quot;</span>、<span class="string">&quot;kendall&quot;</span>或<span class="string">&quot;spearman&quot;</span>）</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">corr.test<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> use<span class="operator">=</span></span><br><span class="line"><span class="punctuation">,</span> method <span class="operator">=</span> <span class="punctuation">)</span> – 参数use<span class="operator">=</span>的取值可为<span class="string">&quot;pairwise&quot;</span>或<span class="string">&quot;complete&quot;</span></span><br><span class="line">（分别表示对缺失值执行成对删除或行删除）。</span><br><span class="line">– 参数method<span class="operator">=</span>的取值可为<span class="string">&quot;pearson&quot;</span>（默认值）、<span class="string">&quot;spearman&quot;</span>或<span class="string">&quot;kendall&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="T检验"><a href="#T检验" class="headerlink" title="T检验"></a>T检验</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">原始测量值服从t分布。</span><br><span class="line">• 原假设：针对两组独立样本（并且是从正态总体中抽得），两个总体的均值相等。</span><br><span class="line"></span><br><span class="line">• t检验的第一种调用格式为：</span><br><span class="line">t.test<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data<span class="punctuation">)</span></span><br><span class="line">其中的y是一个数值型变量，x是一个二分变量。</span><br><span class="line">• t检验的第二种调用格式为：</span><br><span class="line">t.test<span class="punctuation">(</span>y1<span class="punctuation">,</span> y2<span class="punctuation">)</span></span><br><span class="line">其中的y1和y2为数值型向量。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方差分析ANOVA"><a href="#方差分析ANOVA" class="headerlink" title="方差分析ANOVA"></a>方差分析<code>ANOVA</code></h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">首先得保证是正态总体，假设每组均值相等</span><br><span class="line"></span><br><span class="line">方差分析主要用于分析分类型自变量和数值型因变量之间的关系</span><br><span class="line"></span><br><span class="line">aov<span class="punctuation">(</span>formula<span class="punctuation">,</span> data <span class="operator">=</span> dataframe）</span><br></pre></td></tr></table></figure><h2 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">TukeyHSD<span class="punctuation">(</span><span class="punctuation">)</span>函数提供了对各组均值差异的成对检验</span><br><span class="line">进行两个两个之间的差别</span><br></pre></td></tr></table></figure><h2 id="双因素方差分析"><a href="#双因素方差分析" class="headerlink" title="双因素方差分析"></a>双因素方差分析</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fit <span class="operator">&lt;-</span> aov<span class="punctuation">(</span>len <span class="operator">~</span> supp<span class="operator">*</span>dose<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interaction.plot<span class="punctuation">(</span><span class="punctuation">)</span>函数来展示双因素方差分析的交互效应</span><br><span class="line"></span><br><span class="line">可以用gplots包中的plotmeans<span class="punctuation">(</span><span class="punctuation">)</span>函数来展示交互效应</span><br><span class="line"></span><br><span class="line">可以HH包中的interaction2wt<span class="punctuation">(</span><span class="punctuation">)</span>函数来可视化结果，图形对任意顺序的因子设计的主效应和交互效应都会进行展示</span><br></pre></td></tr></table></figure><h2 id="组间差异的非参数检验"><a href="#组间差异的非参数检验" class="headerlink" title="组间差异的非参数检验"></a>组间差异的非参数检验</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">两组数据独立，可以使用Wilcoxon秩和检验<span class="punctuation">,</span>来评估观测是否是从相同的概率分布中抽得的</span><br><span class="line"></span><br><span class="line">第一种调用格式为：</span><br><span class="line">wilcox.test<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data<span class="punctuation">)</span></span><br><span class="line">其中的y是数值型变量，而x是一个二分变量。</span><br><span class="line">• 第二种调用格式为：</span><br><span class="line">wilcox.test<span class="punctuation">(</span>y1<span class="punctuation">,</span> y2<span class="punctuation">)</span></span><br><span class="line">其中的y1和y2为各组的结果变量</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">多于两组</span><br><span class="line">如果无法满足ANOVA设计的假设，那么可以使用非参数方法来评估组间的差异。</span><br><span class="line">• 如果各组独立，可以使用Kruskal—Wallis检验。</span><br><span class="line">kruskal.test<span class="punctuation">(</span>y <span class="operator">~</span> A<span class="punctuation">,</span> data<span class="punctuation">)</span></span><br><span class="line">• 如果各组不独立（如重复测量设计或随机区组设计），可以使用Friedman检验。</span><br><span class="line">friedman.test<span class="punctuation">(</span>y <span class="operator">~</span> A <span class="operator">|</span>B，data<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h1 id="dataTable"><a href="#dataTable" class="headerlink" title="dataTable"></a><code>dataTable</code></h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">读取数据</span><br><span class="line">可以使用data.table的fread<span class="punctuation">(</span><span class="punctuation">)</span>函数进行数据读取</span><br><span class="line"></span><br><span class="line">可以通过data.table<span class="punctuation">(</span><span class="punctuation">)</span>创建一个data.table</span><br><span class="line"></span><br><span class="line">as.data.table<span class="punctuation">(</span><span class="punctuation">)</span>将已经存在的对象转化成data.table</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">i表示subset行，表示选择多少观测</span><br><span class="line">j表示select列，用 <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span> 把列名包围起来，它可以确保返回值是data.table。还可以对列进行计算合并，也可以重命名</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">特别的符号 .N，相当于<span class="built_in">length</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">– .N 是一个内建的变量，它表示当前的分组中，对象的数目。在下一节，当它和 by 一起使用的时候，我们会发现它特别有用。还没有涉及到分组的时候，它只是简单地返回行的数目</span><br></pre></td></tr></table></figure><h3 id="by分组"><a href="#by分组" class="headerlink" title="by分组"></a>by分组</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ans <span class="operator">&lt;-</span> flights<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>.N<span class="punctuation">)</span><span class="punctuation">,</span> by<span class="operator">=</span>.<span class="punctuation">(</span>origin<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">– .N 表示当前的分组中，对象的数目。先按照 origin 列分组，再用 .N 获取每组的数目</span><br><span class="line">在by中.<span class="punctuation">(</span><span class="punctuation">)</span>可以表示用<span class="built_in">list</span>来进行分类</span><br><span class="line">.<span class="punctuation">(</span><span class="punctuation">)</span>将其转化为datatable，之后计算.N</span><br></pre></td></tr></table></figure><h3 id="keyby关键字"><a href="#keyby关键字" class="headerlink" title="keyby关键字"></a>keyby关键字</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">只是把 by 改为了 keyby。这会自动的将结果按照升序排列。注意 keyby<span class="punctuation">(</span><span class="punctuation">)</span> 是在数据操作完成后才进行。</span><br><span class="line">– 实际上 keyby 做的不只是排序。它在排序之后，设置一个叫做sorted的属性。</span><br><span class="line">相当于把这里面的值当作了主键</span><br></pre></td></tr></table></figure><h3 id="chaining表达式"><a href="#chaining表达式" class="headerlink" title="chaining表达式"></a>chaining表达式</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">我们可以一个接一个地添加表达式，做一系列操作，就像</span><br><span class="line">这样：DT<span class="punctuation">[</span>...<span class="punctuation">]</span><span class="punctuation">[</span>...<span class="punctuation">]</span><span class="punctuation">[</span>...<span class="punctuation">]</span>。也可以换行写：DT<span class="punctuation">[</span>... </span><br><span class="line">                              <span class="punctuation">]</span><span class="punctuation">[</span>...</span><br><span class="line">                                         <span class="punctuation">]</span><span class="punctuation">[</span>...</span><br><span class="line">                                          <span class="punctuation">]</span></span><br><span class="line">不会生成临时变量</span><br></pre></td></tr></table></figure><h3 id="SD语法"><a href="#SD语法" class="headerlink" title=".SD语法"></a>.SD语法</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">– .SD是Subset of Data的缩写。它自身就是一个data.table，包含通过by 分组后的每一组</span><br><span class="line"></span><br><span class="line">lapply函数和sapply函数相似 ，前者返回列表，后者返回向量</span><br></pre></td></tr></table></figure><h3 id="SDcols关键字"><a href="#SDcols关键字" class="headerlink" title=".SDcols关键字"></a><code>.SDcols</code>关键字</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">选取一些.SD中的一些变量，指定选取，即和.SD一块使用，.SD计算.SDcols选中的列</span><br></pre></td></tr></table></figure><h2 id="dataTable语义引用"><a href="#dataTable语义引用" class="headerlink" title="dataTable语义引用"></a><code>dataTable</code>语义引用</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">:=</span> 如果没有列那么会新增列，如果有会直接进行修改，删除元素直接将值进行<span class="literal">NULL</span>处理，相当于指针引用，会直接改变原来数据的值，要进行操作时候，考虑新加一列获得数据后赋值<span class="literal">NULL</span>，一般不使用copy函数进行拷贝</span><br></pre></td></tr></table></figure><h3 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a><code>copy</code>函数</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">操作符“<span class="operator">:=</span>”会更新原数据。当我们不想更新原数据时，可以用函数 copy<span class="punctuation">(</span><span class="punctuation">)</span>，深拷贝，一般不会使用，因为会影响内存使用</span><br></pre></td></tr></table></figure><h2 id="dataTable主键"><a href="#dataTable主键" class="headerlink" title="dataTable主键"></a><code>dataTable</code>主键</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">所有的data.frame都有一个行名的属性，但是行名是独一无二的而且每行都有</span><br><span class="line">所以data.table从不使用行名</span><br><span class="line"></span><br><span class="line">setkey<span class="punctuation">(</span>flights<span class="punctuation">,</span> origin） 设置主键，主键不强制唯一性</span><br><span class="line">       </span><br><span class="line">可以给函数setkey<span class="punctuation">(</span><span class="punctuation">)</span> 传入列名作为参数，不需要引号。这在交互式使用的时候特别方便。</span><br><span class="line">– 还可以给函数setkeyv<span class="punctuation">(</span><span class="punctuation">)</span> 传入一个列名向量，以便设置多个列名作为主键</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">一旦将某一列设置成data.table的主键，就可以在参数i里指定 .<span class="punctuation">(</span><span class="punctuation">)</span>来subset哪些主键了       </span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">key<span class="punctuation">(</span><span class="punctuation">)</span> 查找主键列</span><br><span class="line">获得被设置为data.table的主键的那一列的列名，使用函数 key<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">设置多个主键</span><br><span class="line">setkey<span class="punctuation">(</span>flights<span class="punctuation">,</span> origin<span class="punctuation">,</span> dest<span class="punctuation">)</span></span><br><span class="line">或：setkeyv<span class="punctuation">(</span>flights<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;origin&quot;</span><span class="punctuation">,</span><span class="string">&quot;dest&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="keyby"><a href="#keyby" class="headerlink" title="keyby"></a><code>keyby</code></h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">keyby<span class="punctuation">(</span>month<span class="punctuation">)</span></span><br><span class="line">使用参数keyby来自动将month设置为结果的主键。它使得结果不仅按month列排序，而且将month设置为主键：key<span class="punctuation">(</span>ans<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mult"><a href="#mult" class="headerlink" title="mult"></a><code>mult</code></h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">对于每次查询，可以通过参数mult，指定所有符合条件的行“<span class="built_in">all</span>”都被返回，还是只返回第一行“first”或者最后一行“last”。默认是所有的行“<span class="built_in">all</span>”</span><br></pre></td></tr></table></figure><h3 id="nomatch"><a href="#nomatch" class="headerlink" title="nomatch"></a><code>nomatch</code></h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">指定在没有找到符合条件的数据的情况下，是返回<span class="literal">NA</span>呢，还是跳过</span><br><span class="line">在经过挑选后，有的条件找不到，可以将他设置返回<span class="literal">NA</span>还是不返回</span><br></pre></td></tr></table></figure><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于主键设置的时候，会自动按照主键列进行排序，但是如果主键列顺序发生变化或者对主键列进行操作，那么会自动把主键删除掉</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">设置二级索引</span><br><span class="line">setindex（flights<span class="punctuation">,</span> orign）</span><br><span class="line"></span><br><span class="line">设置索引不会进行排序</span><br><span class="line">setindex<span class="punctuation">(</span>flights<span class="punctuation">,</span> <span class="literal">NULL</span><span class="punctuation">)</span>会删除所有的二级索引</span><br><span class="line">indices<span class="punctuation">(</span>flights<span class="punctuation">)</span>获取当前的索引</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">on语法设置成为索引</span><br><span class="line"></span><br><span class="line">flights<span class="punctuation">[</span><span class="string">&quot;JFK&quot;</span><span class="punctuation">,</span> on <span class="operator">=</span> <span class="string">&quot;origin&quot;</span><span class="punctuation">]</span></span><br><span class="line">不会把这个二级索引自动创建为data.table的一个属性</span><br></pre></td></tr></table></figure><h2 id="subset推荐语法on"><a href="#subset推荐语法on" class="headerlink" title="subset推荐语法on"></a><code>subset</code>推荐语法<code>on</code></h2><h1 id="ggplot2"><a href="#ggplot2" class="headerlink" title="ggplot2"></a><code>ggplot2</code></h1><h2 id="qplot"><a href="#qplot" class="headerlink" title="qplot"></a><code>qplot</code></h2><p><code>qplot</code>即quick plot 能快速对数据进行可视化分析</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qplot<span class="punctuation">(</span><span class="punctuation">)</span>前两个参数是x和y，分别代表图中所画对象的x坐标和y坐标。data参数可选，如果指定，那么qplot首先会在该数据框内查找变量名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qplot可以对颜色进行自动转换</span><br><span class="line">colour属性指定颜色</span><br><span class="line">alpha用来创建半透明的颜色，其取值从0（完全透明）到1（完全不透明）</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">geom参数来设置图的样式，eg<span class="operator">:</span>point散点图 smooth拟合平滑曲线 boxplot箱型图 path或line数据点间绘制连线</span><br><span class="line"></span><br><span class="line">geom可以传多个参数，eg<span class="operator">:</span>geom <span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;point&quot;</span><span class="punctuation">,</span><span class="string">&quot;smooth&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">一维变量——————————————————————————</span><br><span class="line">– 连续变量</span><br><span class="line">• geom <span class="operator">=</span> <span class="string">&quot;histogram&quot;</span> 直方图（一维数据默认选项）</span><br><span class="line">• geom <span class="operator">=</span> <span class="string">&quot;freqpoly&quot;</span> 频率多边形</span><br><span class="line">• geom <span class="operator">=</span> <span class="string">&quot;density&quot;</span> 密度曲线</span><br><span class="line">– 离散变量</span><br><span class="line">• geom <span class="operator">=</span> <span class="string">&quot;bar&quot;</span> 条形图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">geom <span class="operator">=</span> <span class="string">&quot;jittered&quot;</span> 扰动点图，相当于左右晃动，把重合点分开</span><br><span class="line">• 对于密度曲线图，adjust参数控制曲线平滑程度（取值越大越平滑）</span><br><span class="line">• 对于直方图，通过binwidth参数设定组距来调节平滑度。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">条形图 bar</span><br><span class="line">对于条形图，还可以加权进行绘制，weigh</span><br></pre></td></tr></table></figure><h3 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">除了利用颜色和形状来比较不同分组，还可以用分面：将数据分割成若干子集，然后创建一个图形的矩阵。</span><br><span class="line">• qplot<span class="punctuation">(</span><span class="punctuation">)</span>默认的分面方法是拆分成若干个窗格，通过形如facets <span class="operator">=</span> row<span class="operator">-</span>var <span class="operator">~</span> col_var的表达式进行指定。如果只想指定一行或一列，可以使用“.”作为占位符，例如row<span class="operator">-</span>var <span class="operator">~</span> .会创建一个单列多行的图形矩阵</span><br></pre></td></tr></table></figure><h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">xlim<span class="punctuation">,</span> ylim：设置x轴和y轴的显示区间，例如，xlim<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">)</span> 和 ylim<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">0.9</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line">• <span class="built_in">log</span>：<span class="built_in">log</span><span class="operator">=</span><span class="string">&quot;x&quot;</span> 表示对x轴取对数；<span class="built_in">log</span><span class="operator">=</span><span class="string">&quot;xy&quot;</span>表示对x轴和y轴都取对数。</span><br><span class="line">• main：图形主标题。可以是字符串也可以是数学表达式。</span><br><span class="line">• xlab<span class="punctuation">,</span> ylab：设置x和y轴的标签文字，可以是字符串或数学表达式</span><br></pre></td></tr></table></figure><h2 id="qplot理论基础"><a href="#qplot理论基础" class="headerlink" title="qplot理论基础"></a>qplot理论基础</h2>]]></content>
      
      
      <categories>
          
          <category> 学校学习 </category>
          
          <category> 东北大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学校学习 </tag>
            
            <tag> 东北大学 </tag>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待办清单</title>
      <link href="/posts/48081.html"/>
      <url>/posts/48081.html</url>
      
        <content type="html"><![CDATA[<h1 id="新增博客记录"><a href="#新增博客记录" class="headerlink" title="新增博客记录"></a>新增博客记录</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于自己太懒了，这个博客维护一直是有笔记才来维护，很长时间不来就容易忘记博客操作记录，索性直接记录在最前面得了，😄</span><br><span class="line">hexo <span class="keyword">new</span> <span class="title class_">back</span>/Linux/Docker复习 -p  back/Linux/Docker复习   </span><br><span class="line"></span><br><span class="line">博客头顶内容：</span><br><span class="line">    title: 个人博客搭建</span><br><span class="line">    date: <span class="number">2024</span>-<span class="number">12</span>-<span class="number">18</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">20</span></span><br><span class="line">    tags: </span><br><span class="line">        - 其他</span><br><span class="line">    categories: </span><br><span class="line">        - 其他</span><br><span class="line">    keywords: 个人博客搭建</span><br><span class="line">    description: hexo搭建个人博客，使用butterfly主题</span><br><span class="line">    top_img: /image/top/other/Personal-blog-building.png #顶部图片</span><br><span class="line">    cover: posts/<span class="number">24403</span>/Personal-blog-building.assets/hexo.png #封面图片</span><br><span class="line">    abbrlink: <span class="number">24403</span>（自动生成</span><br></pre></td></tr></table></figure><h2 id="运行记录"><a href="#运行记录" class="headerlink" title="运行记录"></a>运行记录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先生成一遍文件输入命令（blog目录下使用git）：hexo g</span><br><span class="line">自己本地运行指令启动hexo服务 hexo s</span><br><span class="line">部署到GitHub输入命令（blog目录下使用git）：hexo d</span><br></pre></td></tr></table></figure><h1 id="2024年记录"><a href="#2024年记录" class="headerlink" title="2024年记录"></a>2024年记录</h1><h2 id="博客初步搭建"><a href="#博客初步搭建" class="headerlink" title="博客初步搭建"></a>博客初步搭建</h2><ul><li><input checked="" disabled="" type="checkbox"> 初步搭建</li><li><input checked="" disabled="" type="checkbox"> 笔记文档上传一半，到学习文档，研0文档没上传</li><li><input disabled="" type="checkbox"> 研一文档后续上传</li><li><input checked="" disabled="" type="checkbox"> 搭建图床链接Git</li><li><input disabled="" type="checkbox"> 分类页面二级分类修改（修改成elementUI类型，但是还是有BUG，懒得改了，先放着吧）</li><li><input disabled="" type="checkbox"> 音乐吸附修改</li><li><input checked="" disabled="" type="checkbox"> 首页分类修改，主题变色时候修改，图标修改</li><li><input checked="" disabled="" type="checkbox"> 图片缓存懒加载</li><li><input disabled="" type="checkbox"> 博客体量太大，压缩博客</li></ul><h2 id="作业内容"><a href="#作业内容" class="headerlink" title="作业内容"></a>作业内容</h2><ul><li><input checked="" disabled="" type="checkbox"> 数据库大作业刘帅–结束于2025.01.10 00:00</li><li><input checked="" disabled="" type="checkbox"> 软件体系结构–2025年02月16日（周日）18:00时之前</li><li><input checked="" disabled="" type="checkbox"> 中国现代思想史专题–春季开学第一周</li></ul><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><ul><li><input checked="" disabled="" type="checkbox"> RabbitMQ 学习</li></ul><h1 id="2025年随意记录"><a href="#2025年随意记录" class="headerlink" title="2025年随意记录"></a>2025年随意记录</h1><h2 id="博客初步搭建-1"><a href="#博客初步搭建-1" class="headerlink" title="博客初步搭建"></a>博客初步搭建</h2><ul><li><input disabled="" type="checkbox"> 研一文档后续上传</li><li><input disabled="" type="checkbox"> 分类页面二级分类修改（修改成elementUI类型，但是还是有BUG，懒得改了，先放着吧）</li><li><input disabled="" type="checkbox"> 音乐吸附修改</li><li><input disabled="" type="checkbox"> 博客体量太大，压缩博客</li></ul><h2 id="其他内容-1"><a href="#其他内容-1" class="headerlink" title="其他内容"></a>其他内容</h2><ul><li><input checked="" disabled="" type="checkbox"> Redis 学习</li><li><input checked="" disabled="" type="checkbox"> Consul注册中心</li><li><input disabled="" type="checkbox"> Redis 原理篇学习，后续学习这个</li><li><input disabled="" type="checkbox"> 复习一下SpringCloudCloud 和nacos 20250714</li><li><input disabled="" type="checkbox"> 开始一步步实现项目吧</li></ul><h2 id="生活碎碎念"><a href="#生活碎碎念" class="headerlink" title="生活碎碎念"></a>生活碎碎念</h2><ul><li>🌚2025年4月25日:最近一直在忙项目课程，没怎么管理博客，后续进行管理吧，最近在跑组里的大模型。上周看的李荣浩演唱会，上传一张照片吧</li></ul><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425164556566-1b6139.png" alt="image-20250425164556566"></p><ul><li><p>2025年6月25号：实现年少的梦想吧，自己用自己的钱买了一台主机</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/image-20250713211439153-45cf78.png" alt="image-20250713211439153"></p></li><li><p>2025年7月13日:学完Redis，终于不用忙学习，可以干一点自己的事情了</p></li><li><p>2025年7月25日：CSGO成功进化为A车队！</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/26/image-20250726171735534-ee8b6d.png" alt="image-20250726171735534"></p></li><li><p>2025年7月26日：复习完mybatisPlus，准备回家（真懒学的真慢</p></li><li><p>2025年9月2日：复习完成Docker</p></li><li><p>2025年9月8号：学习consul注册中心</p></li><li><p>2025年9月29号：吃到正宗隰县雨露香梨<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/5cf27b62fb15d02cea4ba15c2c4e809b-1f2128.jpg" alt="5cf27b62fb15d02cea4ba15c2c4e809b"></p></li><li><p>2025年10月24号：学习校园音乐节看明星咯<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/a8e58b2f2c35173ac9ca62b6a6afde50-31dd31.jpg" alt="a8e58b2f2c35173ac9ca62b6a6afde50"></p></li><li><p>2025年11月29号：爬老君山<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/0e208e502aa854d5cde722da4eee04f9-59582a.jpg" alt="0e208e502aa854d5cde722da4eee04f9"></p></li><li><p>2025年12月28号：鹳雀楼<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/2d83c27f0c9e223c2e22b53e2a40b037-7bd1ca.jpg" alt="2d83c27f0c9e223c2e22b53e2a40b037"></p></li><li><p>2025年12月30号：壶口瀑布+小西天+自驾游<img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/7c0e2aca503c95280bddc7d5094d45e5-4c713b.jpg" alt="7c0e2aca503c95280bddc7d5094d45e5"></p></li><li><p>2026年1月1-3：河南郑州建业小镇+海昌海洋公园+万岁山</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/badfcaeb429995d9a76bdbd7faee9155-df724f.jpg" alt="badfcaeb429995d9a76bdbd7faee9155"></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/7a60b8a6afa2396a22e81047c7594049-05c0ac.jpg" alt="7a60b8a6afa2396a22e81047c7594049"><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2026/01/05/006e6f86727ba40791b801e225094963-d6cf4e.jpg" alt="006e6f86727ba40791b801e225094963"></p></li><li><p>2026年1月5号：Langchain4j学习完成</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待办清单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/posts/52913.html"/>
      <url>/posts/52913.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>springsecurity是安全框架，准确来说是安全管理框架。相比与另外一个安全框架Shiro，springsecurity提供了更丰富的功能，社区资源也比Shiro丰富</p><p>springsecurity框架用于Web应用的需要进行认证和授权</p><p>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</p><p>授权：经过认证后判断当前用户是否有权限进行某个操作。认证和授权也是SpringSecurity作为安全框架的核心功能</p><p>认证和授权也是SpringSecurity作为安全框架的核心功能</p><p>笔记保存</p><p><a href="https://www.yuque.com/huanfqc/springsecurity/springsecurity#HizsM">https://www.yuque.com/huanfqc/springsecurity/springsecurity#HizsM</a></p><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><h2 id="搭建正常的maven项目"><a href="#搭建正常的maven项目" class="headerlink" title="搭建正常的maven项目"></a>搭建正常的maven项目</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引入security依赖"><a href="#引入security依赖" class="headerlink" title="引入security依赖"></a>引入security依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登录页面，默认用户名是user,密码会输出在控制台。必须登录之后才能对接口进行访问</span><br><span class="line">http://localhost:8080/login 登录进入后才能进行自己想要的操作</span><br><span class="line">http://localhost:8080/logout 点击登出，那么登录状态就会消失</span><br></pre></td></tr></table></figure><h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h1><p>​流程图如下，注意下图的jwt指的是 json web token，jwt是登录校验的时候用的技术，可以根据指定的算法进行信息的加密和解密</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241014165901166-275bad.png" alt="image-20241014165901166"></p><h2 id="springsecurity原理"><a href="#springsecurity原理" class="headerlink" title="springsecurity原理"></a>springsecurity原理</h2><p>​SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。例如快速入门案例里面使用到的三种过滤器，</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241014170155814-474f14.png" alt="image-20241014170155814"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UsernamePasswordAuthenticationFilter: 负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责</span><br><span class="line">ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException</span><br><span class="line">FilterSecurityInterceptor：负责权限校验的过滤器</span><br><span class="line">注意上图，橙色部分表示认证，黄色部分表示异常处理，红色部分表示授权</span><br><span class="line"></span><br><span class="line">实际上中间省略了很多过滤操作</span><br></pre></td></tr></table></figure><h3 id="自己进行Debug查询过滤器"><a href="#自己进行Debug查询过滤器" class="headerlink" title="自己进行Debug查询过滤器"></a>自己进行Debug查询过滤器</h3><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241014170853165-eb01d2.png" alt="image-20241014170853165"><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241014171012213-2e7076.png" alt="image-20241014171012213"></p><h2 id="认证流程-1"><a href="#认证流程-1" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241014171154041-46ffa6.png" alt="image-20241014171154041"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">springsecurity原理&#x27; 的橙色部分，也就是认证那部分的知识</span><br><span class="line"></span><br><span class="line">一、Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息</span><br><span class="line">二、AuthenticationManager 接口：定义了认证Authentication的方法</span><br><span class="line">三、UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法</span><br><span class="line">四、UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中</span><br></pre></td></tr></table></figure><h1 id="自定义流程"><a href="#自定义流程" class="headerlink" title="自定义流程"></a>自定义流程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 &#x27;快速入门&#x27; 中，我们在Boot项目里面引入了Security依赖，实现了当我们访问某个业务接口时，会被Security的login接口拦截，但是如果我们不想使用Security默认的登录页面，那么怎么办呢，还有，springsecurity的校验，我们希望是根据数据库来做校验，那么怎么实现呢。我们需要实现如下</span><br><span class="line">【登录-未实现】</span><br><span class="line">1、自定义登录接口。用于调用ProviderManager的方法进行认证 如果认证通过生成jwt，然后把用户信息存入redis中</span><br><span class="line">2、自定义UserDetailsService接口的实现类。在这个实现类中去查询数据库</span><br><span class="line">【校验-未实现】</span><br><span class="line">1、定义Jwt认证过滤器。用于获取token，然后解析token获取其中的userid，还需要从redis中获取用户信息，然后存入SecurityContextHolder</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>自定义登录接口</strong></li></ol><p>调用<code>ProviderManager</code>的方法进行认证 如果认证通过生成jwt</p><p>把用户信息存入redis中</p><blockquote><p><code>SpringSecurity</code>在默认的认证过程中如果账号密码校验成功会返回Authentication对象之后<code>UsernamePasswordAuthenticationFilter</code>会将用户信息<code>Authentication</code>存入<code>SecurityContextHolder</code>中</p><p>但是我们在实际运用场景中认证通过后还需要向前端返回一个JSON格式的数据里面包括了JWT</p><p>所以此时我们需要写一个自定义登录接口</p></blockquote><ol start="2"><li><strong>自定义UserDetailsService接口</strong></li></ol><p>在这个实现类中去查询数据库</p><p>校验：</p><p>定义Jwt认证过滤器</p><p>获取token</p><p>解析token获取其中的userid</p><p>从redis中获取用户信息</p><p>存入SecurityContextHolder</p><blockquote><p><code>SpringSecurity</code> 默认是在内存中查找对应的用户名密码然后封装成<code>UserDetai</code>l对象交给<code>DaoAuthenticationProcider</code>校验</p><p>但是我们在实际运用场景中是从数据库中查找用户信息</p><p>所以此时我们需要写一个<code>UserDetailsService</code>的实现类用来在数据库中查询用户信息并且封装到<code>UserDetai</code>l对象中</p></blockquote><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!--fastjson依赖--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!--jwt依赖--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">&lt;!--引入Lombok依赖，方便实体类开发--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加入相关工具类"><a href="#加入相关工具类" class="headerlink" title="加入相关工具类"></a>加入相关工具类</h3><h3 id="自定义security实现"><a href="#自定义security实现" class="headerlink" title="自定义security实现"></a>自定义security实现</h3><p><code>SpringSecurity</code> 默认是在内存中查找对应的用户名密码然后<code>UserDetailsService</code>的默认实现类使用封装成<code>UserDetai</code>l对象交给<code>DaoAuthenticationProcider</code>校验</p><p>但是我们在实际运用场景中是从数据库中查找用户信息</p><p>所以此时我们需要写一个<code>UserDetailsService</code>的实现类用来在数据库中查询用户信息并且封装到<code>UserDetai</code>l对象中</p><p>并且需要写一个<code>UserDetai</code>的实现类因为用户信息不仅仅只有用户名和密码还有其他信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">思路: 只需要新建一个实现类，在这个实现类里面实现Security官方的UserDetailsService接口，然后重写里面的loadUserByUsername方法</span><br><span class="line"></span><br><span class="line">注意: 重写好loadUserByUsername方法之后，我们需要把拿到 &#x27;数据库与用户输入的数据&#x27; 进行比对的结果，也就是user对象这个结果封装成能被 &#x27;Security官方的UserDetailsService接口&#x27; 接收的类型，例如可以封装成我们下面写的LoginUser类型。然后才能伪装好数据，给Security官方的认证机制去对比user对象与数据库的结果是否匹配。Security官方的认证机制会拿LoginUser类的方法数据(数据库拿，不再用默认的)，跟我们封装过去的user对象进行匹配，要使匹配一致，就证明认证通过，也就是用户在浏览器页面输入的用户名和密码能被Security认证通过，就不再拦截该用户去访问我们的业务接口</span><br><span class="line"></span><br><span class="line">MyUserDetailServiceImpl被标记为“@Service”,它会被Spring容器管理， 当Spring Security需要进行用户认证时，它会自动查找已经被Spring扫描并管理的MyUserDetailServiceImpl实例，并使用它来处理认证请求。  </span><br></pre></td></tr></table></figure><ol><li>构建UserDetailsServiceImpl 继承UserDetailsService，实现未实现的方法loadUserByUsername</li><li>实现loginUser 实现UserDetails，对里面内容进行修改，以及方法继承</li><li>进行测试</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意这里没有实现密码加密功能默认是报错的，所以需要对数据库进行&#123;noop&#125;12345  这样存储，提醒密码是明文存储</span><br></pre></td></tr></table></figure><h2 id="密码加密存储"><a href="#密码加密存储" class="headerlink" title="密码加密存储"></a>密码加密存储</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringSecurity默认的密码校验，替换为SpringSecurity为我们提供的BCryptPasswordEncoder</span><br><span class="line">我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。(版本问题，有的版本没有WebSecurityConfigurerAdapter类了，不需要继承，其余步骤一样也是可以使用的)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//实现Security提供的WebSecurityConfigurerAdapter类，就可以改变密码校验的规则了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验</span></span><br><span class="line">    <span class="comment">//注意也可以注入PasswordEncoder，效果是一样的，因为PasswordEncoder是BCry..的父类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 创建SpringSecurity自带的编码器，然后用Bean类型进行注入，那么容器会自动识别并且进行替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: curry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2024/10/14 21:01</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JWT加密"><a href="#JWT加密" class="headerlink" title="JWT加密"></a>JWT加密</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jwt依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="构建JWTutils"><a href="#构建JWTutils" class="headerlink" title="构建JWTutils"></a>构建JWTutils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 35238</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/11 0011 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//JWT工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效期为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">JWT_TTL</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000L</span>;<span class="comment">// 60 * 60 *1000  一个小时</span></span><br><span class="line">    <span class="comment">//设置秘钥明文, 注意长度必须大于等于6位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_KEY</span> <span class="operator">=</span> <span class="string">&quot;CURRYS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUUID</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, <span class="literal">null</span>, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis token超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JwtBuilder <span class="title function_">getJwtBuilder</span><span class="params">(String subject, Long ttlMillis, String uuid)</span> &#123;</span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line">        <span class="keyword">if</span>(ttlMillis==<span class="literal">null</span>)&#123;</span><br><span class="line">            ttlMillis=JwtUtil.JWT_TTL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setId(uuid)              <span class="comment">//唯一的ID</span></span><br><span class="line">                .setSubject(subject)   <span class="comment">// 主题  可以是JSON数据</span></span><br><span class="line">                .setIssuer(<span class="string">&quot;curry&quot;</span>)     <span class="comment">// 签发者</span></span><br><span class="line">                .setIssuedAt(now)      <span class="comment">// 签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey) <span class="comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span></span><br><span class="line">                .setExpiration(expDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 加密数据（支持JSON数据）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, id);<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数据加密</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> createJWT(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        System.out.println(jwt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数据解密</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseJWT(jwt);</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> claims.getSubject();</span><br><span class="line">        System.out.println(claims);</span><br><span class="line">        System.out.println(subject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密后的秘钥 secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title function_">generalKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span> id id</span><br><span class="line">    * <span class="meta">@param</span> subject 加密数据（支持JSON数据）</span><br><span class="line">    * <span class="meta">@param</span> ttlMillis 过期时间</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 数据加密</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> createJWT(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">       System.out.println(jwt);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 数据解密</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseJWT(jwt);</span><br><span class="line">       <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> claims.getSubject();</span><br><span class="line">       System.out.println(claims);</span><br><span class="line">       System.out.println(subject);</span><br></pre></td></tr></table></figure><h2 id="登录接口实现"><a href="#登录接口实现" class="headerlink" title="登录接口实现"></a>登录接口实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①我们需要自定义登陆接口，也就是在controller目录新建LoginController类，在controller方法里面去调用service接口，在service接口实现AuthenticationManager去进行用户的认证，注意，我们定义的controller方法要让SpringSecurity对这个接口放行(如果不放行的话，会被SpringSecurity拦截)，让用户访问这个接口的时候不用登录也能访问。</span><br><span class="line"></span><br><span class="line">②在service接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器</span><br><span class="line"></span><br><span class="line">③认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。</span><br></pre></td></tr></table></figure><p>自定义登录接口，让SpringSecurity对这个接口放行，然后进行认证判断等相关操作</p><ol><li><p>书写正常的controller以及Service，在SecurityConfig中重写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自己重写登录管理的管理</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在ServiceImpl中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。同时会默认进行验证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  进行用户认证</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *  进行认证操作，最后会调用到loadUserByUsername这个方法，去进行用户校验</span></span><br><span class="line"><span class="comment">        *  在登录界面输入的账号和密码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">usernamePasswordAuthenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserName(), user.getPassword());</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(usernamePasswordAuthenticationToken);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这里其实调用了UserDetailsServiceImpl里面的方法，所以返回的是UserDetail类，LoginUser</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果认证没通过 authenticate为null</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="keyword">if</span> (Objects.isNull(authenticate)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果认证通过，就使用userid生成一个jwt，然后把jwt存入ResponseResult后返回</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">       <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br></pre></td></tr></table></figure></li><li><p>认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key</p></li></ol><p></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">      <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">      <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果认证通过 authenticate不为null</span></span><br><span class="line"><span class="comment">       * ，通过USERID生成一个JWT JWT存入</span></span><br><span class="line"><span class="comment">       * 完整用户信息存入redis userid作为ID</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;token&quot;</span>, jwt);</span><br><span class="line">      redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span> + userId, loginUser.getUser());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>&lt;Map&lt;String, String&gt;&gt;(<span class="number">200</span>, <span class="string">&quot;登陆成功&quot;</span>,map);</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在进行放行的过程中，需要进行配置，在SecurityConfig中配置相关属性</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//由于是前后端分离项目，所以要关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//由于是前后端分离项目，所以session是失效的，我们就不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//指定让spring security放行登录接口的规则</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 anonymous表示允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="认证过滤器"><a href="#认证过滤器" class="headerlink" title="认证过滤器"></a>认证过滤器</h2><ol><li>需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。(主要作用于除登录外的请求)</li><li>使用userid去redis中获取对应的LoginUser对象。</li><li>然后封装Authentication对象存入SecurityContextHolder</li><li>将这个过滤器加到指定过滤器前面</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OncePerRequestFilter特点是在处理单个HTTP请求时确保过滤器的 doFilterInternal 方法只被调用一次</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  获取token，指定你要获取的请求头叫什么</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断token是否为空</span></span><br><span class="line"><span class="comment">         *  判空，不一定所有的请求都有请求头，所以上面那行的token可能为空</span></span><br><span class="line"><span class="comment">         *  !StringUtils.hasText()方法用于检查给定的字符串是否为空或仅包含空格字符</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasText(token))&#123;</span><br><span class="line">            <span class="comment">//没有token放行 此时的SecurityContextHolder没有用户信息 会被后面的过滤器拦截</span></span><br><span class="line">            filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 之所以要return，是因为doFilter前后语句是两个执行，doFilter前执行的是httpServletRequest，当获取到httpServletResponse会继续执行后面的语句，所以需要return不需要执行</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = JwtUtil.parseJWT(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//解析失败</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                httpServletResponse.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">                httpServletResponse.getWriter().write(<span class="string">&quot;Unauthorized access&quot;</span>);</span><br><span class="line">                httpServletResponse.getWriter().flush();</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> claims.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取到userId后可以通过Redis获取用户信息,这个函数是泛型函数，所以可以直接转换</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span> + userId;</span><br><span class="line">        <span class="type">User</span> <span class="variable">User</span> <span class="operator">=</span> redisCache.getCacheObject(key);</span><br><span class="line">        <span class="comment">//此处需要判断loginUser是否为空</span></span><br><span class="line">        <span class="comment">//判断获取到的用户信息是否为空，因为redis里面可能并不存在这个用户信息，例如缓存过期了</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(User))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最终的LoginUser用户信息，通过setAuthentication方法，存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="comment">//第一个参数是LoginUser用户信息，第二个参数是凭证(null)，第三个参数是权限信息(null)</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">usernamePasswordAuthenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(User, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);</span><br><span class="line">        filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>把token校验过滤器添加到过滤器链中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      http</span><br><span class="line">              <span class="comment">//由于是前后端分离项目，所以要关闭csrf</span></span><br><span class="line">              .csrf().disable()</span><br><span class="line">              <span class="comment">//由于是前后端分离项目，所以session是失效的，我们就不通过Session获取SecurityContext</span></span><br><span class="line">              .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">              .and()</span><br><span class="line">              <span class="comment">//指定让spring security放行登录接口的规则</span></span><br><span class="line">              .authorizeRequests()</span><br><span class="line">              <span class="comment">// 对于登录接口 anonymous表示允许匿名访问</span></span><br><span class="line">              .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">              <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">              .anyRequest().authenticated();</span><br><span class="line">      <span class="comment">//---------------------------认证过滤器的实现----------------------------------</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">      <span class="comment">//第一个参数是上面注入的我们在filter目录写好的类，第二个参数表示你想添加到哪个过滤器之前</span></span><br><span class="line">      http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><p>我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ResponseResult <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取我们在JwtAuthenticationTokenFilter类写的SecurityContextHolder对象中的用户id</span></span><br><span class="line">      <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> (UsernamePasswordAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//loginUser是我们在domain目录写好的实体类</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">      <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> user.getId();</span><br><span class="line">      <span class="comment">//根据用户id，删除redis中的token值，注意我们的key是被 login: 拼接过的，所以下面写完整key的时候要带上 longin:</span></span><br><span class="line">      redisCache.deleteObject(<span class="string">&quot;login:&quot;</span>+id);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="授权基本流程"><a href="#授权基本流程" class="headerlink" title="授权基本流程"></a>授权基本流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</span><br><span class="line"></span><br><span class="line">只需要把当前登录用户的权限信息也存入Authentication</span><br><span class="line"></span><br><span class="line">然后设置我们的资源所需要的权限即可。</span><br></pre></td></tr></table></figure><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><h3 id="限制访问资源所需权限"><a href="#限制访问资源所需权限" class="headerlink" title="限制访问资源所需权限"></a>限制访问资源所需权限</h3><blockquote><p>SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以</p><p>使用注解去指定访问对应的资源所需的权限。</p><p>但是要使用它我们需要先开启相关配置。</p></blockquote><p>(com.sangeng.config.SecurityConfig)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br></pre></td></tr></table></figure><blockquote><p>然后就可以使用对应的注解。@PreAuthorize</p></blockquote><p>(com.sangeng.controller.HelloController)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装权限信息"><a href="#封装权限信息" class="headerlink" title="封装权限信息"></a>封装权限信息</h3><p>​写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。先直接把权限信息写死封装到UserDetails中进行测试。之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 存储权限信息</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 存储真正返回的权限信息</span></span><br><span class="line"><span class="comment">   * 同时在redis进行存储过程中，要忽略序列化，不忽略会进行报错处理</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回权限信息，当使用权限后再用</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">      <span class="keyword">if</span> (authorities != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> authorities;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (permissions == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      authorities = permissions.stream().</span><br><span class="line">              map(SimpleGrantedAuthority::<span class="keyword">new</span>).</span><br><span class="line">              collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> authorities;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意这里有两点注意，一点是authorities这个集合必须要加上注解表示不被序列化，因为Redis存储过程中如果序列化会报错；第二点是返回对象名字必须是authorities，否则也会序列化报错</p><p>之后依次在进行查询数据库进行对比匹配过程中将权限信息存储进去，同时在Redis时候把信息读取出来保存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">usernamePasswordAuthenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(User, <span class="literal">null</span>, User.getAuthorities());</span><br><span class="line">      SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);</span><br></pre></td></tr></table></figure><h3 id="从数据库查询权限信息"><a href="#从数据库查询权限信息" class="headerlink" title="从数据库查询权限信息"></a>从数据库查询权限信息</h3><p>RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。主要通过对下面表的查询从而分析到相应的权限，由于都是N对N的所以有个中间表进行关联比较简单。</p><p>该模型由以下五个主要组成部分构成:<br>一、用户: 在系统中代表具体个体的实体，可以是人员、程序或其他实体。用户需要访问系统资源<br>二、角色: 角色是权限的集合，用于定义一组相似权限的集合。角色可以被赋予给用户，从而授予用户相应的权限<br>三、权限: 权限表示系统中具体的操作或功能，例如读取、写入、执行等。每个权限定义了对系统资源的访问规则<br>四、用户-角色映射: 用户-角色映射用于表示用户与角色之间的关系。通过为用户分配适当的角色，用户可以获得与角色相关联的权限<br>五、角色-权限映射: 角色-权限映射表示角色与权限之间的关系。每个角色都被分配了一组权限，这些权限决定了角色可执行的操作</p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241016215656569-58fca7.png" alt="image-20241016215656569"></p><p>实现来讲比较简单，实际上就是把上面写死的权限写成自己设计的权限</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------------------------查询用户权限信息----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于我们自定义了3个权限，所以用List集合存储。注意权限实际就是&#x27;有特殊含义的字符串&#x27;，所以下面的三个字符串就是自定义的</span></span><br><span class="line"><span class="comment">//下面那行就是我们的权限集合，等下还要在LoginUser类做权限集合的转换</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//list.add(&quot;user&quot;);</span></span><br><span class="line"><span class="comment">//上面那行的list就不用死数据啦，我们用下面那行的list，是数据库获取到的权限字符串信息的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------查询来自数据库的权限信息--------------------------------</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = menuDao.selectPermsByUserId(user.getId());</span><br></pre></td></tr></table></figure><p>然后去实现相关接口和类即可</p><h1 id="自定义异常处理（不建议还是–）"><a href="#自定义异常处理（不建议还是–）" class="headerlink" title="自定义异常处理（不建议还是–）"></a>自定义异常处理（不建议还是–）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常，其中有如下两种情况</span><br><span class="line">一、如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。</span><br><span class="line">二、如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。</span><br><span class="line">总结: 如果我们需要自定义异常处理，我们只需要创建AuthenticationEntryPoint和AccessDeniedHandler的实现类对象，然后配置给SpringSecurity即可</span><br></pre></td></tr></table></figure><h2 id="com-sangeng-handler"><a href="#com-sangeng-handler" class="headerlink" title="(com.sangeng.handler)"></a>(com.sangeng.handler)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//这个类只处理认证异常，不处理授权异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//第一个参数是请求对象，第二个参数是响应对象，第三个参数是异常对象。把异常封装成授权的对象，然后封装到handle方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//ResponseResult是我们在domain目录写好的实体类。HttpStatus是spring提供的枚举类，UNAUTHORIZED表示401状态码</span></span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;用户认证失败，请重新登录&quot;</span>);</span><br><span class="line">        <span class="comment">//把上面那行拿到的result对象转换为JSON字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        <span class="comment">//WebUtils是我们在utils目录写好的类</span></span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//这个类只处理授权异常，不处理认证异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//第一个参数是请求对象，第二个参数是响应对象，第三个参数是异常对象。把异常封装成认证的对象，然后封装到handle方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//ResponseResult是我们在domain目录写好的实体类。HttpStatus是spring提供的枚举类，FORBIDDEN表示403状态码</span></span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;您没有权限进行访问&quot;</span>);</span><br><span class="line">        <span class="comment">//把上面那行拿到的result对象转换为JSON字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        <span class="comment">//WebUtils是我们在utils目录写好的类</span></span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a><strong>修改配置类</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">// 开启Spring Security的功能 代替了 implements WebSecurityConfigurerAdapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AuthenticationConfiguration authenticationConfiguration;<span class="comment">//获取AuthenticationManager</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccessDeniedHandlerImpl accessDeniedHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AuthenticationEntryPointImpl authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> authenticationConfiguration.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置Spring Security的过滤链。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http 用于构建安全配置的HttpSecurity对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回配置好的SecurityFilterChain对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 如果配置过程中发生错误，则抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//由于是前后端分离项目，所以要关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//由于是前后端分离项目，所以session是失效的，我们就不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//指定让spring security放行登录接口的规则</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 anonymous表示允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---------------------------认证过滤器的实现----------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">        <span class="comment">//第一个参数是上面注入的我们在filter目录写好的类，第二个参数表示你想添加到哪个过滤器之前</span></span><br><span class="line">        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---------------------------异常处理的相关配置-------------------------------</span></span><br><span class="line">        </span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">                <span class="comment">//配置认证失败的处理器</span></span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                <span class="comment">//配置授权失败的处理器</span></span><br><span class="line">                .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于我们的SpringSecurity负责所有请求和资源的管理，当请求经过SpringSecurity时，如果SpringSecurity不允许跨域，那么也是会被拦截，所以下面我们将学习并解决跨域问题。前面我们在测试时，是在postman测试，因此没有出现跨域问题的情况，postman只是负责发请求跟浏览器没关系</span><br><span class="line">浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、开启SpringBoot的允许跨域访问</span><br><span class="line">2、开启SpringSecurity的允许跨域访问(实际测试这个没用)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    //重写spring提供的WebMvcConfigurer接口的addCorsMappings方法</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        // 设置允许跨域的路径</span><br><span class="line">        registry.addMapping(&quot;/**&quot;)</span><br><span class="line">                // 设置允许跨域请求的域名</span><br><span class="line">                .allowedOriginPatterns(&quot;*&quot;)</span><br><span class="line">                // 是否允许cookie</span><br><span class="line">                .allowCredentials(true)</span><br><span class="line">                // 设置允许的请求方式</span><br><span class="line">                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)</span><br><span class="line">                // 设置允许的header属性</span><br><span class="line">                .allowedHeaders(&quot;*&quot;)</span><br><span class="line">                // 跨域允许时间</span><br><span class="line">                .maxAge(3600);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">        //---------------------------👇 设置security运行跨域访问 👇------------------</span><br><span class="line"></span><br><span class="line">        http.cors();</span><br><span class="line"></span><br><span class="line">        //---------------------------👆 设置security运行跨域访问 👆------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h1><h2 id="其他权限校验"><a href="#其他权限校验" class="headerlink" title="其他权限校验"></a>其他权限校验</h2><p>前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。</p><p>SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p><p>hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知</p><p>道它内部的校验原理。</p><p>它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法</p><p>参数数据在权限列表中</p><p>hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所</p><p>以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以</p><p>这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义权限校验"><a href="#自定义权限校验" class="headerlink" title="自定义权限校验"></a>自定义权限校验</h2><p>security校验权限的PreAuthorize注解，其实就是获取用户权限，然后跟业务接口的权限进行比较，最后返回一个布尔类型。自定义一个权限校验方法的话，就需要新建一个类，在类里面定义一个方法，按照前面学习的三种方法的定义格式，然后返回值是布尔类型。如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;EX&quot;)</span></span><br><span class="line"><span class="comment">//自定义权限校验的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuanfExpressionRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义权限校验的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">huanfHasAuthority</span><span class="params">(String authority)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取用户具有的权限字符串，有可能用户具有多个权限字符串，所以获取后是一个集合</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="comment">//LoginUser是我们在domain目录写好的实体类</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        List&lt;String&gt; xxpermissions = loginUser.getXxpermissions();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户权限集合中，是否存在跟业务接口(业务接口的权限字符串会作为authority形参传进来)一样的权限</span></span><br><span class="line">        <span class="keyword">return</span> xxpermissions.contains(authority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@huanfEX.huanfHasAuthority(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;欢迎，开始你新的学习旅程吧&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     http</span><br><span class="line">             <span class="comment">//由于是前后端分离项目，所以要关闭csrf</span></span><br><span class="line">             .csrf().disable()</span><br><span class="line">             <span class="comment">//由于是前后端分离项目，所以session是失效的，我们就不通过Session获取SecurityContext</span></span><br><span class="line">             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">             .and()</span><br><span class="line">             <span class="comment">//指定让spring security放行登录接口的规则</span></span><br><span class="line">             .authorizeRequests()</span><br><span class="line">             <span class="comment">// 对于登录接口 anonymous表示允许匿名访问</span></span><br><span class="line">             .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//基于配置的的权限控制。指定接口的地址，为HelloController类里面的/configAuth接口，指定权限为system:dept:list</span></span><br><span class="line">             .antMatchers(<span class="string">&quot;/configAuth&quot;</span>).hasAuthority(<span class="string">&quot;system:dept:list&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键点是下面：</span><br><span class="line">             <span class="comment">//基于配置的的权限控制。指定接口的地址，为HelloController类里面的/configAuth接口，指定权限为system:dept:list</span></span><br><span class="line">             .antMatchers(<span class="string">&quot;/configAuth&quot;</span>).hasAuthority(<span class="string">&quot;system:dept:list&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一，如图</p><p><a href="https://blog.csdn.net/freeking101/article/details/86537087">https://blog.csdn.net/freeking101/article/details/86537087</a></p><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241017220020673-503518.png" alt="image-20241017220020673"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">防护: SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问</span><br><span class="line">我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了，前后端分离的项目，在配置类关闭csrf就能防范csrf攻击</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="/posts/24403.html"/>
      <url>/posts/24403.html</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node.js 安装</span><br><span class="line">输入node -v和npm -v。如果正确安装，命令行将分别显示已安装的 Node.js 版本号和 npm（Node.js 的包管理工具）版本号。</span><br><span class="line">Git 安装</span><br><span class="line">在命令行中输入git --version，若显示 Git 的版本信息，则表明安装成功</span><br></pre></td></tr></table></figure><h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新建一个仓库</span><br><span class="line">创建一个和你用户名相同的仓库，后面加.github.io后缀，必须要同名哦，不然后面会出现页面<span class="number">404</span>的情况，点击create respository按钮创建。</span><br></pre></td></tr></table></figure><p><img src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20241217144555145-2fadb1.png" alt="image-20241217144555145"></p><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建SSH</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;860211327@qq.com&quot;</span>(你的邮箱）</span><br><span class="line"></span><br><span class="line">将生成的内容绑定到git的SSH上面</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">验证： </span><br><span class="line">输入命令（git）：ssh -T git<span class="meta">@github</span>.com 并且输入yes之后，行末尾会显示你的用户名</span><br><span class="line"></span><br><span class="line">（绑定成功邮箱会收到邮件提醒）</span><br><span class="line"></span><br><span class="line">接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class="line">输入命令：git config --global user.name “注册时用户名”</span><br><span class="line">输入命令：git config --global user.email “注册时邮箱”</span><br></pre></td></tr></table></figure><h1 id="安装HEXO"><a href="#安装HEXO" class="headerlink" title="安装HEXO"></a>安装HEXO</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">确保node安装完成</span><br><span class="line"></span><br><span class="line">全局安装 hexo</span><br><span class="line">npm  i  hexo-cli -g</span><br><span class="line"></span><br><span class="line">在对应位置初始化一个项目</span><br><span class="line">hexo  init blog</span><br><span class="line">    </span><br><span class="line">进入项目文件夹，安装依赖文件</span><br><span class="line">cd  blog</span><br><span class="line">npm  install</span><br><span class="line">    </span><br><span class="line">运行，并且在浏览器打开，就可以看到博客页面了</span><br><span class="line"></span><br><span class="line">hexo server</span><br><span class="line">http:<span class="comment">//localhost:4000</span></span><br><span class="line"></span><br><span class="line">修改主题</span><br><span class="line">https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重新启动hexo服务</span><br><span class="line">hexo s</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">hexo clean <span class="comment">//清除hexo缓存</span></span><br><span class="line">hexo g     <span class="comment">//重新生成hexo</span></span><br><span class="line">hexo s     <span class="comment">//运行本地服务器</span></span><br><span class="line">hexo d     <span class="comment">//将hexo推送到设置好的服务器上</span></span><br><span class="line">hexo <span class="keyword">new</span>   <span class="title class_">xxx</span> <span class="comment">//新建博文</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="title class_">page</span> xxx <span class="comment">//新建页面</span></span><br><span class="line"></span><br><span class="line">博文新建好会存到/&lt;博客根目录&gt;/souce/_post中</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化完成后，博客目录下会出现以下主要的目录和文件：</p><ul><li>config.yml：这是 Hexo 的核心配置文件，整个博客的各种设置都在这里完成。它是一个 YAML 格式的文件，通过简单的键值对来配置博客的参数，包括博客的标题、副标题、作者、语言、主题、插件等众多设置。例如，title字段用于设置博客的标题</li><li>subtitle字段用于设置副标题，author字段填写作者姓名，language字段可以指定博客使用的语言，如en（英语）、zh-CN（中文简体）等。</li><li>source：这个目录是用户创建博客文章和页面的源文件存放处。默认情况下，我们使用 Markdown 格式来撰写文章。在这个目录下创建的 Markdown 文件将被 Hexo 解析并转换为网页内容。例如，您可以在source&#x2F;posts子目录下创建新的博客文章文件。</li><li>themes：存放博客主题文件的目录。Hexo 有大量丰富多样的开源主题可供选择，每个主题都有其独特的设计风格和功能。不同的主题可以让您的博客呈现出完全不同的外观和交互体验。</li><li>public：这个目录用于存放 Hexo 根据source目录中的内容和_config.yml的配置生成的静态文件。这些静态文件包括 HTML、CSS、JavaScript 等，它们将被部署到服务器（如 GitHub）上，供用户通过浏览器访问。</li><li>此外，还有其他一些辅助文件和文件夹，如scaffolds用于生成文章或页面的模板，package.json用于管理项目的依赖等</li></ul><h2 id="换主题"><a href="#换主题" class="headerlink" title="换主题"></a>换主题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">安装主题</span><br><span class="line">cd themes</span><br><span class="line">git clone git<span class="meta">@github</span>.com:theme-particlex/hexo-theme-particlex.git particlex --depth=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 修改默认主题</span><br><span class="line">在根目录 _config.yml 设置主题为 ParticleX 即可</span><br></pre></td></tr></table></figure><h2 id="主题换完后，上传GIT"><a href="#主题换完后，上传GIT" class="headerlink" title="主题换完后，上传GIT"></a>主题换完后，上传GIT</h2><p>安装上传工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">        type: git</span><br><span class="line">        repo: https:<span class="comment">//github.com/用户名/用户名.github.io.git</span></span><br><span class="line"></span><br><span class="line">                    （或者git<span class="meta">@github</span>.com:用户名/用户名.github.io.git）【推荐】</span><br><span class="line">        branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="之后上传顺序"><a href="#之后上传顺序" class="headerlink" title="之后上传顺序"></a>之后上传顺序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新建文章(不新建的话也会有一篇自带的Hello World文章)</span><br><span class="line"></span><br><span class="line">输入命令：hexo <span class="keyword">new</span> “文章名称”</span><br><span class="line"></span><br><span class="line">然后根据返回的地址即可找到创建的文件位置，即可使用编辑器打开编辑（推荐使用vscode或者typora）</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">预览</span><br><span class="line">输入命令（blog目录下使用git）：hexo s（如上）</span><br><span class="line">确认无误后先生成一遍文件</span><br><span class="line">输入命令（blog目录下使用git）：hexo g</span><br><span class="line">b重新启动hexo服务</span><br><span class="line">hexo s</span><br><span class="line">之后即可部署到GitHub</span><br><span class="line">输入命令（blog目录下使用git）：hexo d</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">此时再浏览器输入：用户名.github.io(Github仓库名)就可以访问博客啦</span><br></pre></td></tr></table></figure><h1 id="博客内容修改样例"><a href="#博客内容修改样例" class="headerlink" title="博客内容修改样例"></a>博客内容修改样例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新建博客</span><br><span class="line"></span><br><span class="line"> 如果制定位置</span><br><span class="line">hexo <span class="keyword">new</span> <span class="title class_">post</span> -p  其他/个人博客搭建  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">title: 个人博客搭建</span><br><span class="line">date: <span class="number">2024</span>-<span class="number">12</span>-<span class="number">18</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">20</span></span><br><span class="line">tags: </span><br><span class="line">- 其他</span><br><span class="line">categories: </span><br><span class="line">- 其他</span><br><span class="line">keywords: 个人博客搭建</span><br><span class="line">description: hexo搭建个人博客，使用butterfly主题</span><br><span class="line">top_img: /image/top/other/Personal-blog-building.png #顶部图片</span><br><span class="line">cover: posts/<span class="number">24403</span>/Personal-blog-building.assets/hexo.png #封面图片</span><br><span class="line">typora-root-url: Personal-blog-building</span><br><span class="line">abbrlink: <span class="number">24403</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录下载地址"><a href="#附录下载地址" class="headerlink" title="附录下载地址"></a>附录下载地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;/download/typora/app.asar&quot; download&gt;生成的app.asar文件&lt;/a&gt;</span><br></pre></td></tr></table></figure><h1 id="魔改参考"><a href="#魔改参考" class="headerlink" title="魔改参考"></a>魔改参考</h1><p><a href="https://blog.aqcoder.cn/posts/b20a/#%E5%B1%95%E7%A4%BA%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB">枫叶</a></p><p><a href="https://butterfly.zhheo.com/window.html">魔改网站</a></p><p><a href="https://blog.zhheo.com/">张洪Heo</a></p><p><a href="https://blog.justlovesmile.top/">Justlovesmile</a></p><p><a href="https://meuicat.com/">MeuiCat</a></p><p>首页分类教程：<a href="https://zfe.space/post/hexo-magnet.html">小冰博客</a></p><h1 id="图标网站"><a href="#图标网站" class="headerlink" title="图标网站"></a>图标网站</h1><p><a href="https://fontawesome.com.cn/v5">fontawesome中文网站v5</a></p><p><a href="https://fontawesome.com.cn/v4/icons">fontawesome中文网站v4</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的小屋</title>
      <link href="/posts/18872.html"/>
      <url>/posts/18872.html</url>
      
        <content type="html"><![CDATA[<p>​很早以前就有写博客的想法，但是由于比较懒没有实现，最近在实验室和自己笔记本上电脑来回使用，发现有很多笔记文件，需要来回看，但是同时带电脑又比较麻烦，所以心生一个博客的想法，来便捷这个过程，在两台电脑上串通这些知识。</p><p>​同时前段时间笔记本电脑硬盘坏掉，使得我有这种想法，万一真的再坏了，我数据没了怎么办，故有此篇博客。</p><blockquote><p>注意这个博客只供自己参考，内容如果有出入，可以联系我。</p><p>QQ :860211327</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
