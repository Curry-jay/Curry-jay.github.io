<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis原理和实战 | Curry的小屋</title><meta name="author" content="Curry Jay"><meta name="copyright" content="Curry Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis讲解">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis原理和实战">
<meta property="og:url" content="https://curry-jay.github.io/posts/58965.html">
<meta property="og:site_name" content="Curry的小屋">
<meta property="og:description" content="Redis讲解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://curry-jay.github.io/image/top/back/Database/Redis-1.png">
<meta property="article:published_time" content="2025-07-13T13:05:12.000Z">
<meta property="article:modified_time" content="2025-07-13T13:15:04.078Z">
<meta property="article:author" content="Curry Jay">
<meta property="article:tag" content="Database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://curry-jay.github.io/image/top/back/Database/Redis-1.png"><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="https://curry-jay.github.io/posts/58965.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.2.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Curry Jay","link":"链接: ","source":"来源: Curry的小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis原理和实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/config/css/custom_homeCenter.css?v1"><link rel="stylesheet" href="/config/css/catagory.css?v1"><link rel="stylesheet" href="/config/css/tag.css?v1"><link rel="stylesheet" href="/config/css/rightmenu.css?v1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/theme-chalk/index.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fas fa-angle-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fas fa-angle-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fas fa-sync-alt"></i></div><div class="rightMenu-item" id="menu-darkmode"><i class="fas fa-adjust"></i></div><a class="rightMenu-item" href="/" id="menu-home"><i class="fas fa-home"></i></a></div><div class="rightMenu-group rightMenu-line rightMenuPost"><div class="rightMenu-item" id="menu-reading"><i class="fas fa-book"></i><span>阅读模式</span></div><div class="rightMenu-item" id="menu-postlink"><i class="fas fa-link"></i><span>复制本文地址</span></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="fas fa-copy"></i><span>复制内容</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="fas fa-paste"></i><span>粘贴内容</span></div><div class="rightMenu-item" id="menu-search"><i class="fas fa-search"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="fab fa-internet-explorer"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="fas fa-external-link-alt"></i><span>新建窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="fas fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="fas fa-image"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="fas fa-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-copylinkimg"><i class="fas fa-link"></i><span>复制图片链接</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-translate"><i class="fas fa-language"></i><span>繁简转换</span></a><div class="rightMenu-item" id="menu-asidehide"><i class="fas fa-bars"></i><span>边栏控制</span></div></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="/tags/" id="menu-tags"><i class="fas fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="/posts/48081.html" id="menu-waitToDo"><i class="fas fa-th-list"></i><span>待办清单</span></a><a class="rightMenu-item" href="/categories/" id="menu-folder-open"><i class="fas fa-folder-open"></i><span>博客分类</span></a><a class="rightMenu-item" href="/posts/18872.html" id="menu-copyright"><i class="fas fa-copyright"></i><span>初衷申明</span></a></div></div><div id="rightMenu-mask"></div><div id="web_bg" style="background-color: #c0c3c5;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/image/loading.gif" data-lazy-src="/image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-pie-chart"></i><span> 统计</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/image/top/back/Database/Redis-1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "/image/loading.gif" data-lazy-src="/image/curry.jpg" alt="Logo"><span class="site-name">Curry的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis原理和实战</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-pie-chart"></i><span> 统计</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div><div id="nav-right"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Redis原理和实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-13T13:05:12.000Z" title="发表于 2025-07-13 21:05:12">2025-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T13:15:04.078Z" title="更新于 2025-07-13 21:15:04">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/Database/">Database</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">29.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>110分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p><code>Redis</code>是一种键值型的<code>NoSql</code>数据库，这里有两个关键字：</p>
<ul>
<li><p>键值型</p>
</li>
<li><p><code>NoSql</code></p>
</li>
</ul>
<p>其中<strong>键值型</strong>，是指<code>Redis</code>中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至<code>json</code>：</p>
<h2 id="NoSQL与SQL的对比"><a href="#NoSQL与SQL的对比" class="headerlink" title="NoSQL与SQL的对比"></a><code>NoSQL</code>与<code>SQL</code>的对比</h2><h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><p><code>NoSQL</code></p>
<p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317145611174-bebf61.png" alt="image-20250317145611174"></p>
<p><code>SQL</code></p>
<p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。可以是键值型、文档类型甚至是图格式。：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161352186-189da3.png" alt="image-20250317161352186"></p>
<h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161424361-0a4762.png" alt="image-20250317161424361"></p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161521208-33e421.png" alt="image-20250317161521208"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/J1MqOJM-69959f.png"></p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317161544032-454729.png" alt="image-20250317161544032"></p>
<ul>
<li>存储方式<ul>
<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>
<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>
</ul>
</li>
</ul>
<ul>
<li><p>扩展性</p>
<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
</li>
</ul>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识<code>Redis</code></h2><p>  <strong>特征：</strong></p>
<ul>
<li><strong>键值（key-value）型，value支持多种不同数据结构，功能丰富</strong></li>
<li><strong>单线程，每个命令具备原子性</strong></li>
<li><strong>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</strong></li>
<li><strong>支持数据持久化(定期将内存搬运到磁盘)</strong></li>
<li><strong>支持主从集群、分片集群（数据拆分）</strong></li>
<li><strong>支持多语言客户端</strong></li>
</ul>
<h2 id="wsl使用"><a href="#wsl使用" class="headerlink" title="wsl使用"></a>wsl使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切换环境</span><br><span class="line">wsl --set-default CentOS7</span><br><span class="line"></span><br><span class="line">老式启动</span><br><span class="line">wsl -d name</span><br></pre></td></tr></table></figure>

<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>

<h3 id="上传安装包并解压"><a href="#上传安装包并解压" class="headerlink" title="上传安装包并解压"></a>上传安装包并解压</h3><p>然后将 提供的Redis安装包上传到CentOS7的指定位置，在这里我使用的是WSL来创建一个Windows版本下的Linux子系统，来进行使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">解压缩：</span><br><span class="line">	tar -xzf redis-<span class="number">6.2</span><span class="number">.6</span>.tar.gz</span><br><span class="line">进入解压缩目录</span><br><span class="line">    cd redis-<span class="number">6.2</span><span class="number">.6</span></span><br><span class="line">运行编译命令</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">默认的安装路径是在</span><br><span class="line">    /usr/local/bin 的目录下面</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317231710237-024fa8.png" alt="image-20250317231710237"></p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/home/Redis/redis-6.2.6</code>），名字叫redis.conf</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317232150256-22eb1b.png" alt="image-20250317232150256"></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>

<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br><span class="line"><span class="comment"># 关闭保护模式：</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>

<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /home/Redis/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /home/Redis/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br><span class="line"><span class="comment"># linux下查询redis运行程序</span></span><br><span class="line">ps -ef | grep <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>

<h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码</li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a><code>Redis</code>常见命令</h2><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure>

<p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/17/image-20250317232906001-289359.png" alt="image-20250317232906001"></p>
<p><code>Redis</code>为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（<a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p>
<p>同时<code>Redis</code>是通过分组来进行学习的，即每一种数据类型是一个组的类型，可以通过分别学习一个数据类型来进行学习。还可以通过<code>Redis</code>运行命令进行查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用  &quot;help @&lt;group&gt;&quot; to get a list of commands in &lt;group&gt;</span><br><span class="line">eg: help @generic</span><br></pre></td></tr></table></figure>

<h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a><code>Redis</code>通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key，不建议在生产环境设备上使用，因为<code>Redis</code>是单线程的，如果数据量很大的话，可能导致<code>Redis</code>进行阻塞</li>
<li>DEL：删除一个指定的key，也可以删除多个</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期，-1代表永久有效，-2代表被删除</li>
</ul>
<blockquote>
<p>可以通过help [command] 可以查看一个命令的具体用法</p>
</blockquote>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型，也就是字符串类型，是<code>Redis</code>中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</p>
<h4 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h4><p>String的常见命令有：</p>
<ul>
<li><code>SET</code>：添加或者修改已经存在的一个String类型的键值对</li>
<li><code>GET</code>：根据key获取String类型的value</li>
<li><code>MSET</code>：批量添加多个String类型的键值对：MSET  key value</li>
<li><code>MGET</code>：根据多个key获取多个String类型的value : MGET key1 key2</li>
<li><code>INCR</code>：让一个整型的key自增1 : INCR KEY</li>
<li><code>INCRBY</code>:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 :INCRBY key increment</li>
<li><code>INCRBYFLOAT</code>：让一个浮点类型的数字自增并指定步长 :INCRBYFLOAT key increment</li>
<li><code>SETNX</code>：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li><code>SETEX</code>：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<h4 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h4><p>对于<code>Redis</code>，完全靠key来区分不同的数据，我们可以添加不同的前缀来进行区分，即在对应的项目前面加上对应的区分关系，<code>Redis</code>的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>格式并非固定，也可以根据自己的需求来删除或添加词条。就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user相关的key：Curry:user:1</span><br><span class="line">product相关的key：Curry:product:1</span><br></pre></td></tr></table></figure>

<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为<code>JSON</code>字符串后存储：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET Curry:user:1 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>在<code>Redis</code>的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/18/image-20250318231607701-22d095.png" alt="image-20250318231607701"></p>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/24/x2zDBjf-741019.png"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/24/VF2EPt0-8c79ee.png"></p>
<p>Hash的常见命令有：</p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HSET Curry:user:3 name neu</span><br><span class="line">HSET Curry:user:3 age  101</span><br><span class="line">存储出来的格式如下图所示</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/03/25/image-20250325173135825-4cb900.png" alt="image-20250325173135825"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取出来操作：HGET Curry:user:3 name</span><br><span class="line">一次性拿出来所有 HGETAll Curry:user:3，把KEY Value 依次返回 </span><br></pre></td></tr></table></figure>

<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">怎么通过它实现一个栈效果呢</span><br><span class="line">	入口和出口一致即可</span><br><span class="line">怎么通过它实现一个队列效果呢</span><br><span class="line">	入口和出口不一致即可</span><br><span class="line">怎么通过它实现一个阻塞队列呢？</span><br><span class="line">	使用BLPOP 和 BRPOP</span><br></pre></td></tr></table></figure>

<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
</ul>
<h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
</li>
<li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</li>
</ul>
<p>注意要是顺序，升序，从小到大，那你如果要取出前三个最大的，那就要REV</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg：ZREVrange stus 0 2   取出值最大的前三个</span><br></pre></td></tr></table></figure>

<h2 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * jedis 设置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisConfig</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//1. 建立连接</span></span><br><span class="line">      jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;172.19.77.55&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">      <span class="comment">//2. 设置连接密码</span></span><br><span class="line">      jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      <span class="comment">//3. 选择库</span></span><br><span class="line">      jedis.select(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//加入内容</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">set</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;jedis&quot;</span>, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;加入内容结果：&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取内容</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">jedisResult</span> <span class="operator">=</span> <span class="built_in">this</span>.jedis.get(<span class="string">&quot;jedis&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;获取响应内容：&quot;</span> + jedisResult);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterEach</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisClose</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//关闭连接</span></span><br><span class="line">      jedis.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//jedis配置</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//设置总的连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//设置空闲时候保存的最大连接数，如果空闲，会保存一段时间连接，然后才清除掉</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//设置空闲时候保存的最小连接数，会清除为0</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置连接时间，如果连接池满了，那么就会进行等待，默认-1一直等待</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;172.19.77.55&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">当有连接池的时候，那么就不需要进行close,而是进行归还</span><br></pre></td></tr></table></figure>

<h3 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">官网地址</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/22/UFlNIV0-a8f7c5.png"></p>
<h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><p>引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--redis依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--common-pool--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Jackson依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><p>spring默认使用lettuce实现连接池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: redis-demo</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: <span class="number">172.19</span><span class="number">.77</span><span class="number">.55</span></span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      password: <span class="number">123456</span></span><br><span class="line">      lettuce:</span><br><span class="line">        pool:</span><br><span class="line">          max-active: <span class="number">8</span> #最大连接</span><br><span class="line">          max-idle: <span class="number">8</span> #最大空闲连接</span><br><span class="line">          min-idle: <span class="number">0</span> #最小空闲连接</span><br><span class="line">          max-wait: 100ms #连接等待时间</span><br></pre></td></tr></table></figure>

<h4 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate edisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RedisTemplate可以接收任意Object作为值写入Redis，但是写入前会把Object序列化为字节新式，默认是采用JDK序列化，导致可读性很差，所以我们可以自定义序列化，如下图所示</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425134837192-e305e8.png" alt="image-20250425134837192"></p>
<p>可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">redisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 redisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置Key的序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置Value的序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存到数据库中如下图所示：如果存储的是对象，会自动存储对象的地址，到时候从Redis取出，可以直接进行强制转换，转换成想要的内容。</span><br><span class="line">目的是为了查询时实现自动反序列化</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425134822602-c7faee.png" alt="image-20250425134822602"></p>
<h4 id="手动序列化"><a href="#手动序列化" class="headerlink" title="手动序列化"></a>手动序列化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于上面自动序列化，一直会加入上面这个属性，对于大型系统来讲，很占用内存空间，可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425142026125-906c54.png" alt="image-20250425142026125"></p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意这里使用的mapper是spring自带的一个序列化工具，也可以使用fastjson等自定义json工具进行转换</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">//设置手动序列化内容，要使用他进行序列化以及反序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">//写入一条数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new一个对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;刀哥&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> mapper.writeValueAsString(user1);</span><br><span class="line">        <span class="comment">//写入一条数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, string);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(s, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><p>一共要学习的内容</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425154856912-e7823e.png" alt="image-20250425154856912"></p>
<p>数据库记录</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425152409811-aafd97.png" alt="image-20250425152409811"></p>
<p>项目记录</p>
<p>由于这是一个Redis项目，所以后端没有采用微服务，而是简单采用tomcat，可以使用集群的方法，进行部署，减少服务器压力</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/25/image-20250425154923397-a12d97.png" alt="image-20250425154923397"></p>
<h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="基于Session实现登录登录流程"><a href="#基于Session实现登录登录流程" class="headerlink" title="基于Session实现登录登录流程"></a>基于Session实现登录登录流程</h3><p><strong>发送验证码：</strong></p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带着sessionID到后台，后台通过sessionID从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal(线程域对象)中，并且放行</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/04/27/image-20250427163347883-3cd5f7.png" alt="image-20250427163347883"></p>
<h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">功能比较简单，就首先查验手机号是否正确，之后生成验证码，调用第三方服务发送验证码，返回即可</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 校验手机号是否合格</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//3. 生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//4. 保存验证码到session里面</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        <span class="comment">//5. 发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送短信验证码成功，验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 登录功能的实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">      <span class="comment">//1. 校验手机号</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">      <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">          <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">      <span class="keyword">if</span> (cacheCode != <span class="literal">null</span> &amp;&amp; !cacheCode.toString().equals(code)) &#123;</span><br><span class="line">          <span class="comment">//3. 验证码不一致报错</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. 一致的话，根据手机号查询数据库，看这个手机号是否存在，从而决定   登录/注册</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">      <span class="comment">//5. 判断用户是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//6. 不存在，创建新用户并且进行保存</span></span><br><span class="line">          user = creatUserWithPhone(phone);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//7. 保存用户信息到session里面即可</span></span><br><span class="line">      session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">      <span class="keyword">return</span> Result.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="登录验证功能"><a href="#登录验证功能" class="headerlink" title="登录验证功能"></a>登录验证功能</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总体的流程来讲，当要进行访问的时候，首先进入拦截器，拦截器会查看是否携带Cookie，携带获取到用户，然后进行查询是否存在，保存到threadlocal，供验证函数使用</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/05/image-20250505161410663-361c37.png" alt="image-20250505161410663"></p>
<h4 id="拦截器制作"><a href="#拦截器制作" class="headerlink" title="拦截器制作"></a>拦截器制作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、从请求当中获取到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 2、获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 4、不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5、存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line">        <span class="comment">// 6、放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是返回controller后调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是渲染后调用的函数方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册到拦截器上"><a href="#注册到拦截器上" class="headerlink" title="注册到拦截器上"></a>注册到拦截器上</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将刚才写的拦截器加入到拦截器当中，同时设置哪些可以进行放行，不需要进行登录</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));</span><br></pre></td></tr></table></figure>

<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>

<p><strong>在UserHolder处：将user对象换成UserDTO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507143439962-f10795.png" alt="image-20250507143439962"></p>
<h3 id="Redis代替session的业务流程"><a href="#Redis代替session的业务流程" class="headerlink" title="Redis代替session的业务流程"></a>Redis代替session的业务流程</h3><p>登录功能的实现<br><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507144556627-febda9.png" alt="image-20250507144556627"></p>
<p>登录校验实现<br><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507144616643-c43482.png" alt="image-20250507144616643"></p>
<h4 id="登录和注册功能"><a href="#登录和注册功能" class="headerlink" title="登录和注册功能"></a>登录和注册功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 校验码的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 校验手机号是否合格</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//3. 生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//4. 保存验证码到Redis当中里面</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5. 发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送短信验证码成功，验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 登录功能的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 校验手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">//2. 如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不正确！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span> (cacheCode != <span class="literal">null</span> &amp;&amp; !cacheCode.equals(code)) &#123;</span><br><span class="line">            <span class="comment">//3. 验证码不一致报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 一致的话，根据手机号查询数据库，看这个手机号是否存在，从而决定   登录/注册</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">        <span class="comment">//5. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//6. 不存在，创建新用户并且进行保存</span></span><br><span class="line">            user = creatUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 保存用户信息到redis里面即可</span></span><br><span class="line">        <span class="comment">//7.1 随机生成一个Token，作为登录令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);<span class="comment">//设置带不带下划线，这里true设置为不带下划线</span></span><br><span class="line">        <span class="comment">//7.2 将user对象转化为HashMap进行存储</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        <span class="comment">//7.3 存储</span></span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(tokenKey, map);</span><br><span class="line">        <span class="comment">//设置token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="登录验证功能-1"><a href="#登录验证功能-1" class="headerlink" title="登录验证功能"></a>登录验证功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 4、不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、基于token获取Redis中的用户</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">// 3、判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 4、不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将查询到的Hash数据转化为UserDTO对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);<span class="comment">//第三个错误是忽略不忽略</span></span><br><span class="line">        <span class="comment">// 5、存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 刷新Token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 6、放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是返回controller后调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是渲染后调用的函数方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO);</span><br><span class="line">  当往redis存储的时候，选择的是StringRedisTemplate,那么redis只能保存string的数据，这样转化完成有其他属性要进行转化，最好写成这样</span><br><span class="line">        Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">下面这个设置的是对字段进行修改，第一个参数是字段名称，第二个参数是字段值，我们直接把字段值都修改成string即可</span><br><span class="line">setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br></pre></td></tr></table></figure>

<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><p>现在的实现，可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，优化方案如下：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507170108087-6a3377.png" alt="image-20250507170108087"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、基于token获取Redis中的用户</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="comment">// 3、判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将查询到的Hash数据转化为UserDTO对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);<span class="comment">//第三个错误是忽略不忽略</span></span><br><span class="line">        <span class="comment">// 5、存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 刷新Token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 6、放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是返回controller后调用的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是渲染后调用的函数方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是请求传入前进行拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将刚才写的拦截器加入到拦截器当中，同时设置哪些可以进行放行，不需要进行登录</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">        ).order(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).excludePathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">纯JWT：无状态，所有信息都包含在 Token 中，服务端不保存任何状态，适合完全无状态的分布式系统，但无法灵活控制 Token 的失效和注销。</span><br><span class="line"></span><br><span class="line">Token + Redis：有状态，Token 存在客户端，状态保存在 Redis 中，服务端通过 Redis 管理 Token 的有效性，方便实现 Token 的失效、注销和续期，适合有状态管理需求的分布式系统。</span><br><span class="line"></span><br><span class="line">Session：有状态，用户信息存储在服务端（内存或 Redis 等），通过 Session ID 维护用户状态，适合中小型系统或传统 Web 应用，需在分布式系统中借助 Redis 共享 Session。</span><br></pre></td></tr></table></figure>

<h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><p>缓存(Cache),就是数据交换的<strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码</p>
<p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p>
<p>但是缓存也会增加代码复杂度和运营的成本:</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20250507174003337-7e31a6.png" alt="image-20250507174003337"></p>
<h3 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h3><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p>
<p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p>
<p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p>
<p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p>
<p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/image-20220523212915666-4f7937.png"></p>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/07/1653322097736-6ca8f2.png" alt="1653322097736"></p>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">     <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">     <span class="comment">//2.判断是否存在</span></span><br><span class="line">     <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">         <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">         <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">     <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">     <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">     <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//6.保存到redis当中</span></span><br><span class="line">     stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line">     <span class="comment">//7.返回</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/12/image-20250512155705078-3501f1.png" alt="image-20250512155705078"></p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</span><br><span class="line"></span><br><span class="line">内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</span><br><span class="line">超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</span><br><span class="line">主动更新：我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/12/image-20250512171757706-90e3e3.png" alt="image-20250512171757706"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于我们的缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:</span><br><span class="line">用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务</span><br><span class="line"></span><br><span class="line">有如下几种方案</span><br><span class="line">Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</span><br><span class="line">Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</span><br><span class="line">Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</span><br></pre></td></tr></table></figure>

<p>由于没有剩下两种方案实现，所以我们选择方案一，但是如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p>
<ul>
<li>删除缓存还是更新缓存？<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存——————选择</li>
</ul>
</li>
<li>如何保证缓存与数据库的操作的同时成功或失败？<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
</ul>
<p>那么对于双写还存在一些问题——先操作缓存还是先操作数据库？</p>
<ul>
<li>先删除缓存，再操作数据库——存在问题两个线程，删除缓存更新过程中有人查询会出错</li>
<li>先操作数据库，再删除缓存——存在问题，两个线程查询缓存未命中进行更新缓存过程中对数据库进行修改，由于这种方案概率较低，所以选择这种方案进行实现</li>
</ul>
<h3 id="实现商铺和缓存与数据库双写一致"><a href="#实现商铺和缓存与数据库双写一致" class="headerlink" title="实现商铺和缓存与数据库双写一致"></a>实现商铺和缓存与数据库双写一致</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心思路如下：</span><br><span class="line">修改ShopController中的业务逻辑，满足下面的需求：</span><br><span class="line"></span><br><span class="line">根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</span><br><span class="line">根据id修改店铺时，先修改数据库，再删除缓存</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改ShopServiceImpl的queryById方法设置：redis缓存时添加过期时间</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.保存到redis当中</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先修改数据库，再删除缓存</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺ID不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新数据库</span></span><br><span class="line">        updateById(shop);</span><br><span class="line">        <span class="comment">//删除缓存</span></span><br><span class="line">        stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**缓存空对象思路分析：**当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**布隆过滤：**布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</span><br><span class="line">假设布隆过滤器判断这个数据不存在，则直接返回</span><br><span class="line">这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</span><br><span class="line">   </span><br><span class="line">布隆过滤，不存在是真的不存在，存在是可能存在</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/15/image-20250515205437935-3da640.png" alt="image-20250515205437935"></p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/15/image-20250515210723478-ff5653.png" alt="image-20250515210723478"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">      <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">      <span class="comment">//2.判断是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">          <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">          <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存储空值，那么就保证缓存穿透</span></span><br><span class="line">      <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">      <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">      <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">      <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">          <span class="comment">//保存空值</span></span><br><span class="line">          stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;商铺不存在！&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.保存到redis当中</span></span><br><span class="line">      stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">      <span class="comment">//7.返回</span></span><br><span class="line">      <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line">* 给不同的Key的TTL添加随机值</span><br><span class="line">* 利用Redis集群提高服务的可用性——哨兵机制，有多个Redis服务器集群，一个挂了可以用其他的</span><br><span class="line">* 给缓存业务添加降级限流策略</span><br><span class="line">* 给业务添加多级缓存——有其他地方也可以进行缓存，eg:浏览器缓存、</span><br></pre></td></tr></table></figure>

<h3 id="缓存击穿问题及解决思路-热点Key"><a href="#缓存击穿问题及解决思路-热点Key" class="headerlink" title="缓存击穿问题及解决思路(热点Key)"></a>缓存击穿问题及解决思路(热点Key)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</span><br><span class="line"></span><br><span class="line">常见的解决方案有两种：</span><br><span class="line">* 互斥锁</span><br><span class="line">* 逻辑过期</span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿问题出现"><a href="#缓存击穿问题出现" class="headerlink" title="缓存击穿问题出现"></a>缓存击穿问题出现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设线程<span class="number">1</span>在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程<span class="number">1</span>走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程<span class="number">1</span>没有走完的时候，后续的线程<span class="number">2</span>，线程<span class="number">3</span>，线程<span class="number">4</span>同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519213942557-77f02a.png" alt="image-20250519213942557"></p>
<h4 id="互斥锁解决"><a href="#互斥锁解决" class="headerlink" title="互斥锁解决"></a>互斥锁解决</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + <span class="type">double</span> check来解决这样的问题。</span><br><span class="line"></span><br><span class="line">假设现在线程<span class="number">1</span>过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程<span class="number">1</span>就会一个人去执行逻辑，假设现在线程<span class="number">2</span>过来，线程<span class="number">2</span>在执行过程中，并没有获得到锁，那么线程<span class="number">2</span>就可以进行到休眠，直到线程<span class="number">1</span>把锁释放后，线程<span class="number">2</span>获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519214026638-3ffe0a.png" alt="image-20250519214026638"></p>
<h4 id="逻辑过期方案"><a href="#逻辑过期方案" class="headerlink" title="逻辑过期方案"></a>逻辑过期方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程<span class="number">1</span>去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程<span class="number">1</span>去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程<span class="number">1</span>直接进行返回，假设现在线程<span class="number">3</span>过来访问，由于线程线程<span class="number">2</span>持有着锁，所以线程<span class="number">3</span>无法获得锁，线程<span class="number">3</span>也直接返回数据，只有等到新开的线程<span class="number">2</span>把重建数据构建完后，其他线程才能走返回正确的数据。</span><br><span class="line"></span><br><span class="line">这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519214126507-33f794.png" alt="image-20250519214126507"></p>
<h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/05/19/image-20250519214153508-280bcc.png" alt="image-20250519214153508"></p>
<h4 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询。如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/02/image-20250602171525287-1b3807.png" alt="image-20250602171525287"></p>
<h5 id="操作锁的内容"><a href="#操作锁的内容" class="headerlink" title="操作锁的内容"></a>操作锁的内容</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">本质上利用了redis当中的setnx，当设置的KEY存在的时候，不能进行设置</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取互斥锁的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解决缓存击穿问题</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//2.判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           <span class="keyword">return</span> shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//存储空值，那么就保证缓存穿透</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//5.查询数据库不存在，返回错误</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//实现缓存重建</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//获取互斥锁</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">           <span class="comment">//查看是否获取成功</span></span><br><span class="line">           <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">               <span class="comment">//失败,休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//成功根据ID查询数据库</span></span><br><span class="line">           <span class="comment">//3. 存在直接进行返回</span></span><br><span class="line">           shop = getById(id);</span><br><span class="line">           <span class="comment">//模拟重建的延时</span></span><br><span class="line">           Thread.sleep(<span class="number">200</span>);</span><br><span class="line">           <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">           <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//5.查询数据库不存在，返回错误，解决缓存穿透问题</span></span><br><span class="line">               <span class="comment">//保存空值</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.保存到redis当中</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放互斥锁</span></span><br><span class="line">           unLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//7.返回</span></span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用逻辑过期时间解决缓存击穿问题"><a href="#利用逻辑过期时间解决缓存击穿问题" class="headerlink" title="利用逻辑过期时间解决缓存击穿问题"></a>利用逻辑过期时间解决缓存击穿问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</span><br><span class="line">    </span><br><span class="line">为什么在一开始未命中的情况下直接返回呢，因为这种热点KEY一般都会进行预热，即把这部分内容存入到缓存当中，不会存在过期，所以没命中就可以直接返回</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/03/image-20250603140452809-6039e2.png" alt="image-20250603140452809"></p>
<h5 id="预热函数"><a href="#预热函数" class="headerlink" title="预热函数"></a>预热函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 预热函数，相当于把数据先存入到Redis当中</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expireSeconds</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shop2Redis</span><span class="params">(<span class="type">long</span> id, Long expireSeconds)</span> &#123;</span><br><span class="line">       <span class="comment">//1.查询商铺数据</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">       <span class="comment">//3.写入Redis当中</span></span><br><span class="line">       stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="利用逻辑时间解决问题"><a href="#利用逻辑时间解决问题" class="headerlink" title="利用逻辑时间解决问题"></a>利用逻辑时间解决问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用逻辑过期解决缓存击穿问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">//2.1未命中直接返回空值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 命中</span></span><br><span class="line">        <span class="comment">//3.判断缓存是否过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//3.1 未过期，返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 过期</span></span><br><span class="line">        <span class="comment">//4.1 尝试获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(key);</span><br><span class="line">        <span class="comment">//4.3获取成功开启独立线程</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//二次确认，我这里没写，实际上存在当你获取到锁后，可能前一个刚好释放，但是redis已经更新的情况</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.shop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unLock(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2获取锁失败，返回原本商铺信息</span></span><br><span class="line">        <span class="comment">//6.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="秒杀优惠券"><a href="#秒杀优惠券" class="headerlink" title="秒杀优惠券"></a>秒杀优惠券</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</span><br><span class="line"></span><br><span class="line">* id的规律性太明显</span><br><span class="line">* 受单表数据量的限制——因为优惠卷一般是多个表，分布式存储表格，每个表自增长是一样的，会出现ID重复的问题</span><br></pre></td></tr></table></figure>

<h3 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h3><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：唯一性、高可用、高性能、递增性、安全性。</p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/07/image-20250607172446289-cde1bf.png" alt="image-20250607172446289"></p>
<p>ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始时间戳</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1749340800L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移动单位</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">      <span class="comment">//1.生成时间戳</span></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">      <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line">      <span class="comment">//2.生成序列号</span></span><br><span class="line">      <span class="comment">//2.1 获取当前的日期</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> <span class="variable">increment</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">      <span class="comment">//3.拼接并且进行返回</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | increment ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> RedisWorkId redisWorkId;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//new 一个500个线程的线程池</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">               <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line">           &#125;</span><br><span class="line">           countDownLatch.countDown();</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">           es.submit(task);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;begin-end = &quot;</span> + (end - begin));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局唯一ID生成策略：</span><br><span class="line">    UUID</span><br><span class="line">    Redis自增</span><br><span class="line">    snowflake算法</span><br><span class="line">    数据库自增</span><br></pre></td></tr></table></figure>

<h4 id="注意——异步线程知识"><a href="#注意——异步线程知识" class="headerlink" title="注意——异步线程知识"></a>注意——异步线程知识</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关于countdownlatch</span><br><span class="line"></span><br><span class="line">countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</span><br><span class="line"></span><br><span class="line">我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</span><br><span class="line"></span><br><span class="line">CountDownLatch 中有两个最重要的方法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、countDown</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、await</span><br><span class="line"></span><br><span class="line">await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为<span class="number">0</span>时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为<span class="number">0</span> 呢，我们只需要调用一次countDown ，内部变量就减少<span class="number">1</span>，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是<span class="number">0</span>，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</span><br></pre></td></tr></table></figure>

<h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><p>增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现优惠卷秒杀下单"><a href="#实现优惠卷秒杀下单" class="headerlink" title="实现优惠卷秒杀下单"></a>实现优惠卷秒杀下单</h3><p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/08/1653366238564-221177.png" alt="1653366238564"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">//1.查询优惠卷</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">//2.查询秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">//判断尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3.查询秒杀是否结束</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">//判断已经结束</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.查询库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//库存不够</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5. 扣减库存</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          <span class="comment">//库存不够</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.创建订单</span></span><br><span class="line">      <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">      <span class="comment">//6.1 订单ID</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">      voucherOrder.setId(orderID);</span><br><span class="line">      <span class="comment">//6.2 用户ID</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">      voucherOrder.setVoucherId(voucherId);</span><br><span class="line">      <span class="comment">//7.返回订单ID</span></span><br><span class="line">      save(voucherOrder);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/image-20250609154457808-45099c.png" alt="image-20250609154457808"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653368562591-34b462.png" alt="1653368562591"></p>
<h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a><strong>悲观锁：</strong></h4><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p>简单理解就是单线程串行执行</p>
<h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a><strong>乐观锁：</strong></h4><p>  乐观锁——版本号控制：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">var5 是操作前读取的内存值，<span class="keyword">while</span>中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</span><br><span class="line">其中<span class="keyword">do</span> <span class="keyword">while</span> 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>

<h4 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在进行库存修改的时候，进行双重判断即可</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>

<h3 id="优惠券秒杀-一人一单"><a href="#优惠券秒杀-一人一单" class="headerlink" title="优惠券秒杀-一人一单"></a>优惠券秒杀-一人一单</h3><p>修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/image-20250609164850992-bf453a.png" alt="image-20250609164850992"></p>
<h4 id="修改方案——判断是否存在"><a href="#修改方案——判断是否存在" class="headerlink" title="修改方案——判断是否存在"></a>修改方案——判断是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询优惠卷</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.查询秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//判断尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.查询秒杀是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//判断已经结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.查询库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//库存不够</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 一人一单逻辑</span></span><br><span class="line">        <span class="comment">//5.1 获取用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//5.2 判断是否已经购买过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.3.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">//库存不够</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//7.1 订单ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderID);</span><br><span class="line">        <span class="comment">//7.2 用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">//8.返回订单ID</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</span><br></pre></td></tr></table></figure>

<h4 id="优化——悲观锁"><a href="#优化——悲观锁" class="headerlink" title="优化——悲观锁"></a>优化——悲观锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将数据库操作判断函数，提取出来，使用悲观锁来进行控制</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//5. 一人一单逻辑</span></span><br><span class="line">        <span class="comment">//5.1 获取用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//5.2 判断是否已经购买过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.3.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">//库存不够</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//7.1 订单ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderID);</span><br><span class="line">        <span class="comment">//7.2 用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">//8.返回订单ID</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这样添加锁，锁的粒度太粗了，在使用锁过程中，控制锁粒度是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</span><br><span class="line"></span><br><span class="line">intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</span><br></pre></td></tr></table></figure>

<h4 id="继续优化，精确锁控制"><a href="#继续优化，精确锁控制" class="headerlink" title="继续优化，精确锁控制"></a>继续优化，精确锁控制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上述实现把锁放在函数上，即这个函数只能运行一次，所以我们需要锁的是用户ID，每一个用户只能操作一次</span><br><span class="line"> <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//5. 一人一单逻辑</span></span><br><span class="line">        <span class="comment">//5.1 获取用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.2 判断是否已经购买过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="comment">// 5.3.判断是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已经购买过了</span></span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">//库存不够</span></span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7.创建订单</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            <span class="comment">//7.1 订单ID</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            voucherOrder.setId(orderID);</span><br><span class="line">            <span class="comment">//7.2 用户ID</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">            voucherOrder.setUserId(id);</span><br><span class="line"></span><br><span class="line">            voucherOrder.setVoucherId(voucherId);</span><br><span class="line">            <span class="comment">//8.返回订单ID</span></span><br><span class="line">            save(voucherOrder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：</span><br></pre></td></tr></table></figure>

<h4 id="继续优化——事务处理放置位置"><a href="#继续优化——事务处理放置位置" class="headerlink" title="继续优化——事务处理放置位置"></a>继续优化——事务处理放置位置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">   <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">       <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">但是以上做法依然有问题，因为你调用的方法，其实是<span class="built_in">this</span>.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>注意要导入依赖和注册扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        </span><br><span class="line">        启动类加入</span><br><span class="line">@EnableAspectJAutoProxy(exposeProxy = true)</span><br></pre></td></tr></table></figure>

<h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653373887844-8d08bf.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653373908620-bdc646.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<p><strong>有关锁失效原因分析</strong></p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/06/09/1653374044740-98c68d.png" alt="1653374044740"></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/03/image-20250703155848615-ad8cae.png" alt="image-20250703155848615"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</span><br><span class="line">互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</span><br><span class="line">高可用：程序不易崩溃，时时刻刻都保证较高的可用性</span><br><span class="line">高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</span><br><span class="line">安全性：安全也是程序中必不可少的一环</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/03/image-20250703160006909-6ae8e2.png" alt="image-20250703160006909"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常见的分布式锁有三种</span><br><span class="line"></span><br><span class="line">Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</span><br><span class="line">Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</span><br><span class="line">Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/03/image-20250703160457899-a25718.png" alt="image-20250703160457899"></p>
<h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li><p>互斥：确保只能有一个线程获取锁</p>
</li>
<li><p>非阻塞：尝试一次，成功返回true，失败返回false</p>
</li>
<li><pre><code>SET lock thread1 NX EX 10
NX是设置互斥，EX是设置超时时间
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">* 释放锁：</span><br><span class="line"></span><br><span class="line">  * 手动释放</span><br><span class="line">  * 超时释放：获取锁时添加一个超时时间、</span><br><span class="line"></span><br><span class="line">### 实现分布式锁版本一</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Ilock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description:</span><br><span class="line">     * @author: curry</span><br><span class="line">     * @date: 2025/7/3 16:13</span><br><span class="line">     * @param: timeoutSec 锁持有的超时时间，过期后自动释放</span><br><span class="line">     * @return: true表示获取锁成功，false表示获取锁失败</span><br><span class="line">     **/</span><br><span class="line">    boolean tryLock(long timeoutSec);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description:</span><br><span class="line">     * @author: curry</span><br><span class="line">     * @date: 2025/7/3 16:14</span><br><span class="line">     * @param:</span><br><span class="line">     * @return: 释放锁</span><br><span class="line">     **/</span><br><span class="line">    void unLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Ilock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程标识</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(bool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取线程标识</span></span><br><span class="line"><span class="comment">         * 因为存在一种情况，当这个线程运行完成要释放，但是过期了，现在锁是另一个线程的，就有可能把别的线程的锁误删，所以最好进行对比</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="keyword">if</span> (s.equals(id + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/04/image-20250704180325152-ffbc48.png" alt="image-20250704180325152"></p>
<h3 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）</span><br><span class="line">在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</span><br><span class="line"></span><br><span class="line">* 如果一致则释放锁</span><br><span class="line">* 如果不一致则不释放锁</span><br><span class="line"></span><br><span class="line">核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 获取线程标识</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ID_PREFIX+ Thread.currentThread().getId();</span><br><span class="line">     <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id , timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">     <span class="keyword">return</span> BooleanUtil.isTrue(bool);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程标识</span></span><br><span class="line"><span class="comment">       * 因为存在一种情况，当这个线程运行完成要释放，但是过期了，现在锁是另一个线程的，就有可能把别的线程的锁误删，所以最好进行对比</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程标识</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ID_PREFIX+ Thread.currentThread().getId();</span><br><span class="line">      <span class="comment">// 获取锁中的标示</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">      <span class="keyword">if</span> (Objects.equals(s, id )) &#123;</span><br><span class="line">          stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程<span class="number">2</span>进来，但是线程<span class="number">1</span>他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程<span class="number">1</span>的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705160737136-84befd.png" alt="image-20250705160737136"></p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法可以参考网站：https://www.runoob.com/lua/lua-tutorial.html</span><br></pre></td></tr></table></figure>

<p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...) number(Key参数个数) key参数  其他参数</span><br><span class="line"></span><br><span class="line">基本写法</span><br><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>], ...) <span class="number">1</span> key  value</span><br><span class="line">key类型参数会存放再KEYS数组当中，其他参数存在ARGV数组里面，后面数字表示有几个key类型参数，然后后面跟几个key类型参数，之后跟着ARGV类型参数</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705161124070-48d7c2.png" alt="image-20250705161124070"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">所以我们释放锁的操作可以简化为下面的Lua语言</span><br><span class="line">释放锁的业务流程是这样的</span><br><span class="line">	<span class="number">1</span>、获取锁中的线程标示</span><br><span class="line">	<span class="number">2</span>、判断是否与指定的标示（当前线程标示）一致</span><br><span class="line">	<span class="number">3</span>、如果一致则释放锁（删除）</span><br><span class="line">	<span class="number">4</span>、如果不一致则什么都不做</span><br><span class="line"></span><br><span class="line"><span class="comment">--锁的Key</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--当前线程表示</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>] </span><br><span class="line"><span class="comment">--获取锁中的线程表示</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&quot;get&quot;</span>, key)</span><br><span class="line"><span class="comment">--比较线程表示和锁标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> id == threadId <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--如果一致，删除锁</span></span><br><span class="line">    redis.call(<span class="string">&quot;del&quot;</span>, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">--如果不一致，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化脚本,这里&lt;long&gt;表示返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; unlock_script;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unlock_script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        unlock_script.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        unlock_script.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用lua脚本</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stringRedisTemplate.execute(unlock_script, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="改善问题"><a href="#改善问题" class="headerlink" title="改善问题"></a>改善问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁-redission"><a href="#分布式锁-redission" class="headerlink" title="分布式锁-redission"></a>分布式锁-redission</h2><h3 id="上述实现存在的问题"><a href="#上述实现存在的问题" class="headerlink" title="上述实现存在的问题"></a>上述实现存在的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于setnx实现的分布式锁存在下面的问题：</span><br><span class="line">**重入问题**：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用<span class="keyword">synchronized</span>修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的<span class="keyword">synchronized</span>和Lock锁都是可重入的。</span><br><span class="line">**不可重试**：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</span><br><span class="line">**超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</span><br><span class="line">**主从一致性：** 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705164401547-9ee04b.png" alt="image-20250705164401547"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">Redission提供了分布式锁的多种多样的功能</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/05/image-20250705164421596-3894de.png" alt="image-20250705164421596"></p>
<h3 id="分布式锁-Redission快速入门"><a href="#分布式锁-Redission快速入门" class="headerlink" title="分布式锁-Redission快速入门"></a>分布式锁-Redission快速入门</h3><p>引入依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用Redission的分布式锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁-redission可重入锁原理"><a href="#分布式锁-redission可重入锁原理" class="headerlink" title="分布式锁-redission可重入锁原理"></a>分布式锁-redission可重入锁原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redission可重入锁的机制就如下面流程图所示，将数据存储为Hset格式的，当不存在锁，对锁进行创建，并且设置时间以及次数，当锁存在后，就对锁进入次数进行修改</span><br><span class="line">释放的时候，对锁的次数进行减少，直到减少到<span class="number">0</span>即可</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">    <span class="keyword">private</span> RLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        lock = redissonClient.getLock(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RedissonTest1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁失败-------------1 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁成功-----------------1&quot;</span>);</span><br><span class="line">            RedissonTest2();</span><br><span class="line">            System.out.println(<span class="string">&quot; 执行业务1-----------------1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 释放业务1----------------1&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RedissonTest2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁失败-------------2 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 获取锁成功-----------------2&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 执行业务2-----------------2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 释放业务2-----------------2&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706162007786-99cd97.png" alt="image-20250706162007786"></p>
<h3 id="分布式锁-redission锁重试和WatchDog机制"><a href="#分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-redission锁重试和WatchDog机制"></a>分布式锁-redission锁重试和WatchDog机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大致流程如下图所示，看门狗机制实现</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706165500487-13f333.png" alt="image-20250706165500487"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redisson分布式锁原理：</span><br><span class="line">可重入：利用hash结构记录线程id和重入次数</span><br><span class="line">可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</span><br><span class="line">超时续约：利用watchDog，每隔一段时间（releaseTime/<span class="number">3</span>），重置超时时间</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁-redission锁的MutiLock原理"><a href="#分布式锁-redission锁的MutiLock原理" class="headerlink" title="分布式锁-redission锁的MutiLock原理"></a>分布式锁-redission锁的MutiLock原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主节点处理所有的写操作，从节点进行读操作，需要进行主从同步</span><br><span class="line"></span><br><span class="line">独立的锁联合起来成一个联合的锁，多个独立的锁，</span><br></pre></td></tr></table></figure>

<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706171902694-35c751.png" alt="image-20250706171902694"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706171916933-a51602.png" alt="image-20250706171916933"></p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/06/image-20250706171950552-0924f6.png" alt="image-20250706171950552"></p>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><p>没有优化前进行测试，放入1000个线程进行强200的库存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">具体操作，写入一个脚本，让其获取<span class="number">1000</span>个用户token,进行假登录，完事后用jmeter进行测试，测试结果如下：</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">TestMultiLogin</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        List&lt;User&gt; userList = userService.lambdaQuery().last(<span class="string">&quot;limit 1000&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);<span class="comment">//设置带不带下划线，这里true设置为不带下划线</span></span><br><span class="line">            <span class="comment">//7.2 将user对象转化为HashMap进行存储</span></span><br><span class="line">            <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">            Map&lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                    CopyOptions.create().setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">            <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">            <span class="comment">//7.3 存储</span></span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(tokenKey, map);</span><br><span class="line">            <span class="comment">//设置token有效期</span></span><br><span class="line">            stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.keys(LOGIN_USER_KEY + <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Cleanup</span> <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;VVtokens.txt&quot;</span>);</span><br><span class="line">        <span class="meta">@Cleanup</span> <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fileWriter);</span><br><span class="line">        <span class="keyword">assert</span> keys != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> key.substring(LOGIN_USER_KEY.length());</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> token + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            bufferedWriter.write(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707001304010-f8083e.png" alt="image-20250707001304010"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以发现有点慢，所以我们希望对这部分内容进行优化，</span><br><span class="line">优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</span><br><span class="line">第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</span><br><span class="line">第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707001523540-15b127.png" alt="image-20250707001523540"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于<span class="number">0</span>即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回<span class="number">0</span>，整个过程需要保证是原子性的，我们可以使用lua来操作</span><br><span class="line"></span><br><span class="line">当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是<span class="number">0</span> ，如果是<span class="number">0</span>，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707001548952-66e8d5.png" alt="image-20250707001548952"></p>
<h3 id="秒杀优化-Redis完成秒杀资格判断"><a href="#秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="秒杀优化-Redis完成秒杀资格判断"></a>秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li>
<li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li>
<li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li>
</ul>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707151729264-36f9ad.png" alt="image-20250707151729264"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新增优惠卷的时候，加入到Redis当中</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存优惠券</span></span><br><span class="line">        save(voucher);</span><br><span class="line">        <span class="comment">// 保存秒杀信息</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">        seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">        seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">        seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">        seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">        seckillVoucherService.save(seckillVoucher);</span><br><span class="line">        <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完整lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">--- Generated by EmmyLua(https://github.com/EmmyLua)</span></span><br><span class="line"><span class="comment">--- Created by CurryJay.</span></span><br><span class="line"><span class="comment">--- DateTime: 2025/7/7 15:22</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---1.参数列表</span></span><br><span class="line"><span class="comment">---1.1 优惠卷ID</span></span><br><span class="line"><span class="keyword">local</span> voucherID = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">---1.2用户ID</span></span><br><span class="line"><span class="keyword">local</span> userID = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">---1.3 订单ID</span></span><br><span class="line"><span class="keyword">local</span> orderID = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>执行业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userID.toString(), String.valueOf(orderID)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(flag == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="秒杀优化-基于阻塞队列实现秒杀优化"><a href="#秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="秒杀优化-基于阻塞队列实现秒杀优化"></a>秒杀优化-基于阻塞队列实现秒杀优化</h3><p>实现意义不大，没实现，因为不会使用这种方案，一般会使用消息队列来进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//异步处理线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 2.创建锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">            proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderID</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userID.toString(), String.valueOf(orderID)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(flag == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisWorkId.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userID);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">        proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">秒杀业务的优化思路是什么？</span><br><span class="line"></span><br><span class="line">* 先利用Redis完成库存余量、一人一单判断，完成抢单业务</span><br><span class="line">* 再将下单业务放入阻塞队列，利用独立线程异步下单</span><br><span class="line">* 基于阻塞队列的异步秒杀存在哪些问题？</span><br><span class="line">  * 内存限制问题</span><br><span class="line">  * 数据安全问题</span><br></pre></td></tr></table></figure>

<h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><h3 id="Redis消息队列-基于List实现消息队列"><a href="#Redis消息队列-基于List实现消息队列" class="headerlink" title="Redis消息队列-基于List实现消息队列"></a>Redis消息队列-基于List实现消息队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</span><br><span class="line">队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</span><br><span class="line">不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回<span class="literal">null</span>，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707162156246-503228.png" alt="image-20250707162156246"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于List的消息队列有哪些优缺点？</span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">* 利用Redis存储，不受限于JVM内存上限</span><br><span class="line">* 基于Redis的持久化机制，数据安全性有保证</span><br><span class="line">* 可以满足消息有序性</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">* 无法避免消息丢失</span><br><span class="line">* 只支持单消费者</span><br></pre></td></tr></table></figure>

<h3 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PubSub（发布订阅）是Redis2<span class="number">.0</span>版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</span><br><span class="line"></span><br><span class="line"> SUBSCRIBE channel [channel] ：订阅一个或多个频道</span><br><span class="line"> PUBLISH channel msg ：向一个频道发送消息</span><br><span class="line"> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707162945884-9c92b1.png" alt="image-20250707162945884"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基于PubSub的消息队列有哪些优缺点？</span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">* 采用发布订阅模型，支持多生产、多消费</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">* 不支持数据持久化</span><br><span class="line">* 无法避免消息丢失</span><br><span class="line">* 消息堆积有上限，超出时数据丢失</span><br></pre></td></tr></table></figure>

<h3 id="Redis消息队列-基于Stream的消息队列"><a href="#Redis消息队列-基于Stream的消息队列" class="headerlink" title="Redis消息队列-基于Stream的消息队列"></a>Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577301737-111b25.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577349691-ca71cf.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577445413-b465f4.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577643629-10e227.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577659166-6ce04d-3f67c2.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/1653577689129-82a0ea.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列-消费者组"><a href="#Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="Redis消息队列-基于Stream的消息队列-消费者组"></a>Redis消息队列-基于Stream的消息队列-消费者组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707181302059-db3605.png" alt="image-20250707181302059"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建消费者组：XGROUP CREATE key groupName ID [MKSTREAM]</span><br><span class="line">    key：队列名称</span><br><span class="line">groupName：消费者组名称</span><br><span class="line">ID：起始ID标示，$代表队列中最后一个消息，<span class="number">0</span>则代表队列中第一个消息</span><br><span class="line">MKSTREAM：队列不存在时自动创建队列</span><br></pre></td></tr></table></figure>

<p>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br><span class="line">* group：消费组名称</span><br><span class="line">* consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</span><br><span class="line">* count：本次查询的最大数量</span><br><span class="line">* BLOCK milliseconds：当没有消息时最长等待时间</span><br><span class="line">* NOACK：无需手动ACK，获取到消息后自动确认</span><br><span class="line">* STREAMS key：指定队列名称</span><br><span class="line">* ID：获取消息的起始ID：</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&gt;&quot;</span>：从下一个未消费的消息开始</span><br><span class="line">其它：根据指定id从pending-list中获取已消费但未确认的消息，例如<span class="number">0</span>，是从pending-list中的第一个消息开始</span><br></pre></td></tr></table></figure>

<p>处理的基本思路<br><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707181502028-20b3f7.png" alt="image-20250707181502028"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STREAM类型消息队列的XREADGROUP命令特点：</span><br><span class="line"></span><br><span class="line">* 消息可回溯</span><br><span class="line">* 可以多消费者争抢消息，加快消费速度</span><br><span class="line">* 可以阻塞读取</span><br><span class="line">* 没有消息漏读的风险</span><br><span class="line">* 有消息确认机制，保证消息至少被消费一次</span><br></pre></td></tr></table></figure>

<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/07/image-20250707181546388-c13535.png" alt="image-20250707181546388"></p>
<h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：</span><br><span class="line"></span><br><span class="line">* 创建一个Stream类型的消息队列，名为stream.orders</span><br><span class="line">* 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</span><br><span class="line">* 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</span><br></pre></td></tr></table></figure>



<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">首先创建消息队列：XGROUP CREATE stream.orders g1 <span class="number">0</span> MKSTREAM</span><br><span class="line"><span class="comment">-- 3.6 发送给Redis消息队列,XADD stream.order</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>,<span class="string">&#x27;stream.orders&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;userID&#x27;</span>,userID,<span class="string">&#x27;voucherID&#x27;</span>,voucherID,<span class="string">&#x27;orderID&#x27;</span>,id)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现消息队列读取，以及确认重试操作  </span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</span></span><br><span class="line"></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 2.判断消息获取是否成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 2.1 如果获取失败，说明没有消息，继续下一次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.1 解析消息中订单信息String-消息ID,返回的键值对形式 Object -&gt;key, Object -&gt;vlaue</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; map = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 4. 如果获取成功，可以下单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">// 5. ACK 确认 SACK</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(</span><br><span class="line">                            <span class="string">&quot;stream.orders&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId()</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line"><span class="comment">//                    break;</span></span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取Pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 2.判断消息获取是否成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 2.1 如果获取失败，说明pending-list没有消息，结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 3.1 解析消息中订单信息String-消息ID,返回的键值对形式 Object -&gt;key, Object -&gt;vlaue</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; map = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 4. 如果获取成功，可以下单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">// 5. ACK 确认 SACK</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(</span><br><span class="line">                            <span class="string">&quot;stream.orders&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId()</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理pending-list订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="达人探店-发布探店笔记"><a href="#达人探店-发布探店笔记" class="headerlink" title="达人探店-发布探店笔记"></a>达人探店-发布探店笔记</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单来说就调用人写好的接口，没啥好说的</span><br><span class="line"></span><br><span class="line">探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：</span><br><span class="line">tb_blog：探店笔记表，包含笔记中的标题、文字、图片等</span><br><span class="line">tb_blog_comments：其他用户对探店笔记的评价</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-查看探店笔记"><a href="#达人探店-查看探店笔记" class="headerlink" title="达人探店-查看探店笔记"></a>达人探店-查看探店笔记</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其实这部分内容也没用到Redis，简单提一嘴，就使用Service方法实现对应接口，然后返回数据即可，</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询blog</span></span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">        blog.setName(user.getNickName());</span><br><span class="line">        blog.setIcon(user.getIcon());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞功能"><a href="#达人探店-点赞功能" class="headerlink" title="达人探店-点赞功能"></a>达人探店-点赞功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将点赞数据以Set集合的形式保存到Redis当中，点赞的时候去Redis中去进行查询判断即可</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">完善点赞功能</span><br><span class="line">需求：</span><br><span class="line">* 同一个用户只能点赞一次，再次点击则取消点赞</span><br><span class="line">* 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</span><br><span class="line">实现步骤：</span><br><span class="line">* 给Blog类中添加一个isLike字段，标示是否被当前用户点赞</span><br><span class="line">* 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+<span class="number">1</span>，已点赞过则点赞数-<span class="number">1</span></span><br><span class="line">* 修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</span><br><span class="line">* 修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">//1. 获取登录用户</span></span><br><span class="line">       <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">       <span class="comment">//2. 判断当前登录是否已经点赞</span></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">       <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">       <span class="keyword">if</span> (BooleanUtil.isFalse(bool)) &#123;</span><br><span class="line">           <span class="comment">//3.1 数据库点赞+1</span></span><br><span class="line">           <span class="comment">//3.2 保存用户到Redis的Set集合</span></span><br><span class="line">           <span class="comment">// 修改点赞数量</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//4 如果已经点赞</span></span><br><span class="line">           <span class="comment">//4.1 数据库点赞-1</span></span><br><span class="line">           <span class="comment">//4.2 把用户从redis的集合删掉</span></span><br><span class="line">           <span class="comment">// 修改点赞数量</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞排行榜"><a href="#达人探店-点赞排行榜" class="headerlink" title="达人探店-点赞排行榜"></a>达人探店-点赞排行榜</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</span><br><span class="line"></span><br><span class="line">之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708162551356-724505.png" alt="image-20250708162551356"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改代码，查询存不存在用score</span><br><span class="line"> <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">        <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.1 数据库点赞+1</span></span><br><span class="line">            <span class="comment">//3.2 保存用户到Redis的Set集合 zadd key value score</span></span><br><span class="line">            <span class="comment">// 修改点赞数量</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(BLOG_LIKED_KEY + id, user.getId().toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4 如果已经点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞-1</span></span><br><span class="line">            <span class="comment">//4.2 把用户从redis的集合删掉</span></span><br><span class="line">            <span class="comment">// 修改点赞数量</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>查询出来进行排序返回用户顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1. 查询top的点赞用户 Zrange key 0 4</span></span><br><span class="line">       Set&lt;String&gt; range = stringRedisTemplate.opsForZSet().range(BLOG_LIKED_KEY + id, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">       <span class="keyword">if</span> (range == <span class="literal">null</span> || range.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2. 解析出来用户ID</span></span><br><span class="line">       List&lt;Long&gt; ids = range.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">       <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       <span class="comment">//3. 根据用户ID查询用户 由于默认查出来是相反的顺序，所以需要这样处理是的顺序成正序</span></span><br><span class="line">       List&lt;User&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;IRDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">       <span class="comment">//4. 返回信息</span></span><br><span class="line">       List&lt;UserDTO&gt; collect = users.stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">       <span class="keyword">return</span> Result.ok(collect);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="好友关注-关注和取消关注"><a href="#好友关注-关注和取消关注" class="headerlink" title="好友关注-关注和取消关注"></a>好友关注-关注和取消关注</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较简单，就是操作一张表，关注的时候新增表，取关的时候删除表，查询是否关注的时候查询是否存在这个数据</span><br><span class="line"></span><br><span class="line">需求：基于该表数据结构，实现两个接口：</span><br><span class="line"></span><br><span class="line">* 关注和取关接口</span><br><span class="line">* 判断是否关注的接口</span><br><span class="line"></span><br><span class="line">关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708164504016-50a278.png" alt="image-20250708164504016"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserID, Boolean isFollow)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">//1. 判断到底是关注还是取关</span></span><br><span class="line">       <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">           <span class="comment">//2. 关注,新增数据</span></span><br><span class="line">           <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">           follow.setUserId(userId);</span><br><span class="line">           follow.setFollowUserId(followUserID);</span><br><span class="line">           save(follow);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//3. 取关，删除</span></span><br><span class="line">           remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserID));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserID)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserID).count();</span><br><span class="line">       <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-共同关注"><a href="#好友关注-共同关注" class="headerlink" title="好友关注-共同关注"></a>好友关注-共同关注</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">核心内容就是使用Redis的交集功能，获取到两个集合的交集即可，获取到交集</span><br><span class="line"></span><br><span class="line">首先改造关注的时候需要把关注内容加入到Redis当中</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserID, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//1. 判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">//2. 关注,新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserID);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(follow);</span><br><span class="line">            <span class="keyword">if</span> (save) &#123;</span><br><span class="line">                <span class="comment">//把关注用户的ID，放入Redis的set集合当中，sadd userID foll</span></span><br><span class="line">                stringRedisTemplate.opsForSet().add(FOLLOWS_KEY + userId, followUserID.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//3. 取关，删除</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserID));</span><br><span class="line">            <span class="comment">//移除用户</span></span><br><span class="line">            <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().remove(FOLLOWS_KEY + userId, followUserID.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具体计算交集的代码，通过Set提供的交集代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">commonFollow</span><span class="params">(Long followUserID)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//求集合</span></span><br><span class="line">        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(FOLLOWS_KEY + id, FOLLOWS_KEY + followUserID);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析ID集合</span></span><br><span class="line">        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-Feed流实现方案"><a href="#好友关注-Feed流实现方案" class="headerlink" title="好友关注-Feed流实现方案"></a>好友关注-Feed流实现方案</h3><p> 当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708181944697-092ab0.png" alt="image-20250708181944697"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708181955069-297f57.png" alt="image-20250708181955069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Feed流产品有两种常见模式：</span><br><span class="line">Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</span><br><span class="line">* 优点：信息全面，不会有缺失。并且实现也相对简单</span><br><span class="line">* 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</span><br><span class="line"></span><br><span class="line">智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</span><br><span class="line">* 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</span><br><span class="line">* 缺点：如果算法不精准，可能起到反作用</span><br></pre></td></tr></table></figure>

<p>因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<h4 id="拉模式：也叫做读扩散"><a href="#拉模式：也叫做读扩散" class="headerlink" title="拉模式：也叫做读扩散"></a><strong>拉模式</strong>：也叫做读扩散</h4><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182036738-f83aa8.png" alt="image-20250708182036738"></p>
<h4 id="推模式：也叫做写扩散。"><a href="#推模式：也叫做写扩散。" class="headerlink" title="推模式：也叫做写扩散。"></a><strong>推模式</strong>：也叫做写扩散。</h4><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182050926-e24fb4.png" alt="image-20250708182050926"></p>
<h4 id="推拉结合模式："><a href="#推拉结合模式：" class="headerlink" title="推拉结合模式："></a><strong>推拉结合模式</strong>：</h4><p>也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182113107-d2cb3e.png" alt="image-20250708182113107"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/08/image-20250708182129510-7cf4a9.png" alt="image-20250708182129510"></p>
<h3 id="好友关注-推送到粉丝收件箱"><a href="#好友关注-推送到粉丝收件箱" class="headerlink" title="好友关注-推送到粉丝收件箱"></a>好友关注-推送到粉丝收件箱</h3><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/12/1653813047671-9370f4.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/12/1653813462834-906847.png" alt="1653813462834"></p>
<p>实现方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     blog.setUserId(user.getId());</span><br><span class="line">     <span class="comment">// 保存探店博文</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">     <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//查询笔记作者的所有粉丝 select * from tb_floow</span></span><br><span class="line">     List&lt;Follow&gt; list = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">     <span class="comment">// 博客发送给粉丝</span></span><br><span class="line">     <span class="keyword">for</span> (Follow follow : list) &#123;</span><br><span class="line">         <span class="comment">//获取粉丝ID</span></span><br><span class="line">         <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">         <span class="comment">//推送</span></span><br><span class="line">         stringRedisTemplate.opsForZSet().add(FEED_KEY+userId,blog.getId().toString(),System.currentTimeMillis());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 返回id</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-实现分页查询收邮箱"><a href="#好友关注-实现分页查询收邮箱" class="headerlink" title="好友关注-实现分页查询收邮箱"></a>好友关注-实现分页查询收邮箱</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</span><br><span class="line"></span><br><span class="line">具体操作如下：</span><br><span class="line">1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</span><br><span class="line">2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</span><br><span class="line">综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</span><br><span class="line">这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回数据定义</span><br><span class="line">@Data</span><br><span class="line">public class ScrollResult &#123;</span><br><span class="line">    private List&lt;?&gt; list;</span><br><span class="line">    private Long minTime;</span><br><span class="line">    private Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">     <span class="comment">//1.收件箱所有笔记</span></span><br><span class="line">     <span class="comment">//获取当前用户信息</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//滚动分页查询</span></span><br><span class="line">     Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(FEED_KEY + userId, <span class="number">0</span>, max, offset, <span class="number">3</span>);</span><br><span class="line">     <span class="comment">// 非空判断</span></span><br><span class="line">     <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.ok();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//查询收件箱</span></span><br><span class="line">     <span class="comment">//2. 解析数据 blogId、minTime、offset</span></span><br><span class="line">     List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">     <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> typedTuple.getValue();</span><br><span class="line">         ids.add(Long.valueOf(id));</span><br><span class="line">         <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">         <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">             os++;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 获取分数</span></span><br><span class="line">             minTime = time;</span><br><span class="line">             os = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获取根据ID查询blog</span></span><br><span class="line">     <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">     <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">     List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">     <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">         <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">         <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">         blog.setName(user.getNickName());</span><br><span class="line">         blog.setIcon(user.getIcon());</span><br><span class="line">         <span class="comment">// 3. 查询blog是否被点赞</span></span><br><span class="line">         <span class="comment">// 2. 判断当前登录是否已经点赞</span></span><br><span class="line">         <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(BLOG_LIKED_KEY + id, user.getId().toString());</span><br><span class="line">         blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     scrollResult.setList(blogs);</span><br><span class="line">     scrollResult.setOffset(os);</span><br><span class="line">     scrollResult.setMinTime(minTime);</span><br><span class="line">     <span class="comment">//封装返回数据</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</span><br><span class="line"></span><br><span class="line">* GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</span><br><span class="line">* GEODIST：计算指定的两个点之间的距离并返回</span><br><span class="line">* GEOHASH：将指定member的坐标转为hash字符串形式并返回</span><br><span class="line">* GEOPOS：返回指定member的坐标</span><br><span class="line">* GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</span><br><span class="line">* GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</span><br><span class="line">* GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</span><br></pre></td></tr></table></figure>

<h3 id="附近商户-导入店铺数据到GEO"><a href="#附近商户-导入店铺数据到GEO" class="headerlink" title="附近商户-导入店铺数据到GEO"></a>附近商户-导入店铺数据到GEO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">首先需要将坐标位置保存到Reids当中，按照店铺类型进行分类，存储到集合当中</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询店铺信息</span></span><br><span class="line">        List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">        <span class="comment">// 2. 把店铺分组，按照typeID分组，id一致的放到一个集合</span></span><br><span class="line">        Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">        <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取类型的id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">//3.2 获取同类型店铺的集合</span></span><br><span class="line">            List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入Redis 与下面写法效果是一样的</span></span><br><span class="line"><span class="comment">//            for (Shop shop : shops) &#123;</span></span><br><span class="line"><span class="comment">//                stringRedisTemplate.opsForGeo().add(SHOP_GEO_KEY+typeId,new Point(shop.getX(),shop.getY()),shop.getId().toString());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(shops.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">                locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 批量写</span></span><br><span class="line">            stringRedisTemplate.opsForGeo().add(SHOP_GEO_KEY + typeId, locations);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="附近商户-实现附近商户功能"><a href="#附近商户-实现附近商户功能" class="headerlink" title="附近商户-实现附近商户功能"></a>附近商户-实现附近商户功能</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</span><br><span class="line"></span><br><span class="line">第一步：导入pom</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 根据类型分页查询</span></span><br><span class="line">           Page&lt;Shop&gt; page = query()</span><br><span class="line">                   .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                   .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">           <span class="comment">// 返回数据</span></span><br><span class="line">           <span class="keyword">return</span> Result.ok(page);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2.计算分页参数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">       <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">       <span class="comment">//3. 查询redis，按照距离排序、分页‘；结果shopID .distance</span></span><br><span class="line"></span><br><span class="line">       GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(</span><br><span class="line">               SHOP_GEO_KEY + typeId,</span><br><span class="line">               GeoReference.fromCoordinate(x, y),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">               RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; content = results.getContent();</span><br><span class="line">       <span class="comment">//跳过没数据了，直接返回空集合就可以了</span></span><br><span class="line">       <span class="keyword">if</span> (content.size() &lt;= from) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(content.size());</span><br><span class="line">       Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(content.size());</span><br><span class="line">       <span class="comment">//截取从from到end</span></span><br><span class="line">       content.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">shopID</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">           ids.add(Long.valueOf(shopID));</span><br><span class="line">           <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">           distanceMap.put(shopID, distance);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       <span class="comment">// 解析id</span></span><br><span class="line">       List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">       shops.forEach(shop -&gt; &#123;</span><br><span class="line">           shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitMap 的高位和地位和正常是相反的，左边是低位，右边是高位 </span><br></pre></td></tr></table></figure>

<p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/1653824498278-58340c.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h3 id="用户签到-实现签到功能"><a href="#用户签到-实现签到功能" class="headerlink" title="用户签到-实现签到功能"></a>用户签到-实现签到功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 1 .获取当前登录的用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2. 获取日期</span></span><br><span class="line">     <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">     <span class="comment">// 3.拼接key</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userID + format;</span><br><span class="line">     <span class="comment">// 4. 今天是本月的第几天</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">     <span class="comment">// 5. 写入Redis</span></span><br><span class="line">     stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="连续签到"><a href="#连续签到" class="headerlink" title="连续签到"></a>连续签到</h3><p>这里其实有点问题，当天应该会签到上的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//1、 获取本月截至今天位置所有的签到记录</span></span><br><span class="line">      <span class="comment">// 1 .获取当前登录的用户</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">// 2. 获取日期</span></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      <span class="comment">// 3.拼接key</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userID + format;</span><br><span class="line">      <span class="comment">// 4. 今天是本月的第几天</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">      <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">      List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">              key,</span><br><span class="line">              BitFieldSubCommands.create()</span><br><span class="line">                      .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 没有任何签到结果</span></span><br><span class="line">          <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 6.循环遍历</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">          <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">              count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">          num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</span><br><span class="line">* PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</span><br><span class="line"></span><br><span class="line">通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</span><br><span class="line"></span><br><span class="line">UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</span><br><span class="line">Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：https://juejin.cn/post/6844903785744056333#heading-0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">他可以自动进行去重，加入就可以去重了</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/image-20250713205310390-fe7bd4.png" alt="image-20250713205310390"></p>
<h3 id="UV统计-测试百万数据的统计"><a href="#UV统计-测试百万数据的统计" class="headerlink" title="UV统计-测试百万数据的统计"></a>UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/07/13/1653838053608-9b6295.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>
<h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl alt m   快速给一段代码创建一个函数</span><br></pre></td></tr></table></figure>

<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableField(exist = false)</span><br><span class="line">表示不是数据库里面的字段</span><br></pre></td></tr></table></figure>

<h1 id="高级用法记录一下"><a href="#高级用法记录一下" class="headerlink" title="高级用法记录一下"></a>高级用法记录一下</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用stream流 </span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 解析出来用户ID</span></span><br><span class="line">        List&lt;Long&gt; ids = range.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        <span class="comment">//3. 根据用户ID查询用户 由于默认查出来是相反的顺序，所以需要这样处理是的顺序成正序</span></span><br><span class="line">        List&lt;User&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + join + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="comment">//4. 返回信息</span></span><br><span class="line">        List&lt;UserDTO&gt; collect = users.stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.ok(collect);</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="qq:860211327">Curry Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://curry-jay.github.io/posts/58965.html">https://curry-jay.github.io/posts/58965.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://curry-jay.github.io" target="_blank">Curry的小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Database/">Database</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/55889.html" title="mybatisPlus复习"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/mybatisPlus.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">mybatisPlus复习</div></div><div class="info-2"><div class="info-item-1">快速入门环境准备首先需要将数据库初始化，以及设置对应的配置文件，完成一些基本的设置  spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: 123456logging:  level:    com.itheima: debug  pattern:    dateformat: HH:mm:ssmybatis:  mapper-locations: classpath*:mapper/*.xml  快速开始对于使用mybatisPlus来讲，和mybatis区别是它集成好了一些已经定义完成的接口，可以方便我们后续的使用，他包含mybatis的所有功能   ...</div></div></div></a><a class="pagination-related" href="/posts/43782.html" title="Vue"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/Vue/Vue.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Vue</div></div><div class="info-2"><div class="info-item-1">VUE初始化npm i vue@2.6.13具体操作可以看nodejs文档列表模块：npm ls卸载模块：npm uninstall 模块名更新模块：npm update 模块名运行工程：npm run dev/test编译工程：npm run build  创建，构建一个IDEA（javascript项目） 并进入目录  vue init webpack     入门使用相当于new一个Vue对象  new Vue(&#123;        //选择一个组件和它进行绑定,产生一个绑定关系，和组件绑定起来        el: &quot;#app&quot;,        //数据进行绑定        data: &#123;    title: &#x27;VUE入门讲解&#x27;,&#125;        &#125;）          之后可以通过胡须表达式就可以获取到数据   &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;可以用@click...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/27273.html" title="Redis"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/Redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-05</div><div class="info-item-2">Redis</div></div><div class="info-2"><div class="info-item-1">Redis入门安装http://redis.io/download ; http://redis.cn/window版本解压Redis包即可  Redis目录介绍redis.window.conf    #【重要】reids配置文件redis-benchmark.exe   #reids压测工具redis-check-aof.exe    #aof文件校验、修复功能redis-check-rdb.exe    #rdb文件校验、修复功能redis-cli.exe    #【重要】命令行客户端，连接Redis服务端可对Redis进行相关操作redis-server.exe  #【重要】Redis服务器,启动Redis  启动启动redis-server进入到Redis安装目录，用CMD运行redis-server.exe redis.windows.conf    启动redis-client  启动本地redis-cli.exe启动其他服务器的Redisredis-cli.exe -h ip -p 端口   #如  redis-client.exe -h...</div></div></div></a><a class="pagination-related" href="/posts/62590.html" title="mybatis"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/mybatis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-05</div><div class="info-item-2">mybatis</div></div><div class="info-2"><div class="info-item-1">mybaits引入依赖  &lt;!--        引入mybatis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.8&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--        引入jdbc--&gt;        &lt;!--		mysql驱动依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;           ...</div></div></div></a><a class="pagination-related" href="/posts/6029.html" title="mysql使用"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/mysql.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-10</div><div class="info-item-2">mysql使用</div></div><div class="info-2"><div class="info-item-1"> MySQL 登录  密码 ：123456； 例如要到D盘，就输入D：找D盘下的某个文件夹，cd（空格）文件夹名  cd D:\developTool\MySQL\mysql-8.0.27-winx64\bin  .\mysql -u root -p MySql 操作：show databases;//查找后台数据mysql //保存用户信息information_schema//保存元数据信息performance_schema//搜集一些性能信息 sys//用于监控 前三个不可动  use +库名//进入一个库里面show tables //展示表中信息 show tables from 库名//查看其他所有库create table 库名（  列名 列类型，  列名 列类型，）；desc 表名 //查看表结构describe 表名；select *form 表名//查看表中结构INSERT INTO 表名 ( field1, field2,...fieldN )                       VALUES                       (...</div></div></div></a><a class="pagination-related" href="/posts/55889.html" title="mybatisPlus复习"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/mybatisPlus.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="info-item-2">mybatisPlus复习</div></div><div class="info-2"><div class="info-item-1">快速入门环境准备首先需要将数据库初始化，以及设置对应的配置文件，完成一些基本的设置  spring:  datasource:    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: 123456logging:  level:    com.itheima: debug  pattern:    dateformat: HH:mm:ssmybatis:  mapper-locations: classpath*:mapper/*.xml  快速开始对于使用mybatisPlus来讲，和mybatis区别是它集成好了一些已经定义完成的接口，可以方便我们后续的使用，他包含mybatis的所有功能   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/image/loading.gif" data-lazy-src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Curry Jay</div><div class="author-info-description">xjtu软件工程在读研究生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Curry-jay"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客，欢迎光临我的博客，刚开始搭建内容</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSQL%E4%B8%8ESQL%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.</span> <span class="toc-text">NoSQL与SQL的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">结构化与非结构化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%92%8C%E9%9D%9E%E5%85%B3%E8%81%94"><span class="toc-number">1.1.2.</span> <span class="toc-text">关联和非关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">查询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Redis"><span class="toc-number">1.2.</span> <span class="toc-text">认识Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wsl%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">wsl使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Redis"><span class="toc-number">1.4.</span> <span class="toc-text">安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%BA%93"><span class="toc-number">1.4.1.</span> <span class="toc-text">依赖库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%AE%89%E8%A3%85%E5%8C%85%E5%B9%B6%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">上传安装包并解压</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">启动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">默认启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">指定配置启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF"><span class="toc-number">1.5.3.</span> <span class="toc-text">开机自启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.5.4.</span> <span class="toc-text">Redis命令行客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">Redis常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.1.</span> <span class="toc-text">Redis通用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">String的常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">key结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.</span> <span class="toc-text">Set类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.6.</span> <span class="toc-text">SortedSet类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.7.</span> <span class="toc-text">java客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis"><span class="toc-number">1.7.1.</span> <span class="toc-text">Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">jedis连接池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringDataRedis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">SpringDataRedis客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">配置设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5RedisTemplate"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">注入RedisTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">编写测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">手动序列化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">2.1.</span> <span class="toc-text">短信登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">基于Session实现登录登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.2.</span> <span class="toc-text">实现发送短信验证码功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.3.</span> <span class="toc-text">实现登录功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.4.</span> <span class="toc-text">登录验证功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%88%B6%E4%BD%9C"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">拦截器制作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%88%B0%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8A"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">注册到拦截器上</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.5.</span> <span class="toc-text">隐藏用户敏感信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.6.</span> <span class="toc-text">session共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BB%A3%E6%9B%BFsession%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.7.</span> <span class="toc-text">Redis代替session的业务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">登录和注册功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD-1"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">登录验证功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.8.</span> <span class="toc-text">解决状态登录刷新问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.1.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">如何使用缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">添加商户缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">代码如下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">2.2.4.</span> <span class="toc-text">实现商铺和缓存与数据库双写一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.5.</span> <span class="toc-text">缓存穿透问题的解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.6.</span> <span class="toc-text">缓存雪崩问题及解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF-%E7%83%AD%E7%82%B9Key"><span class="toc-number">2.2.7.</span> <span class="toc-text">缓存击穿问题及解决思路(热点Key)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">缓存击穿问题出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">互斥锁解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">逻辑过期方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">2.2.7.4.</span> <span class="toc-text">对比分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.7.5.</span> <span class="toc-text">利用互斥锁解决缓存击穿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E9%94%81%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.7.5.1.</span> <span class="toc-text">操作锁的内容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.7.6.</span> <span class="toc-text">利用逻辑过期时间解决缓存击穿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E7%83%AD%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.7.6.1.</span> <span class="toc-text">预热函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E6%97%B6%E9%97%B4%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.7.6.2.</span> <span class="toc-text">利用逻辑时间解决问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Redis%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.2.8.</span> <span class="toc-text">封装Redis工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E6%83%A0%E5%88%B8"><span class="toc-number">2.3.</span> <span class="toc-text">秒杀优惠券</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">全局ID生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">实现方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">测试方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">注意——异步线程知识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%8D%B7"><span class="toc-number">2.3.2.</span> <span class="toc-text">添加优惠卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">实现优惠卷秒杀下单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.</span> <span class="toc-text">库存超卖问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">悲观锁：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">乐观锁：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">乐观锁解决超卖问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80-%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">2.3.5.</span> <span class="toc-text">优惠券秒杀-一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">修改方案——判断是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">优化——悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%B2%BE%E7%A1%AE%E9%94%81%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">继续优化，精确锁控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">继续优化——事务处理放置位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.6.</span> <span class="toc-text">集群环境下的并发问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">2.4.1.</span> <span class="toc-text">Redis分布式锁的实现核心思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E6%83%85%E5%86%B5%E8%AF%B4%E6%98%8E"><span class="toc-number">2.4.2.</span> <span class="toc-text">Redis分布式锁误删情况说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">解决Redis分布式锁误删问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.4.</span> <span class="toc-text">分布式锁的原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.5.</span> <span class="toc-text">Lua脚本解决多条命令原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Java%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8Lua%E8%84%9A%E6%9C%AC%E6%94%B9%E9%80%A0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.4.6.</span> <span class="toc-text">利用Java代码调用Lua脚本改造分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%96%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.7.</span> <span class="toc-text">改善问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission"><span class="toc-number">2.5.</span> <span class="toc-text">分布式锁-redission</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E5%AE%9E%E7%8E%B0%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.1.</span> <span class="toc-text">上述实现存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redission%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">分布式锁-Redission快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.3.</span> <span class="toc-text">分布式锁-redission可重入锁原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8CWatchDog%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.4.</span> <span class="toc-text">分布式锁-redission锁重试和WatchDog机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission%E9%94%81%E7%9A%84MutiLock%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.5.</span> <span class="toc-text">分布式锁-redission锁的MutiLock原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">2.6.</span> <span class="toc-text">秒杀优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96-Redis%E5%AE%8C%E6%88%90%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E5%88%A4%E6%96%AD"><span class="toc-number">2.6.1.</span> <span class="toc-text">秒杀优化-Redis完成秒杀资格判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96-%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">2.6.2.</span> <span class="toc-text">秒杀优化-基于阻塞队列实现秒杀优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.7.</span> <span class="toc-text">Redis消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E4%BA%8EList%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.7.1.</span> <span class="toc-text">Redis消息队列-基于List实现消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.7.2.</span> <span class="toc-text">Redis消息队列-基于PubSub的消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.7.3.</span> <span class="toc-text">Redis消息队列-基于Stream的消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">2.7.4.</span> <span class="toc-text">Redis消息队列-基于Stream的消息队列-消费者组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.5.</span> <span class="toc-text">对比总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84Stream%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">2.7.6.</span> <span class="toc-text">基于Redis的Stream结构作为消息队列，实现异步秒杀下单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">2.8.</span> <span class="toc-text">达人探店</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97-%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">达人探店-发布探店笔记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97-%E6%9F%A5%E7%9C%8B%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">2.8.2.</span> <span class="toc-text">达人探店-查看探店笔记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97-%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD"><span class="toc-number">2.8.3.</span> <span class="toc-text">达人探店-点赞功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97-%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">2.8.4.</span> <span class="toc-text">达人探店-点赞排行榜</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">2.9.</span> <span class="toc-text">好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8-%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E6%B6%88%E5%85%B3%E6%B3%A8"><span class="toc-number">2.9.1.</span> <span class="toc-text">好友关注-关注和取消关注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8-%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">好友关注-共同关注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8-Feed%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">2.9.3.</span> <span class="toc-text">好友关注-Feed流实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B9%9F%E5%8F%AB%E5%81%9A%E8%AF%BB%E6%89%A9%E6%95%A3"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">拉模式：也叫做读扩散</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B9%9F%E5%8F%AB%E5%81%9A%E5%86%99%E6%89%A9%E6%95%A3%E3%80%82"><span class="toc-number">2.9.3.2.</span> <span class="toc-text">推模式：也叫做写扩散。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E6%8B%89%E7%BB%93%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.9.3.3.</span> <span class="toc-text">推拉结合模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">2.9.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8-%E6%8E%A8%E9%80%81%E5%88%B0%E7%B2%89%E4%B8%9D%E6%94%B6%E4%BB%B6%E7%AE%B1"><span class="toc-number">2.9.4.</span> <span class="toc-text">好友关注-推送到粉丝收件箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%94%B6%E9%82%AE%E7%AE%B1"><span class="toc-number">2.9.5.</span> <span class="toc-text">好友关注-实现分页查询收邮箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7"><span class="toc-number">2.10.</span> <span class="toc-text">附近商户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7-%E5%AF%BC%E5%85%A5%E5%BA%97%E9%93%BA%E6%95%B0%E6%8D%AE%E5%88%B0GEO"><span class="toc-number">2.10.1.</span> <span class="toc-text">附近商户-导入店铺数据到GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7-%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">2.10.2.</span> <span class="toc-text">附近商户-实现附近商户功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">2.10.3.</span> <span class="toc-text">实现代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-number">2.11.</span> <span class="toc-text">用户签到</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0-%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">2.11.1.</span> <span class="toc-text">用户签到-实现签到功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0"><span class="toc-number">2.11.2.</span> <span class="toc-text">连续签到</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.12.</span> <span class="toc-text">UV统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1-%E6%B5%8B%E8%AF%95%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.12.1.</span> <span class="toc-text">UV统计-测试百万数据的统计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.</span> <span class="toc-text">IDEA快捷键</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B"><span class="toc-number">5.</span> <span class="toc-text">高级用法记录一下</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3876.html" title="Consul服务中心"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/consul.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Consul服务中心"/></a><div class="content"><a class="title" href="/posts/3876.html" title="Consul服务中心">Consul服务中心</a><time datetime="2025-09-08T14:54:09.000Z" title="发表于 2025-09-08 22:54:09">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/0.html" title="无标题"><img src= "/image/loading.gif" data-lazy-src="/image/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/posts/0.html" title="无标题">无标题</a><time datetime="2025-09-08T14:54:02.407Z" title="发表于 2025-09-08 22:54:02">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/47860.html" title="back/Linux/Docker复习"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/Linux/docker.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="back/Linux/Docker复习"/></a><div class="content"><a class="title" href="/posts/47860.html" title="back/Linux/Docker复习">back/Linux/Docker复习</a><time datetime="2025-09-02T12:19:40.000Z" title="发表于 2025-09-02 20:19:40">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55889.html" title="mybatisPlus复习"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/mybatisPlus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatisPlus复习"/></a><div class="content"><a class="title" href="/posts/55889.html" title="mybatisPlus复习">mybatisPlus复习</a><time datetime="2025-07-26T09:26:46.000Z" title="发表于 2025-07-26 17:26:46">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/58965.html" title="Redis原理和实战"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/Redis-1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis原理和实战"/></a><div class="content"><a class="title" href="/posts/58965.html" title="Redis原理和实战">Redis原理和实战</a><time datetime="2025-07-13T13:05:12.000Z" title="发表于 2025-07-13 21:05:12">2025-07-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/top/back/Database/Redis-1.png);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Curry Jay</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎光临我的小屋!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.2.2"></script><script src="/js/main.js?v=5.2.2"></script><script src="/js/tw_cn.js?v=5.2.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="/config/js/catagory.js?1"></script><script src="https://cdn.staticfile.net/jquery/3.7.1/jquery.min.js"></script><script type="text/javascript" src="/config/js/rightmenu.js?1"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script><script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/index.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.2.2"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/生活/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 生活趣闻 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/后端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 后端学习 (18)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/其他/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧑‍💻 其他内容 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🕵️ 前端学习 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/比赛/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">⛹️‍♂️ 比赛内容 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/学校学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🏫 学校学习记录 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/软件使用/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🖥️ 软件使用技巧 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://curry-jay.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #49B1F5}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18872.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "/image/loading.gif" data-lazy-src="/image/top_first.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18872.html&quot;);" href="javascript:void(0);" alt="">欢迎来到我的小屋</a><div class="blog-slider__text">由于笔记放在实验室电脑和自己电脑上查询不方便，所以想做一个博客将这些东西整合起来！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18872.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/48081.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "/image/loading.gif" data-lazy-src="/image/top/Live/toDoList.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/48081.html&quot;);" href="javascript:void(0);" alt="">待办清单</a><div class="blog-slider__text">统计一下待办清单!</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/48081.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>