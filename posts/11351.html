<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javaScript | Curry的小屋</title><meta name="author" content="Curry Jay"><meta name="copyright" content="Curry Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="javaScript讲解">
<meta property="og:type" content="article">
<meta property="og:title" content="javaScript">
<meta property="og:url" content="https://curry-jay.github.io/posts/11351.html">
<meta property="og:site_name" content="Curry的小屋">
<meta property="og:description" content="javaScript讲解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://curry-jay.github.io/image/top/front/javaScript/javaScript.jpg">
<meta property="article:published_time" content="2025-01-05T15:40:38.000Z">
<meta property="article:modified_time" content="2025-06-27T10:20:49.839Z">
<meta property="article:author" content="Curry Jay">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="javaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://curry-jay.github.io/image/top/front/javaScript/javaScript.jpg"><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="https://curry-jay.github.io/posts/11351.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.2.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Curry Jay","link":"链接: ","source":"来源: Curry的小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javaScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/config/css/custom_homeCenter.css?v1"><link rel="stylesheet" href="/config/css/catagory.css?v1"><link rel="stylesheet" href="/config/css/tag.css?v1"><link rel="stylesheet" href="/config/css/rightmenu.css?v1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/theme-chalk/index.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fas fa-angle-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fas fa-angle-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fas fa-sync-alt"></i></div><div class="rightMenu-item" id="menu-darkmode"><i class="fas fa-adjust"></i></div><a class="rightMenu-item" href="/" id="menu-home"><i class="fas fa-home"></i></a></div><div class="rightMenu-group rightMenu-line rightMenuPost"><div class="rightMenu-item" id="menu-reading"><i class="fas fa-book"></i><span>阅读模式</span></div><div class="rightMenu-item" id="menu-postlink"><i class="fas fa-link"></i><span>复制本文地址</span></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="fas fa-copy"></i><span>复制内容</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="fas fa-paste"></i><span>粘贴内容</span></div><div class="rightMenu-item" id="menu-search"><i class="fas fa-search"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="fab fa-internet-explorer"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="fas fa-external-link-alt"></i><span>新建窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="fas fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="fas fa-image"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="fas fa-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-copylinkimg"><i class="fas fa-link"></i><span>复制图片链接</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-translate"><i class="fas fa-language"></i><span>繁简转换</span></a><div class="rightMenu-item" id="menu-asidehide"><i class="fas fa-bars"></i><span>边栏控制</span></div></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="/tags/" id="menu-tags"><i class="fas fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="/posts/48081.html" id="menu-waitToDo"><i class="fas fa-th-list"></i><span>待办清单</span></a><a class="rightMenu-item" href="/categories/" id="menu-folder-open"><i class="fas fa-folder-open"></i><span>博客分类</span></a><a class="rightMenu-item" href="/posts/18872.html" id="menu-copyright"><i class="fas fa-copyright"></i><span>初衷申明</span></a></div></div><div id="rightMenu-mask"></div><div id="web_bg" style="background-color: #c0c3c5;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/image/loading.gif" data-lazy-src="/image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-pie-chart"></i><span> 统计</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/image/top/front/javaScript/javaScript.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "/image/loading.gif" data-lazy-src="/image/curry.jpg" alt="Logo"><span class="site-name">Curry的小屋</span></a><a class="nav-page-title" href="/"><span class="site-name">javaScript</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-pie-chart"></i><span> 统计</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div><div id="nav-right"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></span></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">javaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-05T15:40:38.000Z" title="发表于 2025-01-05 23:40:38">2025-01-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-27T10:20:49.839Z" title="更新于 2025-06-27 18:20:49">2025-06-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/javaScript/">javaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="javaScript基本用法"><a href="#javaScript基本用法" class="headerlink" title="javaScript基本用法"></a>javaScript基本用法</h1><h2 id="表示形式-引入方式"><a href="#表示形式-引入方式" class="headerlink" title="表示形式&#x2F;引入方式"></a>表示形式&#x2F;引入方式</h2><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>对于js的使用，一般显示有三种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入格式</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;你好啊&#x27;</span>) --在网页弹出层弹出一个窗口展示</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;手动写入&#x27;</span>) -- 直接写入内容将页面改写成这个样式</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message&#x27;</span>) --在控制台打印信息</span><br><span class="line">innerHTML = <span class="string">&quot;段落已修改。&quot;</span> 是用于修改元素的 <span class="variable constant_">HTML</span> 内容(innerHTML)的 <span class="title class_">JavaScript</span> 代码。</span><br><span class="line"></span><br><span class="line">输入代码</span><br><span class="line">&lt;button onclick=<span class="string">&quot;prompt(&#x27;请输入你的名字&#x27;)&quot;</span>&gt;控制台&lt;/button&gt;</span><br><span class="line">点击完成后弹出一个输入框让你进行输入</span><br><span class="line">num = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入&#x27;</span>);</span><br><span class="line">也可以这样书写，让输入的值保存在num里面</span><br></pre></td></tr></table></figure>

<h3 id="对于js代码的引入"><a href="#对于js代码的引入" class="headerlink" title="对于js代码的引入"></a>对于js代码的引入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">首先可以元素内引入，如以下三种方式为例子：</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;alert(&#x27;你好啊&#x27;)&quot;</span> value=<span class="string">&quot;点我&quot;</span>&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;控制台打印！&#x27;)&quot;</span>&gt;</span>控制台<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;点我&#x27;);&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以script标签引入</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;根据script标签在控制台打印&quot;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">第三种方式，可以自己写一个js文件后缀，用script引入</span><br><span class="line">&lt;script src=<span class="string">&quot;demo.js&quot;</span>&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>对于引入来说，执行顺序按照引入的先后顺序来进行执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于第三种方式js方式的引入，不可以在script标签里面继续写方法，不会执行</span><br><span class="line">&lt;script src=<span class="string">&quot;demo.js&quot;</span>&gt;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;根据script标签在控制台打印&quot;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">方法体里面的<span class="variable language_">console</span>语句不会执行</span><br></pre></td></tr></table></figure>

<h2 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h2><p>对于javascript来讲，大小写敏感，所以对于变量的命名以及使用来说，大小写的书写一定要规范。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于变量声明来说，如果不声明直接使用，会报错</span><br><span class="line">如果声明没有赋值，那么会<span class="literal">undefined</span></span><br><span class="line">如果不声明直接赋值，js允许，但是会未全局变量，不提倡</span><br><span class="line">如果重新声明 <span class="title class_">JavaScript</span> 变量，该变量的值不会丢失：</span><br><span class="line"></span><br><span class="line">函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖</span><br></pre></td></tr></table></figure>

<h2 id="对于let-var-const的区别"><a href="#对于let-var-const的区别" class="headerlink" title="对于let,var,const的区别"></a>对于let,var,const的区别</h2><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419153109858-269692.png" alt="image-20230419153109858"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在 <span class="title class_">ES6</span> 之前，是没有块级作用域的概念的。</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES6</span> 可以使用 <span class="keyword">let</span> 关键字来实现块级作用域。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 声明的变量只在 <span class="keyword">let</span> 命令所在的代码块 &#123;&#125; 内有效，在 &#123;&#125; 之外不能访问。</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">值类型(基本类型)：字符串（<span class="title class_">String</span>）、数字(<span class="title class_">Number</span>)、布尔(<span class="title class_">Boolean</span>)、空（<span class="title class_">Null</span>）、未定义（<span class="title class_">Undefined</span>）、<span class="title class_">Symbol</span>。</span><br><span class="line"></span><br><span class="line">引用数据类型（对象类型）：对象(<span class="title class_">Object</span>)、数组(<span class="title class_">Array</span>)、函数(<span class="title class_">Function</span>)，还有两个特殊的对象：正则（<span class="title class_">RegExp</span>）和日期（<span class="title class_">Date</span>）。</span><br><span class="line"></span><br><span class="line">我的理解是值类型就是引用值，数据类型相当于指针的意思</span><br></pre></td></tr></table></figure>

<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419163224483-c3d614.png" alt="image-20230419163224483"></p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419163247110-460216.png" alt="image-20230419163247110"></p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230419163304250-a165d4.png" alt="image-20230419163304250"></p>
<h2 id="对象概念"><a href="#对象概念" class="headerlink" title="对象概念"></a>对象概念</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来说，里面的数据都是对象的形式，即<span class="attr">name</span>:value键值对的存储形式，相当于java的类吧</span><br><span class="line">对于一个对象可以这样定义：</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    id : <span class="number">5566</span>,</span><br><span class="line">    fullName : <span class="keyword">function</span>(<span class="params"></span>) </span><br><span class="line">	&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">在上面的定义中，定义了三个属性和一个方法，</span><br><span class="line">对于属性的访问，一般有两种方法person.<span class="property">lastName</span>; person[<span class="string">&quot;lastName&quot;</span>];</span><br><span class="line"></span><br><span class="line">这两个方法，第一个方法有时候不能使用，第二个方法通用</span><br><span class="line">两种情况不能使用：属性名包含特殊字符</span><br><span class="line">				对于属性名给定的属性不确定，即给定的属性不是一个常量是一个变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于方法的调用person.<span class="title function_">fullName</span>();不添加 (), 它会返回函数的定义：</span><br><span class="line">对于方法的创建：</span><br><span class="line">methodName : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于javascript里面的函数定义来说</span><br><span class="line">function functionname()</span><br><span class="line">&#123;</span><br><span class="line">    // 执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="局部变量和全局变量创建区别"><a href="#局部变量和全局变量创建区别" class="headerlink" title="局部变量和全局变量创建区别"></a>局部变量和全局变量创建区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于局部变量来说，一般存在函数内，函数开始执行时创建，函数执行完后局部变量会自动销毁。</span><br><span class="line"><span class="comment">// 此处不能调用 carName 变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 函数内可调用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">变量在函数外定义，即为全局变量</span><br><span class="line">全局变量有 全局作用域: 网页中所有脚本和函数均可使用。 </span><br><span class="line">全局变量在函数内修改和外部修改效果一样</span><br><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot; Volvo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数内可调用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但要注意的一点是，如果在函数里面申明变量没有<span class="keyword">var</span>，那么为全局变量</span><br><span class="line"><span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处可调用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对于获取一个元素"><a href="#对于获取一个元素" class="headerlink" title="对于获取一个元素"></a>对于获取一个元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于获取一个元素id的时候，可以采用下面的方法,参数传入id</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">一定一定要注意大小写，以及格式，报错</span><br><span class="line"><span class="title class_">Document</span>.<span class="property">getElementById</span> is not a <span class="keyword">function</span>  可能就是大小写出错！！</span><br></pre></td></tr></table></figure>

<h2 id="this作用域"><a href="#this作用域" class="headerlink" title="this作用域"></a>this作用域</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果对于函数调用默认是<span class="variable language_">window</span>，对于元素标签内调用为元素本身，如果<span class="keyword">new</span>一个然后再<span class="keyword">new</span>的进行调用，那么就是<span class="keyword">new</span>出来的结果</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）<span class="variable language_">this</span>的指向是在函数执行的时候确定的，在函数定义的时候是确定不了，实际上<span class="variable language_">this</span>的最终指向的是那个调用它的对象</span><br><span class="line">（<span class="number">2</span>）调用执行函数时，“.”前面是什么，<span class="variable language_">this</span>就是什么。前面没有对象，就是<span class="variable language_">window</span>了。</span><br><span class="line"></span><br><span class="line">在方法中，<span class="variable language_">this</span> 表示该方法所属的对象。</span><br><span class="line">如果单独使用，<span class="variable language_">this</span> 表示全局对象。</span><br><span class="line">在函数中，<span class="variable language_">this</span> 表示全局对象。</span><br><span class="line">在函数中，在严格模式下，<span class="variable language_">this</span> 是未定义的(<span class="literal">undefined</span>)。</span><br><span class="line">在事件中，<span class="variable language_">this</span> 表示接收事件的元素。</span><br><span class="line">类似 <span class="title function_">call</span>() 和 <span class="title function_">apply</span>() 方法可以将 <span class="variable language_">this</span> 引用到任何对象。</span><br><span class="line"></span><br><span class="line">对于call和apply方法来讲，可以对<span class="variable language_">this</span>进行重新定义，举个简单的例子，对于一个对象里面的方法，在外面重新定义的对象可以重定向进行使用，看下面的例子：</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.<span class="property">fullName</span>.<span class="title function_">call</span>(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line">同样的，一个函数可以当作一个对象，可以对外面函数直接进行<span class="variable language_">this</span>转化调用，具体请看<span class="variable constant_">CSDN</span>博客，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">call</span>() 和 <span class="title function_">apply</span>() 之间的区别</span><br><span class="line">不同之处是：</span><br><span class="line"><span class="title function_">call</span>() 方法分别接受参数。</span><br><span class="line"><span class="title function_">apply</span>() 方法接受数组形式的参数。</span><br><span class="line">如果要使用数组而不是参数列表，则 <span class="title function_">apply</span>() 方法非常方便</span><br></pre></td></tr></table></figure>

<h2 id="常见的HTML事件"><a href="#常见的HTML事件" class="headerlink" title="常见的HTML事件"></a>常见的HTML事件</h2><table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">鼠标指针移动到指定的元素上时发生</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个 HTML 元素上移开鼠标时发生</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">浏览器已完成页面的加载</td>
</tr>
</tbody></table>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于string字符串来讲，首先可以用单引号或者双引号都创建一个字符</span><br><span class="line">可以用索引寻找字符串中的一个字符</span><br><span class="line">可以在字符串里面使用引号，但是得注意引号不能相同</span><br><span class="line">如果引号相同需要使用转义字符\  <span class="attr">eg</span>:\<span class="string">&#x27; \&quot;</span></span><br><span class="line"><span class="string">可以用内置函数length来获取字符串长度</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">也可以将字符串创建为对象</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span>; <span class="comment">//string类型</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">//object类型</span></span><br><span class="line">x != y 对象不同不相等</span><br><span class="line">一般不推荐string对象，因为会拖慢执行速度，并可能产生其他副作用</span><br></pre></td></tr></table></figure>

<h3 id="注意一点"><a href="#注意一点" class="headerlink" title="注意一点"></a>注意一点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来讲，在进行字符串比较的时候，==是进行值比较</span><br><span class="line">举个例子：</span><br><span class="line">	<span class="number">10</span> ==  <span class="literal">true</span></span><br><span class="line"> 	<span class="number">10</span> === <span class="string">&quot;10&quot;</span> <span class="literal">false</span></span><br><span class="line">两个等号是值相等，三个等号是连类型也进行判断，要注意误区</span><br><span class="line">t</span><br></pre></td></tr></table></figure>



<h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来讲，<span class="keyword">break</span>语句，不仅仅可以在循环中使用，还可以在其他地方</span><br><span class="line"><span class="keyword">continue</span> 语句（带有或不带标签引用）只能用在循环中。</span><br><span class="line"><span class="keyword">break</span> 语句（不带标签引用），只能用在循环或 <span class="keyword">switch</span> 中。</span><br><span class="line">通过标签引用，<span class="keyword">break</span> 语句可用于跳出任何 <span class="title class_">JavaScript</span> 代码块：</span><br><span class="line">eg：cars=[<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Ford&quot;</span>];</span><br><span class="line"><span class="attr">list</span>: </span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">0</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">1</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">2</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="keyword">break</span> list;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">3</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">4</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(cars[<span class="number">5</span>] + <span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于二者的区别来讲</span><br><span class="line"><span class="literal">null</span>是一个只有一个值的特殊类型，表示一个空对象引用，一般常用来对于大对象数据的释放等</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span>表示没有设置值的一个对象，相当于声明这个变量了，但是没有给这个变量赋值，相当于没有赋值变量的默认值</span><br><span class="line"></span><br><span class="line">对于两者的区别：</span><br><span class="line">	<span class="literal">null</span>是object对象类型的数据，<span class="literal">undefined</span>是表示<span class="literal">undefined</span>类型数据</span><br><span class="line">	对于二者的值来比较是相同的，但是类型是不同的</span><br><span class="line">	<span class="literal">null</span> == <span class="literal">undefined</span>   <span class="literal">true</span></span><br><span class="line">	<span class="literal">null</span> === <span class="literal">undefined</span> 	<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于javascript来讲，他是支持正则表达式，它把正则表达式当作一个对象来进行处理</span><br><span class="line"></span><br><span class="line">语法 : <span class="regexp">/正则表达式主体/</span>修饰符(可选)</span><br><span class="line"></span><br><span class="line">首先对于字符串来讲，有两个函数支持正则表达式</span><br><span class="line"><span class="title function_">search</span>() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</span><br><span class="line"><span class="title function_">replace</span>() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">RegExp</span>对象，在javascript里面定义了正则化对象，</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>() 方法是一个正则表达式方法。</span><br><span class="line"><span class="title function_">test</span>() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="title function_">exec</span>() 方法是一个正则表达式方法。</span><br><span class="line"><span class="title function_">exec</span>() 方法用于检索字符串中的正则表达式的匹配。</span><br><span class="line">该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 <span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h2 id="debugger关键字"><a href="#debugger关键字" class="headerlink" title="debugger关键字"></a>debugger关键字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="keyword">debugger</span>关键字，可以在进行测试以及调试的时候，在此处暂停<span class="title class_">JavaScript</span>的运行，从而进行调试，其原理和在编译器设置duan</span><br></pre></td></tr></table></figure>

<h2 id="‘use-strict’严格模式"><a href="#‘use-strict’严格模式" class="headerlink" title="‘use strict’严格模式"></a>‘use strict’严格模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">JavaScript</span>来讲用来规范程序员的代码书写规范，所以一般使用严格模式来进行约束，严格了一些格式书写上面的错误以及规范写法，函数不声明不能赋值等问题，详细参考菜鸟教程</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript验证API"><a href="#JavaScript验证API" class="headerlink" title="JavaScript验证API"></a>JavaScript验证API</h2><p>约束验证DOM方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">checkValidity</span>()		如果 input 元素中的数据是合法的返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">setCustomValidity</span>()	</span><br><span class="line">设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。相当于如果发生错误会显示什么。</span><br><span class="line"></span><br><span class="line">使用 setCustomValidity 设置了自定义提示后，</span><br><span class="line">validity.<span class="property">customError</span> 就会变成 <span class="literal">true</span>，</span><br><span class="line">checkValidity 总是会返回 <span class="literal">false</span>。如果要重新判断需要取消自定义提示，方式如下：</span><br><span class="line"><span class="title function_">setCustomValidity</span>(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line"><span class="title function_">setCustomValidity</span>(<span class="literal">null</span>) </span><br><span class="line"><span class="title function_">setCustomValidity</span>(<span class="literal">undefined</span>)</span><br><span class="line">有着三种方法，选一种即可</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">validity</td>
<td align="left">布尔属性值，返回 input 输入值是否合法</td>
</tr>
<tr>
<td align="left">validationMessage</td>
<td align="left">浏览器错误提示信息</td>
</tr>
<tr>
<td align="left">willValidate</td>
<td align="left">指定 input 是否需要验证</td>
</tr>
</tbody></table>
<h3 id="validity的一些属性值"><a href="#validity的一些属性值" class="headerlink" title="validity的一些属性值"></a>validity的一些属性值</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">customError</td>
<td align="left">设置为 true, 如果设置了自定义的 validity 信息。</td>
</tr>
<tr>
<td align="left">patternMismatch</td>
<td align="left">设置为 true, 如果元素的值不匹配它的模式属性。</td>
</tr>
<tr>
<td align="left">rangeOverflow</td>
<td align="left">设置为 true, 如果元素的值大于设置的最大值。</td>
</tr>
<tr>
<td align="left">rangeUnderflow</td>
<td align="left">设置为 true, 如果元素的值小于它的最小值。</td>
</tr>
<tr>
<td align="left">stepMismatch</td>
<td align="left">设置为 true, 如果元素的值不是按照规定的 step 属性设置。</td>
</tr>
<tr>
<td align="left">tooLong</td>
<td align="left">设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。</td>
</tr>
<tr>
<td align="left">typeMismatch</td>
<td align="left">设置为 true, 如果元素的值不是预期相匹配的类型。</td>
</tr>
<tr>
<td align="left">valueMissing</td>
<td align="left">设置为 true，如果元素 (required 属性) 没有值。</td>
</tr>
<tr>
<td align="left">valid</td>
<td align="left">设置为 true，如果元素的值是合法的。</td>
</tr>
</tbody></table>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span> 英文全称 <span class="title class_">JavaScript</span> <span class="title class_">Object</span> <span class="title class_">Notation</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>可以当作js对象的字符串表示，本质上是一个字符串，他的表达形式和js对象字符串类似</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>()	用于将一个 <span class="title class_">JSON</span> 字符串转换为 <span class="title class_">JavaScript</span> 对象。</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>()	用于将 <span class="title class_">JavaScript</span> 值转换为 <span class="title class_">JSON</span> 字符串。</span><br></pre></td></tr></table></figure>

<h2 id="与javascript-void-0"><a href="#与javascript-void-0" class="headerlink" title="#与javascript:void(0)"></a>#与javascript:void(0)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">href=<span class="string">&quot;#&quot;</span>与href=<span class="string">&quot;javascript:void(0)&quot;</span>的区别</span><br><span class="line">首先对于<span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>)来讲，它相当于javascript去运行一个没有返回值的函数，这里代表运行<span class="number">0</span>也相当于啥也没有运行 <span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="title function_">func</span>())一般形式这样表示</span><br><span class="line"></span><br><span class="line"># 包含了一个位置信息，默认的锚是#top 也就是网页的上端。</span><br><span class="line">而<span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>), 仅仅表示一个死链接。</span><br><span class="line">在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。</span><br><span class="line">如果你要定义一个死链接请使用 <span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>) 。</span><br></pre></td></tr></table></figure>

<h2 id="Iterator-接口和for-of"><a href="#Iterator-接口和for-of" class="headerlink" title="Iterator 接口和for of"></a>Iterator 接口和for of</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">默认的 <span class="title class_">Iterator</span> 接口部署在数据结构的<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性，或者说，一个数据结构只要具有<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性，就可以认为是“可遍历的”（iterable）。<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器</span><br><span class="line"></span><br><span class="line">对于<span class="title class_">ES6</span>来讲，一些原生属性配置了这个属性，自然可以使用遍历，以下属性：</span><br><span class="line"><span class="title class_">Array</span></span><br><span class="line"><span class="title class_">Map</span></span><br><span class="line"><span class="title class_">Set</span></span><br><span class="line"><span class="title class_">String</span></span><br><span class="line"><span class="title class_">TypedArray</span></span><br><span class="line">函数的 <span class="variable language_">arguments</span> 对象</span><br><span class="line"><span class="title class_">NodeList</span> 对象</span><br><span class="line"></span><br><span class="line"><span class="attr">eg</span>:</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于类似数组的对象（存在数值键名和length属性），部署 <span class="title class_">Iterator</span> 接口，有一个简便方法，就是<span class="title class_">Symbol</span>.<span class="property">iterator</span>方法直接引用数组的 <span class="title class_">Iterator</span> 接口。</span><br><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串也是类似的一个数组的对象，也原生具有 <span class="title class_">Iterator</span> 接口。</span><br><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">iterator.<span class="title function_">next</span>() -&gt;完成对字符串的遍历</span><br></pre></td></tr></table></figure>

<h3 id="最简单实现"><a href="#最简单实现" class="headerlink" title="最简单实现"></a>最简单实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// &quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">iterator</span>()方法几乎不用部署任何代码，只要用 <span class="keyword">yield</span> 命令给出每一步的返回值即可。</span><br></pre></td></tr></table></figure>

<h3 id="现有数据结构对iterator使用"><a href="#现有数据结构对iterator使用" class="headerlink" title="现有数据结构对iterator使用"></a>现有数据结构对iterator使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">entries</span>() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 <span class="title class_">Set</span>，键名与键值相同。<span class="title class_">Map</span> 结构的 <span class="title class_">Iterator</span> 接口，默认就是调用entries方法。</span><br><span class="line"><span class="title function_">keys</span>() 返回一个遍历器对象，用来遍历所有的键名。</span><br><span class="line"><span class="title function_">values</span>() 返回一个遍历器对象，用来遍历所有的键值。</span><br></pre></td></tr></table></figure>



<h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一个数据结构只要部署了<span class="title class_">Symbol</span>.<span class="property">iterator</span>属性，就被视为具有 iterator 接口，就可以用<span class="keyword">for</span>...<span class="keyword">of</span>循环遍历它的成员。也就是说，<span class="keyword">for</span>...<span class="keyword">of</span>循环内部调用的是数据结构的<span class="title class_">Symbol</span>.<span class="property">iterator</span>方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于<span class="keyword">for</span> <span class="keyword">of</span>对<span class="title class_">Set</span> 结构遍历时，返回的是一个值，而 <span class="title class_">Map</span> 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 <span class="title class_">Map</span> 成员的键名和键值。</span><br></pre></td></tr></table></figure>

<h3 id="for…in-和for…of区别"><a href="#for…in-和for…of区别" class="headerlink" title="for…in 和for…of区别"></a>for…in 和for…of区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JavaScript</span> 原有的<span class="keyword">for</span>...<span class="keyword">in</span>循环，只能获得对象的键名，不能直接获取键值。<span class="title class_">ES6</span> 提供<span class="keyword">for</span>...<span class="keyword">of</span>循环，允许遍历获得键值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>...<span class="keyword">of</span>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<span class="keyword">for</span>...<span class="keyword">in</span>循环也不一样。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">即<span class="keyword">for</span> <span class="keyword">in</span> 还会返回属性值，但是<span class="keyword">for</span> <span class="keyword">of</span>只会返回数组遍历器循环的值</span><br><span class="line"></span><br><span class="line">但是对于普通的对象，必须有iterator接口才可以调用<span class="keyword">for</span> <span class="keyword">of</span>方法，但是<span class="keyword">for</span> <span class="keyword">in</span>方法就可以直接使用，返回键名</span><br></pre></td></tr></table></figure>

<h3 id="其他遍历语法区别"><a href="#其他遍历语法区别" class="headerlink" title="其他遍历语法区别"></a>其他遍历语法区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">以数组为例，<span class="title class_">JavaScript</span> 提供多种遍历语法。最原始的写法就是<span class="keyword">for</span>循环。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br><span class="line">这种写法比较麻烦，因此数组提供内置的forEach方法。</span><br><span class="line"></span><br><span class="line">myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line">这种写法的问题在于，无法中途跳出forEach循环，<span class="keyword">break</span>命令或<span class="keyword">return</span>命令都不能奏效。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>循环可以遍历数组的键名。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>循环有几个缺点。</span><br><span class="line"></span><br><span class="line">数组的键名是数字，但是<span class="keyword">for</span>...<span class="keyword">in</span>循环是以字符串作为键名“<span class="number">0</span>”、“<span class="number">1</span>”、“<span class="number">2</span>”等等。</span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</span><br><span class="line">某些情况下，<span class="keyword">for</span>...<span class="keyword">in</span>循环会以任意顺序遍历键名。</span><br><span class="line">总之，<span class="keyword">for</span>...<span class="keyword">in</span>循环主要是为遍历对象而设计的，不适用于遍历数组。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">of</span>循环相比上面几种做法，有一些显著的优点。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">有着同<span class="keyword">for</span>...<span class="keyword">in</span>一样的简洁语法，但是没有<span class="keyword">for</span>...<span class="keyword">in</span>那些缺点。</span><br><span class="line">不同于forEach方法，它可以与<span class="keyword">break</span>、<span class="keyword">continue</span>和<span class="keyword">return</span>配合使用。</span><br><span class="line">提供了遍历所有数据结构的统一操作接口。</span><br><span class="line">下面是一个使用 <span class="keyword">break</span> 语句，跳出<span class="keyword">for</span>...<span class="keyword">of</span>循环的例子。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line">上面的例子，会输出斐波纳契数列小于等于 <span class="number">1000</span> 的项。如果当前项大于 <span class="number">1000</span>，就会使用<span class="keyword">break</span>语句跳出<span class="keyword">for</span>...<span class="keyword">of</span>循环。</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;</span><br><span class="line"></span><br><span class="line">(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)</span><br><span class="line">// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span><br><span class="line">() =&gt; &#123;函数声明&#125;</span><br><span class="line"></span><br><span class="line">使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。</span><br><span class="line"></span><br><span class="line">箭头函数是不能提升的，所以需要在使用之前定义。</span><br><span class="line"></span><br><span class="line">箭头函数 this 是静态的，始终指向声明时所在作用域下 this 的值</span><br><span class="line">箭头函数不能作为构造函数实例化</span><br><span class="line">不能使用 arguments</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于JavaScript来讲，对函数参数个数以及类型没有明确规定，如果指定参数没有赋值，那么默认为undefined,</span><br><span class="line"></span><br><span class="line">对于ES6而言，给定了默认值，function myFunction(x, y = 10) &#123;&#125;   这个函数如果y没有明确给值，那么y默认为10</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arguments 对象</span><br><span class="line">	对于函数传递的参数，都存在arguments 对象里面，可以通过对对象的调用实现对函数参数的使用</span><br></pre></td></tr></table></figure>

<h2 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在函数中调用的参数是函数的隐式参数。</span><br><span class="line"></span><br><span class="line">JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。</span><br><span class="line"></span><br><span class="line">如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。</span><br><span class="line"></span><br><span class="line">隐式参数的改变在函数外是不可见的。</span><br></pre></td></tr></table></figure>

<h2 id="通过对象传递参数"><a href="#通过对象传递参数" class="headerlink" title="通过对象传递参数"></a>通过对象传递参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在JavaScript中，可以引用对象的值。</span><br><span class="line"></span><br><span class="line">因此我们在函数内部修改对象的属性就会修改其初始的值。</span><br><span class="line"></span><br><span class="line">修改对象属性可作用于函数外部（全局变量）。</span><br><span class="line"></span><br><span class="line">修改对象属性在函数外是可见的。</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 JavaScript 中，所有函数都能访问它们上一层的作用域。</span><br><span class="line"></span><br><span class="line">JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。</span><br><span class="line"></span><br><span class="line">为了保存局部变量，从而使用了嵌套函数</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">            let count = 1;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                count++;</span><br><span class="line">                console.log(count)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">const r = fn();</span><br><span class="line">如上面的代码，r保存了fn（）里面的常量count并且每次调用++， 因为r是一个变量，存放在内存中，但是r依托于fn 那么就可以找到fn ，fn又要靠返回函数来进行使用，那么就可以找到返回函数，这样相当于保存了返回函数，count赋值操作只运行了一次。</span><br><span class="line"></span><br><span class="line">对于上面变量const r保存 一般使用不可变量const保存， let也可以 不建议</span><br></pre></td></tr></table></figure>

<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于对闭包的应用，</span><br><span class="line"></span><br><span class="line">    let add = x=&gt;y=&gt;x+y;</span><br><span class="line">    let add2 = add(2);</span><br><span class="line">    </span><br><span class="line">    本来函数的操作为</span><br><span class="line">    let add = (x,y) =&gt; x+y;</span><br><span class="line">    add(2,3)</span><br><span class="line">    现在add2函数只需要一个参数就可以完成这个操作，</span><br><span class="line">    </span><br><span class="line">如果是a =&gt; b =&gt; c =&gt; &#123;xxx&#125;这种多次柯里化的,如何理解?</span><br><span class="line">理解:前n - 1次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值</span><br></pre></td></tr></table></figure>



<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">原型prototype</span><br><span class="line">每个函数都有一个prototype属性，它默认指向一个object空对象(即称为原型对象)。原型对象中有一个属性constructor，它指向函数对象</span><br><span class="line"></span><br><span class="line">即一个函数来讲，有默认属性prototype，他指向一个空对象object  这个空对象有个属性constructor 它又反过来指向函数</span><br><span class="line"></span><br><span class="line">对于函数来讲，函数其实也是一个对象，所以对属性prototype赋新的属性和函数，这个对象都可以调用</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Fun</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;demo1111&quot;</span>) &#125;</span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Fun</span>().<span class="title function_">test</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Fun</span>().<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

<h2 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于每一个函数function来说，都有一个prototype属性，叫做显式原型 </span><br><span class="line">对于每一个实例化对象来讲，都有一个__proto__属性，称为隐式原型</span><br><span class="line">对象的隐式原型实际上为对应构造函数显式原型的值</span><br><span class="line"> var fn = new Fun()</span><br><span class="line">  console.log(fn.__proto__ == Fun.prototype) =&gt;  true</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从上面的探寻中已经知道，每个对象都有一个__proto__属性，而且这个属性是可以进行叠加的，所以对于一个对象属性寻找来说，如果在自身属性中没有找到，那么就沿着这条链子继续往深的找，</span><br><span class="line"></span><br><span class="line">我的理解来说，有点像java的继承，首先在子类中寻找，如果没有去父类中找，一直找到object里面</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于所有的函数都是Function函数的实例，包括自己本身，</span><br><span class="line">__proto__函数这个属性是一个空的object实例对象</span><br><span class="line">Object的原型对象是原型链的尽头Object.__proto__ 是 null</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取对象属性的时候，会到原型链中进行查找，但是设置对象属性的时候，如果对象没有这个属性，那么直接加上就好了，</span><br><span class="line">方法一般定义在原型中，属性一般通过构造函数定义在对象本身</span><br></pre></td></tr></table></figure>

<h2 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="attr">n</span>: <span class="number">2</span>, <span class="attr">m</span>: <span class="number">3</span>&#125;	<span class="comment">// 这里是改了A.prototype的引用</span></span><br><span class="line">上面相当于对A的原型进行了重新定义，并不是添加，如果添加是可以实时响应的</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>, b.<span class="property">m</span>, c.<span class="property">n</span>, c.<span class="property">m</span>) <span class="comment">// 1 undefined 2 3</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、构造函数 通过 Star.prototype 指向 原型对象；</span><br><span class="line"></span><br><span class="line">2、原型对象 通过 Star.prototype.constructor 指向 构造函数；</span><br><span class="line"></span><br><span class="line">3、ldh对象实例 通过 ldh._ _proto_ _指向 原型对象；</span><br><span class="line">再通过 原型对象的constructor，要写成ldh._ _proto_ _constructor，指回 构造函数；</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230426193441114-1ff48d.png" alt="image-20230426193441114"></p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230426200205855-938e30.png" alt="image-20230426200205855"></p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域在函数定义时就已经确定了，而不是在函数调用时</span><br><span class="line">var x = 10;</span><br><span class="line">function fn() &#123; console.log(x); &#125;</span><br><span class="line">function show(f) &#123;</span><br><span class="line">  var x = 20;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn); // 输出10</span><br><span class="line">因为作用域在定义的时候就确定了，所以输出10</span><br></pre></td></tr></table></figure>



<h1 id="javascript异步调用"><a href="#javascript异步调用" class="headerlink" title="javascript异步调用"></a>javascript异步调用</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于回调函数而言，把函数当作一个参数传到另外一个函数中，当需要用这个函数是，再回调运行()这个函数</span><br><span class="line"></span><br><span class="line">回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。（作为参数传递到另外一个函数中，这个作为参数的函数就是回调函数）</span><br><span class="line"></span><br><span class="line">理解：函数可以作为一个参数传递到另外一个函数中</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于回调函数的特点来讲，</span><br><span class="line"><span class="number">1.</span>不会立即执行</span><br><span class="line"></span><br><span class="line">回调函数作为参数传递给一个函数的时候，传递的只是函数的定义并不会立即执行。和普通的函数一样，回调函数在调用函数数中也要通过()运算符调用才会执行。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>回调函数是一个闭包</span><br><span class="line"></span><br><span class="line">回调函数是一个闭包，也就是说它能访问到其外层定义的变量。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>执行前类型判断</span><br><span class="line"></span><br><span class="line">在执行回调函数前最好确认其是一个函数。</span><br></pre></td></tr></table></figure>

<h3 id="回调函数this问题"><a href="#回调函数this问题" class="headerlink" title="回调函数this问题"></a>回调函数this问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于回调函数<span class="variable language_">this</span>，回调函数调用时<span class="variable language_">this</span>的执行上下文并不是回调函数定义时的那个上下文，而是调用它的函数所在的上下文，即定义这个函数所在的上下文，如果函数在外面单独定义，那么<span class="variable language_">this</span>很可能就是<span class="title class_">Window</span>,<span class="variable language_">this</span>指向是离它最近的或者嵌套级别的 <span class="keyword">function</span>/方法的调用者，</span><br><span class="line"></span><br><span class="line">解决方法<span class="number">1</span>：使用箭头函数在里面进行定义</span><br><span class="line">回调函数（若回调函数是普通函数时）当参数传入另外的函数时，若不知道这个函数内部怎么调用回调函数，就会出现回调函数中的<span class="variable language_">this</span>指向不明确的问题。所以 把箭头函数当回调函数，然后作为参数传入另外的函数中就不会出现<span class="variable language_">this</span>指向不明的问题。</span><br><span class="line"><span class="attr">eg</span>: <span class="keyword">function</span> <span class="title function_">createData</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> obj =&#123;</span><br><span class="line">            <span class="attr">data</span>:<span class="number">100</span>,</span><br><span class="line">            <span class="attr">tool</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">createData</span>(<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">data</span> = n;</span><br><span class="line">                &#125;)   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj.<span class="title function_">tool</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">data</span>);</span><br><span class="line">解决方法二：可以使用call和apply来进行重新定向</span><br><span class="line">解决方法三：在运用正确的<span class="variable language_">this</span>前，可以将正确的<span class="variable language_">this</span>声明成为一个变量从而进行使用</span><br></pre></td></tr></table></figure>

<h3 id="回调函数传参问题"><a href="#回调函数传参问题" class="headerlink" title="回调函数传参问题"></a>回调函数传参问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">将回调函数的参数作为与回调函数同等级的参数进行传递</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2Vi5YmN56uv5a6a5YGa,size_20,color_FFFFFF,t_70,g_se,x_16-cf06ae.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">回调函数的参数在调用回调函数内部创建</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2Vi5YmN56uv5a6a5YGa,size_20,color_FFFFFF,t_70,g_se,x_16-16822285726932-7bdd95.png" alt="在这里插入图片描述"></p>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">宏任务：<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>、<span class="title class_">Ajax</span>、I/O、<span class="variable constant_">UI</span>交互事件(比如<span class="variable constant_">DOM</span>事件)</span><br><span class="line"></span><br><span class="line">微任务：<span class="title class_">Promise</span>回调、<span class="keyword">async</span>/<span class="keyword">await</span>、process.<span class="title function_">nextTick</span>(<span class="title class_">Node</span>独有，注册函数的优先级比<span class="title class_">Promise</span>回调函数要高)、<span class="title class_">MutaionObserver</span></span><br><span class="line"></span><br><span class="line">微任务执行时机比宏任务要早（记住）</span><br><span class="line"></span><br><span class="line">注意：script全部代码、(这个是执行栈的代码，属于同步代码)，包括<span class="keyword">new</span> <span class="title class_">Promise</span>（<span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;）里面的代码，只有then、<span class="keyword">catch</span>回调才是微任务</span><br></pre></td></tr></table></figure>

<h2 id="promise规则"><a href="#promise规则" class="headerlink" title="promise规则"></a>promise规则</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）</span><br><span class="line"></span><br><span class="line">一旦状态改变，就不会再变，任何时候都可以得到这个结果</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">其中resolve函数是将pending状态变为resolve即未完成到成功，异步操作成功时调用，并且将异步操作结果作为参数传递进去；reject函数是将<span class="title class_">Promise</span>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line"></span><br><span class="line">可以用.<span class="property">then</span>方法分别定义两个函数，都可选，不一定必须</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">    resolve函数</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">    reject函数</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="then方法"><a href="#then方法" class="headerlink" title=".then方法"></a>.then方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于then方法，上面讲过里面可以传递两种参数，但是一般只传一种参数，resolve参数</span><br><span class="line"></span><br><span class="line">then方法返回的是一个新的<span class="title class_">Promise</span>实例（注意，不是原来那个<span class="title class_">Promise</span>实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</span><br></pre></td></tr></table></figure>

<h3 id="catch方法"><a href="#catch方法" class="headerlink" title=".catch方法"></a>.catch方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">catch</span>()方法是.<span class="title function_">then</span>(<span class="literal">null</span>, rejection)或.<span class="title function_">then</span>(<span class="literal">undefined</span>, rejection)的别名，用于指定发生错误时的回调函数。</span><br><span class="line"></span><br><span class="line">对于下面的例子来讲，getJSON返回一个promise对象，如果运行完成状态为resolve那么运行.<span class="property">then</span>里面的回调函数，如果发生错误，那么会使用.<span class="property">catch</span>里面的函数，如果.<span class="property">then</span>里面发生错误，也可以被<span class="keyword">catch</span>捕捉</span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一般不会在.<span class="property">then</span>里面定义reject函数，都用<span class="keyword">catch</span>捕捉</span><br></pre></td></tr></table></figure>

<h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">看名字就可以发现，他是一个最终执行的函数，不管promise最后的状态，在执行完then或<span class="keyword">catch</span>指定的回调函数以后，都会执行<span class="keyword">finally</span>方法指定的回调函数。</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>函数不接受任何参数</span><br></pre></td></tr></table></figure>

<h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>()方法用于将多个 <span class="title class_">Promise</span> 实例，包装成一个新的 <span class="title class_">Promise</span> 实例。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">接受一个数组作为参数，p1、p2、p3都是 <span class="title class_">Promise</span> 实例，如果不是，就会先调用下面讲到的<span class="title class_">Promise</span>.<span class="property">resolve</span>方法，将参数转为 <span class="title class_">Promise</span> 实例，再进一步处理。另外，<span class="title class_">Promise</span>.<span class="title function_">all</span>()方法的参数可以不是数组，但必须具有 <span class="title class_">Iterator</span> 接口，且返回的每个成员都是 <span class="title class_">Promise</span> 实例。</span><br><span class="line"></span><br><span class="line">p的状态由p1、p2、p3决定，分成两种情况。</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果作为参数的promise对象报错而且他自己有<span class="keyword">catch</span>方法，那么不会调用all.<span class="property">catch</span>的方法</span><br><span class="line">如果没有自己的<span class="keyword">catch</span>方法，那么就会调用<span class="title class_">Promise</span>.<span class="title function_">all</span>()的<span class="keyword">catch</span>方法。</span><br></pre></td></tr></table></figure>

<h3 id="race函数"><a href="#race函数" class="headerlink" title="race函数"></a>race函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 <span class="title class_">Promise</span> 实例的返回值，就传递给p的回调函数。</span><br></pre></td></tr></table></figure>

<h3 id="allsettled"><a href="#allsettled" class="headerlink" title="allsettled"></a>allsettled</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>()方法接受一个数组作为参数，数组的每个成员都是一个 <span class="title class_">Promise</span> 对象，并返回一个新的 <span class="title class_">Promise</span> 对象。只有等到参数数组的所有 <span class="title class_">Promise</span> 对象都发生状态变更（不管是fulfilled还是rejected），返回的 <span class="title class_">Promise</span> 对象才会发生状态变更。</span><br><span class="line"></span><br><span class="line">该方法返回的新的 <span class="title class_">Promise</span> 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 <span class="title class_">Promise</span> 对象。</span><br><span class="line"></span><br><span class="line">返回的数组值固定下面这种格式</span><br><span class="line"><span class="comment">// 异步操作成功时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作失败时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason&#125;</span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/blog&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;blog&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/docs&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;  <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用</span><br></pre></td></tr></table></figure>

<h4 id="参数形式"><a href="#参数形式" class="headerlink" title="参数形式"></a>参数形式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）参数是一个 <span class="title class_">Promise</span> 实例</span><br><span class="line">如果参数是 <span class="title class_">Promise</span> 实例，那么<span class="title class_">Promise</span>.<span class="property">resolve</span>将不做任何修改、原封不动地返回这个实例。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）参数是一个thenable对象</span><br><span class="line">thenable对象指的是具有then方法的对象，比如下面这个对象。</span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()方法会将这个对象转为 <span class="title class_">Promise</span> 对象，然后就立即执行thenable对象的<span class="title function_">then</span>()方法。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）参数不是具有<span class="title function_">then</span>()方法的对象，或根本就不是对象</span><br><span class="line">如果参数是一个原始值，或者是一个不具有<span class="title function_">then</span>()方法的对象，则<span class="title class_">Promise</span>.<span class="title function_">resolve</span>()方法返回一个新的 <span class="title class_">Promise</span> 对象，状态为resolved</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）不带有任何参数</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()方法允许调用时不带参数，直接返回一个resolved状态的 <span class="title class_">Promise</span> 对象。</span><br></pre></td></tr></table></figure>

<h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(reason)方法也会返回一个新的 <span class="title class_">Promise</span> 实例，该实例的状态为rejected。</span><br></pre></td></tr></table></figure>



<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于promise里面的函数来说，是同步栈函数，直接会运行，只有resolve和reject两个函数是异步函数</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于promise函数来说，如果里面发生错误，但是没有使用<span class="keyword">catch</span>方法指定错误的回调函数，那么这个错误不会传递到外层，即外层代码会继续执行，只不过promise会发生错误</span><br></pre></td></tr></table></figure>

<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">Generator</span>函数，首先可以把他理解成<span class="title class_">Generator</span>函数是一个状态机，封装了多个内部状态，执行<span class="title class_">Generator</span>函数，会返回一个可遍历对象，可以依次遍历<span class="title class_">Generator</span>里面的每一个状态</span><br><span class="line"><span class="title class_">Generator</span>函数有两个特征：</span><br><span class="line">一是，<span class="keyword">function</span>关键字与函数名之间有一个星号；</span><br><span class="line">二是，函数体内部使用<span class="keyword">yield</span>表达式，定义不同的内部状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用 <span class="title class_">Generator</span> 函数，返回一个遍历器对象，代表 <span class="title class_">Generator</span> 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是<span class="keyword">yield</span>表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</span><br></pre></td></tr></table></figure>

<h3 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>表达式相当于<span class="title class_">Generator</span>里面的暂停标志</span><br><span class="line">遍历器对象的next方法的运行逻辑如下。</span><br><span class="line">（<span class="number">1</span>）遇到<span class="keyword">yield</span>表达式，就暂停执行后面的操作，并将紧跟在<span class="keyword">yield</span>后面的那个表达式的值，作为返回的对象的value属性值。</span><br><span class="line">（<span class="number">2</span>）下一次调用next方法时，再继续往下执行，直到遇到下一个<span class="keyword">yield</span>表达式。</span><br><span class="line">（<span class="number">3</span>）如果没有再遇到新的<span class="keyword">yield</span>表达式，就一直运行到函数结束，直到<span class="keyword">return</span>语句为止，并将<span class="keyword">return</span>语句后面的表达式的值，作为返回的对象的value属性值。</span><br><span class="line">（<span class="number">4</span>）如果该函数没有<span class="keyword">return</span>语句，则返回的对象的value属性值为<span class="literal">undefined</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>表达式如果用在另一个表达式之中，必须放在圆括号里面。</span><br><span class="line"><span class="attr">eg</span>:<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">               </span><br></pre></td></tr></table></figure>

<h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>表达式本身没有返回值，或者说总是返回<span class="literal">undefined</span>。next方法可以带一个参数，该参数就会被当作上一个<span class="keyword">yield</span>表达式的返回值。</span><br></pre></td></tr></table></figure>

<h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">注意，由于next方法的参数表示上一个<span class="keyword">yield</span>表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</span><br></pre></td></tr></table></figure>

<h3 id="next和yield参数区别"><a href="#next和yield参数区别" class="headerlink" title="next和yield参数区别"></a>next和yield参数区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="keyword">yield</span>后面语句执行之后，会返回给next语句，next语句进行接收那么就可以接收到所运行的值</span><br><span class="line"></span><br><span class="line">对于next参数，会返回给<span class="keyword">yield</span>左侧的值，<span class="attr">eg</span>: <span class="keyword">let</span> x = <span class="keyword">yield</span> m;<span class="keyword">let</span> temp =  <span class="title function_">next</span>(<span class="number">3</span>);</span><br><span class="line">对于这两个，x的值会是<span class="number">3</span>,temp的值为&#123; <span class="attr">value</span>: m, <span class="attr">done</span>: <span class="literal">false</span> &#125; 第一个参数是值，第二个参数是显示他是否运行结束</span><br></pre></td></tr></table></figure>

<h3 id="用for-of遍历"><a href="#用for-of遍历" class="headerlink" title="用for of遍历"></a>用for of遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>...<span class="keyword">of</span>循环可以自动遍历 <span class="title class_">Generator</span> 函数运行时生成的<span class="title class_">Iterator</span>对象，且此时不再需要调用next方法。</span><br><span class="line">一旦next方法的返回对象的done属性为<span class="literal">true</span>，<span class="keyword">for</span>...<span class="keyword">of</span>循环就会中止，且不包含该返回对象</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">所以上面的函数不会返回<span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="throw函数"><a href="#throw函数" class="headerlink" title="throw函数"></a>throw函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Generator</span>函数返回的遍历器对象，都有一个<span class="keyword">throw</span>方法，可以在函数体外抛出错误，然后在<span class="title class_">Generator</span>函数体内捕获。</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br><span class="line">对于上面的例子，第一个<span class="keyword">throw</span>后在内部被捕捉，但是第二个会被外部捕捉</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span>方法被捕获以后，会附带执行下一条<span class="keyword">yield</span>表达式。也就是说，会附带执行一次next方法。</span><br><span class="line"></span><br><span class="line">Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<span class="keyword">catch</span>捕获。</span><br><span class="line"></span><br><span class="line">一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于<span class="literal">true</span>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</span><br></pre></td></tr></table></figure>

<h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于混淆遍历器对象的<span class="keyword">throw</span>方法和全局的<span class="keyword">throw</span>命令。</span><br><span class="line">遍历器对象的<span class="keyword">throw</span>方法，可以由函数内部捕捉</span><br><span class="line">全局的<span class="keyword">throw</span>命令只能被函数体外的<span class="keyword">catch</span>语句捕获。</span><br></pre></td></tr></table></figure>

<h3 id="return函数"><a href="#return函数" class="headerlink" title="return函数"></a>return函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Generator</span> 函数返回的遍历器对象，还有一个<span class="keyword">return</span>()方法，可以返回给定的值，并且终结遍历 <span class="title class_">Generator</span> 函数。</span><br><span class="line"></span><br><span class="line">如果 <span class="title class_">Generator</span> 函数内部有<span class="keyword">try</span>...<span class="keyword">finally</span>代码块，且正在执行<span class="keyword">try</span>代码块，那么<span class="keyword">return</span>()方法会导致立刻进入<span class="keyword">finally</span>代码块，执行完以后，整个函数才会结束。</span><br></pre></td></tr></table></figure>



<h3 id="next-throw-return"><a href="#next-throw-return" class="headerlink" title="next() throw() return()"></a>next() throw() return()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">next</span>()是将<span class="keyword">yield</span>表达式替换成一个值。</span><br><span class="line"><span class="keyword">throw</span>()是将<span class="keyword">yield</span>表达式替换成一个<span class="keyword">throw</span>语句。</span><br><span class="line"><span class="keyword">return</span>()是将<span class="keyword">yield</span>表达式替换成一个<span class="keyword">return</span>语句。</span><br></pre></td></tr></table></figure>

<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a>yield*表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">用来在一个 <span class="title class_">Generator</span> 函数里面执行另一个 <span class="title class_">Generator</span> 函数。</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一句话，它就是 <span class="title class_">Generator</span> 函数的语法糖。</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>函数返回的是 <span class="title class_">Promise</span> 对象</span><br><span class="line"><span class="keyword">await</span>相当于yeild 当遇到<span class="keyword">await</span>后，会把后面的运行完成后自动暂停开一个异步线程进行运行</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>函数返回的 <span class="title class_">Promise</span> 对象，必须等到内部所有<span class="keyword">await</span>命令后面的 <span class="title class_">Promise</span> 对象执行完，才会发生状态改变，除非遇到<span class="keyword">return</span>语句或者抛出错误。也就是说，只有<span class="keyword">async</span>函数内部的异步操作执行完，才会执行then方法指定的回调函数。</span><br><span class="line">必须执行完成，如果没有返回一个可以用的值，那么函数到这里就停止</span><br></pre></td></tr></table></figure>

<h1 id="DOM语法"><a href="#DOM语法" class="headerlink" title="DOM语法"></a>DOM语法</h1><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502145707321-c9495d.png" alt="image-20230502145707321"></p>
<h2 id="查找html元素"><a href="#查找html元素" class="headerlink" title="查找html元素"></a>查找html元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">通过 id 找到 <span class="variable constant_">HTML</span> 元素 <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">通过标签名找到 <span class="variable constant_">HTML</span> 元素 .<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;TagName&quot;</span>);</span><br><span class="line">通过类名找到 <span class="variable constant_">HTML</span> 元素 <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;calssName&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="改变HTML"><a href="#改变HTML" class="headerlink" title="改变HTML"></a>改变HTML</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">改变<span class="variable constant_">HTML</span>的输入流：<span class="variable language_">document</span>.<span class="title function_">write</span>();  向html里面输入数据，注意不可以在文档加载完成后输入，这样会覆盖内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改变<span class="variable constant_">HTML</span>文档内容：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">innerHTML</span>=新的 <span class="variable constant_">HTML</span> 会识别html标签和里面的空格换行会去掉</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">innerText</span>=text  不识别html标签，里面空格和换行也不会去掉</span><br><span class="line"></span><br><span class="line">改变<span class="variable constant_">HTML</span>属性：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">attribute</span>=新属性值</span><br><span class="line">attribute此处为属性，不是样式<span class="attr">eg</span>:如果要将一个P标签的字体颜色改成红色应该这样写：</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>).<span class="property">style</span> = <span class="string">&quot;color:red&quot;</span>;</span><br><span class="line">或者<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>).<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;#bfa&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="改变CSS"><a href="#改变CSS" class="headerlink" title="改变CSS"></a>改变CSS</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">改变样式：<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id).<span class="property">style</span>.<span class="property">property</span>=新样式</span><br><span class="line">产生的是行内样式，权重占比高</span><br><span class="line"><span class="attr">eg</span>:<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>).<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="DOM事件响应"><a href="#DOM事件响应" class="headerlink" title="DOM事件响应"></a>DOM事件响应</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">当用户点击鼠标时</span><br><span class="line">当网页已加载时</span><br><span class="line">当图像已加载时</span><br><span class="line">当鼠标移动到元素上时</span><br><span class="line">当输入字段被改变时</span><br><span class="line">当提交 <span class="variable constant_">HTML</span> 表单时</span><br><span class="line">当用户触发按键时</span><br><span class="line"></span><br><span class="line">onclick=<span class="title class_">JavaScript</span></span><br><span class="line">用dom来分配事件</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>).<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">displayDate</span>()&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onload 和 onunload 事件会在用户进入或离开页面时被触发。</span><br><span class="line">onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</span><br><span class="line">onload 和 onunload 事件可用于处理 cookie。</span><br><span class="line"></span><br><span class="line">onchange 事件常结合对输入字段的验证来使用。</span><br><span class="line">onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 <span class="variable constant_">HTML</span> 元素上方或移出元素时触发函数。</span><br><span class="line"></span><br><span class="line">onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</span><br><span class="line"></span><br><span class="line">onfocus  获得焦点时候进行事件</span><br></pre></td></tr></table></figure>

<h2 id="DOM事件对象的属性"><a href="#DOM事件对象的属性" class="headerlink" title="DOM事件对象的属性"></a>DOM事件对象的属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于每个操作，都是对对象的操作，事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。比如  </span><br><span class="line">谁绑定了这个事件</span><br><span class="line">鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置</span><br><span class="line">键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</span><br><span class="line"></span><br><span class="line">这个 event  是个形参，系统帮我们设定为事件对象，不需要传递实参过去。</span><br><span class="line">当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。</span><br><span class="line"></span><br><span class="line">相当于每一个操作其实函数都有一个默认参数event参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502162221693-bb3caa.png" alt="image-20230502162221693"></p>
<h2 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 MouseEvent和键盘事件对象 KeyboardEvent。</span><br></pre></td></tr></table></figure>

<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502162311744-e3960e.png" alt="image-20230502162311744"></p>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502162433971-a26d12.png" alt="image-20230502162433971"></p>
<h2 id="DOM-EventListener"><a href="#DOM-EventListener" class="headerlink" title="DOM EventListener()"></a>DOM EventListener()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>() 方法用于向指定元素添加事件句柄。</span><br><span class="line"><span class="title function_">addEventListener</span>() 方法添加的事件句柄不会覆盖已存在的事件句柄。</span><br><span class="line">你可以向一个元素添加多个事件句柄。</span><br><span class="line">你可以向同个元素添加多个同类型的事件句柄，如：两个 <span class="string">&quot;click&quot;</span> 事件，不会覆盖以前的事件</span><br><span class="line">你可以向任何 <span class="variable constant_">DOM</span> 对象添加事件监听，不仅仅是 <span class="variable constant_">HTML</span> 元素。如： <span class="variable language_">window</span> 对象。</span><br><span class="line"><span class="title function_">addEventListener</span>() 方法可以更简单的控制事件（冒泡与捕获）。</span><br><span class="line">对于参数传递的时候，可以使用匿名函数调用参数</span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="title function_">myFunction</span>(p1, p2); &#125;);</span><br><span class="line"></span><br><span class="line">element.<span class="title function_">addEventListener</span>(event, <span class="keyword">function</span>, useCapture);</span><br><span class="line">第一个参数是事件的类型 (如 <span class="string">&quot;click&quot;</span> 或 <span class="string">&quot;mousedown&quot;</span>).注意不带on前缀</span><br><span class="line">第二个参数是事件触发后调用的函数。</span><br><span class="line">第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</span><br><span class="line"></span><br><span class="line">对于第三个参数来讲，事件传递有两种方式：冒泡与捕获。</span><br><span class="line">事件传递定义了元素事件触发的顺序。 如果你将 &lt;p&gt; 元素插入到 &lt;div&gt; 元素中，用户点击 &lt;p&gt; 元素, 哪个元素的 <span class="string">&quot;click&quot;</span> 事件先被触发呢？</span><br><span class="line">在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： &lt;p&gt; 元素的点击事件先触发，然后会触发 &lt;div&gt; 元素的点击事件。</span><br><span class="line">在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： &lt;div&gt; 元素的点击事件先触发 ，然后再触发 &lt;p&gt; 元素的点击事件。</span><br><span class="line"></span><br><span class="line">默认值为 <span class="literal">false</span>, 即冒泡传递，当值为 <span class="literal">true</span> 时, 事件使用捕获传递。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">removeEventListener</span>() 方法用来移除add方法添加的事件</span><br></pre></td></tr></table></figure>

<h2 id="事件委派原理"><a href="#事件委派原理" class="headerlink" title="事件委派原理"></a>事件委派原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不在每个子节点单独设置事件监听器，设置在其父节点上，然后利用冒泡原理影响设置每个子节点</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手4&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否，点我应有弹框在手5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点</span><br><span class="line">  var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">  ul.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">    // alert(&#x27;知否知否，点我应有弹框在手！&#x27;);</span><br><span class="line">    // e.target 这个可以得到我们点击的对象</span><br><span class="line">    e.target.style.backgroundColor = &#x27;pink&#x27;;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">如上面的例子，要点击每一个li让他有一些操作，通常的做法是对每一个li设置方法，显然很麻烦，我们可以通过对ul设置方法，然后作用到li上</span><br></pre></td></tr></table></figure>

<h2 id="阻止默认事件执行"><a href="#阻止默认事件执行" class="headerlink" title="阻止默认事件执行"></a>阻止默认事件执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一个链接，你点击之后不希望跳转怎么实现呢？</span><br><span class="line">可以阻止默认事件发生</span><br><span class="line">  e.preventDefault();这个方法就可以阻止默认事件发生，具体看下面例子</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">禁止鼠标右键菜单</span><br><span class="line">contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</span><br><span class="line">document.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">禁止鼠标选中（selectstart开始选中）</span><br><span class="line">document.addEventListener(&#x27;selectstart&#x27;, function(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="DOM元素（节点）操作"><a href="#DOM元素（节点）操作" class="headerlink" title="DOM元素（节点）操作"></a>DOM元素（节点）操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般地，节点至少拥有nodeType节点类型、nodeName节点名称和nodeValue节点值三个基本属性</span><br><span class="line">元素节点 nodeType 为 1</span><br><span class="line">属性节点 nodeType 为 2</span><br><span class="line">文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">appendChild</span>()在一个元素后排追加一个元素</span><br><span class="line"><span class="keyword">var</span> para = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);创建一个元素</span><br><span class="line"><span class="keyword">var</span> node =<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;创建节点文本&quot;</span>);</span><br><span class="line">para.<span class="title function_">appendChild</span>(node);文本节点加入para里面</span><br><span class="line">可以用setAttribute对para进行其他操作eg：  para.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>,<span class="string">&#x27;color:red&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertBefore</span>()加在方法的前面</span><br><span class="line">移除一个元素，需要知道他的父元素parent.<span class="title function_">removeChild</span>(child);</span><br><span class="line">不用刻意寻找父元素，可以这样操作child.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(child);</span><br><span class="line"></span><br><span class="line"><span class="title function_">replaceChild</span>(newChild,oldChild)       替换指定结点的子结点</span><br></pre></td></tr></table></figure>

<h2 id="DOM集合"><a href="#DOM集合" class="headerlink" title="DOM集合"></a>DOM集合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HTMLCollection</span> 对象类似包含 <span class="variable constant_">HTML</span> 元素的一个数组。</span><br><span class="line">集合中的元素可以通过索引(以 <span class="number">0</span> 为起始位置)来访问。</span><br><span class="line"> length 属性定义了集合中元素的数量。</span><br><span class="line"> <span class="title function_">item</span>() -&gt;获取第几个  也可以[]获取</span><br><span class="line"> <span class="title function_">namedItem</span>() -&gt;根据id获取，如果id不存在再在名字里面寻找</span><br><span class="line"> 注意他只是一个类似数组的方法，但本质上不是数组，不可以使用数组其他函数</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">HTMLCollection</span> 是一个动态的属性，对dom树进行增添会即时改变集合里面的元素</span><br></pre></td></tr></table></figure>

<h2 id="HTMLCollection-与-NodeList-的区别"><a href="#HTMLCollection-与-NodeList-的区别" class="headerlink" title="HTMLCollection 与 NodeList 的区别"></a>HTMLCollection 与 NodeList 的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HTMLCollection</span> 是 <span class="variable constant_">HTML</span> 元素的集合。</span><br><span class="line"><span class="title class_">NodeList</span> 是一个文档节点的集合。</span><br><span class="line"><span class="title class_">NodeList</span> 与 <span class="title class_">HTMLCollection</span> 有很多类似的地方。</span><br><span class="line"><span class="title class_">NodeList</span> 与 <span class="title class_">HTMLCollection</span> 都与数组对象有点类似，可以使用索引 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, ...) 来获取元素。</span><br><span class="line"><span class="title class_">NodeList</span> 与 <span class="title class_">HTMLCollection</span> 都有 length 属性。</span><br><span class="line"><span class="title class_">HTMLCollection</span> 元素可以通过 name，id 或索引来获取。</span><br><span class="line"><span class="title class_">NodeList</span> 只能通过索引来获取。</span><br><span class="line">只有 <span class="title class_">NodeList</span> 对象有包含属性节点和文本节点。</span><br></pre></td></tr></table></figure>



<h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>方法：</span><br><span class="line"><span class="title function_">getElementById</span>(id) 返回指定结点的引用</span><br><span class="line"><span class="title function_">getElementsByTagName</span>(name)  返回文档中所有匹配的元素的集合</span><br><span class="line"><span class="title function_">createElement</span>(name) 创建指定类型的新结点</span><br><span class="line"><span class="title function_">createTextNode</span>(text) 创建一个纯文本结点</span><br><span class="line"></span><br><span class="line">element方法：</span><br><span class="line"><span class="title function_">getAttribute</span>(id) 返回指定属性的值</span><br><span class="line"><span class="title function_">setAttribute</span>(id,value)  给属性赋值，注意是属性不是style样式，</span><br><span class="line"><span class="title function_">removeAttribute</span>(id)  移除指定属性和它的值</span><br><span class="line"><span class="title function_">getElementsByTagName</span>(name)  返回结点内所有匹配的元素的集合</span><br><span class="line"></span><br><span class="line">node方法：</span><br><span class="line"><span class="title function_">appendChild</span>(child) 给指定结点添加一个新的子结点</span><br><span class="line"><span class="title function_">removeChild</span>(child) 移除指定结点的子结点</span><br><span class="line"><span class="title function_">replaceChild</span>(newChild,oldChild)  替换指定结点的子结点</span><br><span class="line"><span class="title function_">insertBefore</span>(newChild,refChild) 在同一层级的结点前面插入新结点</span><br><span class="line"><span class="title function_">hasChildNodes</span>()   如果结点有子结点则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">node属性：</span><br><span class="line">nodeName  以字符串的格式存放结点的名称</span><br><span class="line">nodeType   以整型数据格式存放结点的类型</span><br><span class="line">nodeValue   以可用的格式存放结点的值</span><br><span class="line">parentNode  指向结点的父结点的引用</span><br><span class="line">childNodes  指向子结点的引用的集合</span><br><span class="line">firstChild  指向子结点结合中的第一个子结点的引用</span><br><span class="line">lastChild  指向子结点结合中的最后一个子结点的引用</span><br><span class="line">node.<span class="property">nextSibling</span>返回下一个兄弟节点，找不到则返回<span class="literal">null</span>，包含所有的节点</span><br><span class="line">node.<span class="property">previousSibling</span>返回上一个兄弟节点，找不到则返回<span class="literal">null</span>，包含所有的节点</span><br><span class="line">node.<span class="property">nextElementSibling</span>返回下一个兄弟元素节点，找不到则返回<span class="literal">null</span>，有兼容问题</span><br><span class="line">node.<span class="property">previousElementSibling</span>返回上一个兄弟元素节点，找不到则返回<span class="literal">null</span>，有兼容问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node.<span class="title function_">cloneNode</span>() 返回调用该方法的节点的一个副本，也成为克隆节点</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于<span class="title class_">JavaScript</span>对象的创建，可以新建一个object对象，然后给他添加属性和方法</span><br><span class="line">person=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">firstname</span>=<span class="string">&quot;John&quot;</span>;</span><br><span class="line">person.<span class="property">lastname</span>=<span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> 构造函数，会根据给定的参数创建对象，具体有以下情况：</span><br><span class="line">如果给定值是 <span class="literal">null</span> 或 <span class="literal">undefined</span>，将会创建并返回一个空对象。</span><br><span class="line">如果传进去的是一个基本类型的值，则会构造其包装类型的对象。</span><br><span class="line">如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址。</span><br><span class="line">当以非构造函数形式被调用时，<span class="title class_">Object</span> 的行为等同于 <span class="keyword">new</span> <span class="title class_">Object</span>()。</span><br><span class="line"></span><br><span class="line">可以使用构造函数去进行自我创建 </span><br><span class="line"><span class="attr">eg</span>:<span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">firstname,lastname,age,eyecolor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstname</span>=firstname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastname</span>=lastname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eyecolor</span>=eyecolor;</span><br><span class="line">&#125;</span><br><span class="line">但对于上面的例子来讲，</span><br><span class="line"><span class="keyword">var</span> myFather=<span class="keyword">new</span> <span class="title function_">person</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Doe&quot;</span>,<span class="number">50</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myMother=<span class="title function_">person</span>(<span class="string">&quot;Sally&quot;</span>,<span class="string">&quot;Rally&quot;</span>,<span class="number">48</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line"> 如果 <span class="keyword">new</span> 了函数内的 <span class="variable language_">this</span> 会指向当前这个 person 并且就算函数内部不 <span class="keyword">return</span> 也会返回一个对象。</span><br><span class="line"> 如果不 <span class="keyword">new</span> 的话函数内的 <span class="variable language_">this</span> 指向的是 <span class="variable language_">window</span>。第二个就指向<span class="title class_">Window</span> 如果调用<span class="title class_">Window</span>.<span class="property">firstname</span> 也会返回<span class="title class_">Sally</span></span><br></pre></td></tr></table></figure>

<h2 id="prototype-继承"><a href="#prototype-继承" class="headerlink" title="prototype 继承"></a>prototype 继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于以及构建好的类，在下面进行操作时，一般不可以对他的构造函数和方法进行更改，有的时候我们想要在所有已经存在的对象添加新的属性或方法。另外，有时候我们想要在对象的构造函数中添加属性或方法。</span><br><span class="line"></span><br><span class="line">如下面的例子：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last, age, eyecolor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = first;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastName</span> = last;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">eyeColor</span> = eyecolor;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">nationality</span> = <span class="string">&quot;English&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">所有的 <span class="title class_">JavaScript</span> 对象都会从一个 prototype（原型对象）中继承属性和方法</span><br><span class="line">所以对于一个对象进行访问的时候，不仅仅访问自己，还访问他原型对象，直到找到一个名字匹配的属性或到达原型链的末尾</span><br></pre></td></tr></table></figure>

<h2 id="最好的创建方法"><a href="#最好的创建方法" class="headerlink" title="最好的创建方法"></a>最好的创建方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">套路：自定义构造函数, 属性在函数中初始化，方法添加到原型上</span><br><span class="line">适用场景：需要创建多个类型确定的对象</span><br><span class="line">放在原型上可以节省空间（只需要加载一遍方法）,放在原型上方法由于是公用的，所以只需要加载一遍就好了，但是由于属性是独一无二的，所以需要在加载的时候创建</span><br><span class="line"></span><br><span class="line"><span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于组合继承来讲，利用原型链实现对父类型对象的方法继承，利用<span class="variable language_">super</span>()借用父类型构建函数初始化相同属性</span><br><span class="line"><span class="comment">//构造父类构造器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类构造器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, price</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)  <span class="comment">// 为了得到属性，用call改变this指向</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span> <span class="comment">// 修正constructor属性，使其指向子类</span></span><br><span class="line"><span class="comment">//定义子类特有方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setPrice</span> = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">24</span>, <span class="number">15000</span>)</span><br><span class="line">s.<span class="title function_">setName</span>(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.<span class="title function_">setPrice</span>(<span class="number">16000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">name</span>, s.<span class="property">age</span>, s.<span class="property">price</span>)</span><br></pre></td></tr></table></figure>



<h1 id="Window-浏览器对象模型"><a href="#Window-浏览器对象模型" class="headerlink" title="Window - 浏览器对象模型"></a>Window - 浏览器对象模型</h1><p><strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel (BOM)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于所有浏览器都支持 window 对象。它表示浏览器窗口。</span><br><span class="line">所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</span><br><span class="line">全局变量是 window 对象的属性。</span><br><span class="line">全局函数是 window 对象的方法。</span><br><span class="line">甚至 HTML DOM 的 document 也是 window 对象的属性之一</span><br><span class="line">window.open() - 打开新窗口</span><br><span class="line">window.close() - 关闭当前窗口</span><br><span class="line">window.moveTo() - 移动当前窗口</span><br><span class="line">window.resizeTo() - 调整当前窗口的尺寸</span><br></pre></td></tr></table></figure>



<h1 id="函数（API）"><a href="#函数（API）" class="headerlink" title="函数（API）"></a>函数（API）</h1><h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">这个函数可以用来简单判断一个变量是否为整数，如果需要具体进行判断的话，则需要用到正则表达式</span><br><span class="line">使用方法-&gt;            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(flag))</span><br><span class="line"><span class="literal">false</span>- 表示是数字</span><br><span class="line"><span class="literal">true</span> - 表示不是数字</span><br><span class="line"></span><br><span class="line">值得注意的是</span><br><span class="line">最大值<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>，比最大值大就是无穷大<span class="title class_">Infinty</span></span><br><span class="line">最小值<span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>，比最小值小就是无穷大-<span class="title class_">Infinty</span></span><br></pre></td></tr></table></figure>

<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">这个函数可以用来判断一个变量的类型  返回的是一个字符串</span><br><span class="line">不能判断: <span class="literal">null</span>与object object与array </span><br><span class="line">使用方法-&gt;             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> flag)</span><br></pre></td></tr></table></figure>

<h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">constructor 属性可以返回变量的构造函数</span><br><span class="line"><span class="attr">eg</span>:<span class="string">&quot;John&quot;</span>.<span class="property">constructor</span>                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).<span class="property">constructor</span>                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.<span class="property">constructor</span>                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="property">constructor</span>              <span class="comment">// 返回函数 Array()   &#123; [native code] &#125;</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;.<span class="property">constructor</span>  <span class="comment">// 返回函数 Object()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="property">constructor</span>             <span class="comment">// 返回函数 Date()    &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;.<span class="property">constructor</span>         <span class="comment">// 返回函数 Function()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将类似数组结构的元素转化为数组</span><br><span class="line">let arrayLike = &#123; length: 2, 0: &#x27;a&#x27;, 1: &#x27;b&#x27; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="setInterval-方法"><a href="#setInterval-方法" class="headerlink" title="setInterval() 方法"></a>setInterval() 方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">间隔指定的毫秒数不停地执行指定的代码</span><br><span class="line">window.setInterval(&quot;javascript function&quot;,milliseconds);</span><br><span class="line">setInterval() 第一个参数是函数（function）。</span><br><span class="line">第二个参数间隔的毫秒数</span><br><span class="line"></span><br><span class="line">clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。</span><br></pre></td></tr></table></figure>

<h2 id="setTimeout-方法"><a href="#setTimeout-方法" class="headerlink" title="setTimeout() 方法"></a>setTimeout() 方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.setTimeout(&quot;javascript function&quot;, milliseconds);</span><br><span class="line">setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 &quot;alert(&#x27;5 seconds!&#x27;)&quot;，或者对函数的调用，诸如 alertMsg。</span><br><span class="line">第二个参数指示从当前起多少毫秒后执行第一个参数</span><br><span class="line"></span><br><span class="line">clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。</span><br><span class="line">语法</span><br><span class="line">window.clearTimeout(timeoutVariable)</span><br></pre></td></tr></table></figure>

<h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它用于把Array的某些元素过滤掉，然后返回剩下的元素。</span><br><span class="line"></span><br><span class="line">和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</span><br><span class="line"></span><br><span class="line">Array.filter(function(currentValue, indedx, arr), thisValue)</span><br><span class="line">  其中，函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；</span><br><span class="line">  函数的第一个参数 currentValue 也为必须，代表当前元素的值。</span><br></pre></td></tr></table></figure>



<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="在线网站—好用"><a href="#在线网站—好用" class="headerlink" title="在线网站—好用"></a>在线网站—好用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hemin.cn/jq/</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载和安装官网地址 https://jquery.com/</span><br><span class="line">版本</span><br><span class="line">各个版本的下载 https://code.jquery.com/</span><br><span class="line">1x ：兼容 IE 678 等低版本浏览器， 官网不再更新</span><br><span class="line">2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新</span><br><span class="line">3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</span><br><span class="line"></span><br><span class="line">选择development版本的即可，保存本地即可</span><br></pre></td></tr></table></figure>

<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table>
<thead>
<tr>
<th>基本选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>#id</code></td>
<td>根据给定的ID匹配一个元素</td>
</tr>
<tr>
<td><code>element</code></td>
<td>根据给定的元素名匹配所有元素</td>
</tr>
<tr>
<td><code>.class</code></td>
<td>根据给定的类匹配元素</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配所有元素</td>
</tr>
<tr>
<td><code>selector1,selector2,selectorN</code></td>
<td>将每一个选择器匹配到的元素合并后一起返回层级选择器</td>
</tr>
</tbody></table>
<h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><table>
<thead>
<tr>
<th>层级选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ancestor descendant</code></td>
<td>在给定的祖先元素下匹配所有的后代元素</td>
</tr>
<tr>
<td><code>parent &gt; child</code></td>
<td>在给定的父元素下匹配所有的子元素</td>
</tr>
<tr>
<td><code>prev + next</code></td>
<td>匹配所有紧接在 prev 元素后的 next 元素</td>
</tr>
<tr>
<td><code>prev ~ siblings</code></td>
<td>匹配 prev 元素之后的所有 siblings 元素</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里需要强调一下父类选择器和祖先选择器，对于祖先选择器来讲，选择他里面的所有后代里面符合的元素，包括孙类元素，但是父类选择器只选择到儿子层面就停止，不会向下延伸</span><br><span class="line"></span><br><span class="line">`prev + next`只会选择下一个元素</span><br><span class="line">`prev ~ siblings` 会选择后续所有的元素</span><br></pre></td></tr></table></figure>

<h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><table>
<thead>
<tr>
<th>分类</th>
<th>过滤选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>基本</td>
<td><code>:first</code></td>
<td>获取第一个元素</td>
</tr>
<tr>
<td></td>
<td><code>:last</code></td>
<td>获取最后一个元素</td>
</tr>
<tr>
<td></td>
<td><code>:eq(index)</code></td>
<td>匹配一个给定索引值的元素</td>
</tr>
<tr>
<td></td>
<td><code>:gt(index)</code></td>
<td>匹配所有大于给定索引值的元素</td>
</tr>
<tr>
<td></td>
<td><code>:lt(index)</code></td>
<td>匹配所有小于给定索引值的元素</td>
</tr>
<tr>
<td></td>
<td><code>:even</code></td>
<td>匹配所有索引值为偶数的元素，从 0 开始计数</td>
</tr>
<tr>
<td></td>
<td><code>:odd</code></td>
<td>匹配所有索引值为奇数的元素，从 0 开始计数</td>
</tr>
<tr>
<td></td>
<td><code>:not(selector)</code></td>
<td>去除所有与给定选择器匹配的元素</td>
</tr>
<tr>
<td>内容</td>
<td><code>:contains(text)</code></td>
<td>匹配包含给定文本的元素</td>
</tr>
<tr>
<td></td>
<td><code>:has(selector)</code></td>
<td>匹配含有选择器所匹配的元素的元素</td>
</tr>
<tr>
<td></td>
<td><code>:empty</code></td>
<td>匹配所有不包含子元素或者文本的空元素</td>
</tr>
<tr>
<td></td>
<td><code>:parent</code></td>
<td>匹配含有子元素或者文本的元素</td>
</tr>
<tr>
<td>可见性</td>
<td><code>:hidden</code></td>
<td>匹配所有不可见元素，或者type为hidden的元素</td>
</tr>
<tr>
<td></td>
<td><code>:visible</code></td>
<td>匹配所有的可见元素</td>
</tr>
<tr>
<td>属性</td>
<td><code>[attribute]</code></td>
<td>匹配包含给定属性的元素</td>
</tr>
<tr>
<td></td>
<td><code>[attribute=value]</code></td>
<td>匹配给定的属性是某个特定值的元素</td>
</tr>
<tr>
<td></td>
<td><code>[attribute!=value]</code></td>
<td>匹配所有不含有指定的属性，或者属性不等于特定值的元素</td>
</tr>
<tr>
<td></td>
<td><code>[attribute*=value]</code></td>
<td>匹配给定的属性是以包含某些值的元素</td>
</tr>
<tr>
<td></td>
<td><code>[selector1][selector2][selectorN]</code></td>
<td>复合属性选择器，需要同时满足多个条件时使用</td>
</tr>
</tbody></table>
<h3 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h3><table>
<thead>
<tr>
<th>表单选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>:input</code></td>
<td>匹配所有 input, textarea, select 和 button 元素</td>
</tr>
<tr>
<td><code>:text</code></td>
<td>匹配所有的单行文本框</td>
</tr>
<tr>
<td><code>:password</code></td>
<td>匹配所有密码框</td>
</tr>
<tr>
<td><code>:radio</code></td>
<td>匹配所有单选按钮</td>
</tr>
<tr>
<td><code>:checkbox</code></td>
<td>匹配所有复选框</td>
</tr>
<tr>
<td><code>:submit</code></td>
<td>匹配所有提交按钮</td>
</tr>
<tr>
<td><code>:reset</code></td>
<td>匹配所有重置按钮</td>
</tr>
<tr>
<td><code>:button</code></td>
<td>匹配所有按钮</td>
</tr>
<tr>
<td><strong>表单对象属性</strong></td>
<td><strong>描述</strong></td>
</tr>
<tr>
<td><code>:enabled</code></td>
<td>匹配所有可用元素</td>
</tr>
<tr>
<td><code>:disabled</code></td>
<td>匹配所有不可用元素</td>
</tr>
<tr>
<td><code>:checked</code></td>
<td>匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</td>
</tr>
<tr>
<td><code>:selected</code></td>
<td>匹配所有选中的option元素</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意可以同时使用，例如选择文本中不可用元素可以这样：</span><br><span class="line"> $(&#x27;:text:disabled&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><table>
<thead>
<tr>
<th>过滤方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>eq()</td>
<td>获取第N个元素</td>
</tr>
<tr>
<td>first()</td>
<td>获取第一个元素</td>
</tr>
<tr>
<td>last()</td>
<td>获取最后一个元素</td>
</tr>
<tr>
<td>hasClass()</td>
<td>检查当前的元素是否含有某个特定的类，如果有，则返回true</td>
</tr>
<tr>
<td>filter()</td>
<td>筛选出与指定表达式匹配的元素集合</td>
</tr>
<tr>
<td>not()</td>
<td>删除与指定表达式匹配的元素</td>
</tr>
<tr>
<td>is()</td>
<td>根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true</td>
</tr>
<tr>
<td>has()</td>
<td>保留包含特定后代的元素，去掉那些不含有指定后代的元素</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>查找方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>children()</td>
<td>取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合</td>
</tr>
<tr>
<td>find()</td>
<td>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法</td>
</tr>
<tr>
<td>siblings()</td>
<td>取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合</td>
</tr>
<tr>
<td>next()</td>
<td>取得一个包含匹配的元素集合中每一个元素紧邻的后一个同辈元素的元素集合</td>
</tr>
<tr>
<td>nextAll()</td>
<td>查找当前元素之后所有的同辈元素</td>
</tr>
<tr>
<td>nextUntil()</td>
<td>查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止</td>
</tr>
<tr>
<td>prev()</td>
<td>取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合</td>
</tr>
<tr>
<td>prevAll()</td>
<td>查找当前元素之前所有的同辈元素</td>
</tr>
<tr>
<td>prevUntil()</td>
<td>查找当前元素之前所有的同辈元素，直到遇到匹配的那个元素为止</td>
</tr>
<tr>
<td>offsetParent()</td>
<td>返回第一个匹配元素用于定位的父节点</td>
</tr>
<tr>
<td>parent()</td>
<td>取得一个包含着所有匹配元素的唯一父元素的元素集合</td>
</tr>
<tr>
<td>parentsUntil()</td>
<td>查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止</td>
</tr>
</tbody></table>
<p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20230502205541014-9f093e.png" alt="image-20230502205541014"></p>
<h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量内部DOM元素（伪数组形式存储）的过程就叫做隐式迭代，相当于选中元素后，自动会给匹配到元素进行循环遍历，执行相应的方法，而不用我们自己去进行循环遍历</span><br></pre></td></tr></table></figure>

<h2 id="基本工具方法"><a href="#基本工具方法" class="headerlink" title="基本工具方法"></a>基本工具方法</h2><table>
<thead>
<tr>
<th>工具方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$.each(object,[callback])</td>
<td>通用例遍方法，可用于例遍对象和数组,callback是一个函数</td>
</tr>
<tr>
<td>$.type(obj)</td>
<td>检测obj的数据类型</td>
</tr>
<tr>
<td>$.isArray(obj)</td>
<td>测试对象是否为数组</td>
</tr>
<tr>
<td>$.isFunction(obj)</td>
<td>测试对象是否为函数</td>
</tr>
<tr>
<td>$.isNumeric(value)</td>
<td>测试对象是否为数字</td>
</tr>
<tr>
<td>$.parseJSON(json)</td>
<td>接受一个JSON字符串，返回解析后的对象</td>
</tr>
<tr>
<td>$.trim(str)</td>
<td>去除str旁边空格</td>
</tr>
</tbody></table>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>attr(name,value)</td>
<td>设置或返回被选元素的属性值，如果只传入第一个参数，那么返回这个对象属性的值，如果两个参数都输入，那么对这个对象的属性值进行修改</td>
</tr>
<tr>
<td>removeAttr(name)</td>
<td>从每一个匹配的元素中删除一个属性,传入为属性名称</td>
</tr>
<tr>
<td>prop()</td>
<td>获取在匹配的元素集中的第一个元素的属性值</td>
</tr>
<tr>
<td>removeProp()</td>
<td>用来删除由.prop()方法设置的属性集</td>
</tr>
<tr>
<td>addClass(value)</td>
<td>为每个匹配的元素添加指定的类名</td>
</tr>
<tr>
<td>removeClass(value)</td>
<td>从所有匹配的元素中删除全部或者指定的类</td>
</tr>
<tr>
<td>toggleClass(value)</td>
<td>如果存在（不存在）就删除（添加）一个类，相当于获取一个元素，如果元素有value这个类，那么就删除这个类，如果不存在这个类，那么就把这个类加上</td>
</tr>
<tr>
<td>html(value)参数可选</td>
<td>取得第一个匹配元素的html内容，如果不传递参数，那么返回选中的元素里面的html内容，包括标签，如果传入参数，相当于把选中的元素里面的html内容替换为传递的参数</td>
</tr>
<tr>
<td>text()</td>
<td>取得所有匹配元素的内容</td>
</tr>
<tr>
<td>val(value)参数可选</td>
<td>获得匹配元素的当前值,不传递参数获取到value属性的值，传递参数进行替换</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于prop和attr的区别：</span><br><span class="line">对于自定义属性的操作，使用attr方法，</span><br><span class="line">对于固有属性两者看情况使用，固有属性是dom自带的属性，一般推荐使用prop，因为比较快</span><br><span class="line">对于属性值是Boolean的方法，使用prop方法</span><br></pre></td></tr></table></figure>

<h2 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h2><table>
<thead>
<tr>
<th>CSS</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>css()</td>
<td>访问匹配元素的样式属性，详细看下面例子</td>
</tr>
<tr>
<td>offset()</td>
<td>获取匹配元素在当前视口的相对偏移，获取完成后可以用top,left等方位具体查看</td>
</tr>
<tr>
<td>position()</td>
<td>获取匹配元素相对父元素的偏移，获取完成后可以用top,left等方位具体查看</td>
</tr>
<tr>
<td>scrollTop()</td>
<td>获取匹配元素相对滚动条顶部的偏移</td>
</tr>
<tr>
<td>scrollLeft()</td>
<td>获取匹配元素相对滚动条左侧的偏移</td>
</tr>
<tr>
<td>height()</td>
<td>取得匹配元素当前计算的高度值（px）height值</td>
</tr>
<tr>
<td>width()</td>
<td>取得第一个匹配元素当前计算的宽度值（px）width值</td>
</tr>
<tr>
<td>innerHeight()</td>
<td>获取第一个匹配元素内部区域高度（包括补白、不包括边框）height + padding</td>
</tr>
<tr>
<td>innerWidth()</td>
<td>获取第一个匹配元素内部区域宽度（包括补白、不包括边框）width + padding</td>
</tr>
<tr>
<td>outerHeight(false&#x2F;true)</td>
<td>获取第一个匹配元素外部高度（默认包括补白和边框）height + padding + border<code> 如果是</code>true<code>，加上</code>margin</td>
</tr>
<tr>
<td>outerWidth(false&#x2F;true)</td>
<td>获取第一个匹配元素外部宽度（默认包括补白和边框）width + padding + border<code> 如果是</code>true<code>，加上</code>margin</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">CSS</span>()函数来讲</span><br><span class="line">一般有三种用法：</span><br><span class="line">$(<span class="string">&#x27;ul&gt;li:first&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>) =&gt;返回这个样式的值</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;ul&gt;li:first&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>，<span class="string">&#x27;red&#x27;</span>)=&gt; 对样式进行修改</span><br><span class="line">$(<span class="string">&#x27;ul&gt;li:first&#x27;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span></span><br><span class="line"> &#125;)  =&gt;也是对样式进行修改，不过用大括号进行多样式修改</span><br></pre></td></tr></table></figure>

<h2 id="JS文档操作"><a href="#JS文档操作" class="headerlink" title="JS文档操作"></a>JS文档操作</h2><table>
<thead>
<tr>
<th>文档处理方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>内部插入</td>
<td></td>
</tr>
<tr>
<td>append()</td>
<td>向每个匹配的元素内部追加内容</td>
</tr>
<tr>
<td>appendTo()</td>
<td>把所有匹配的元素追加到另一个指定的元素元素集合中</td>
</tr>
<tr>
<td>prepend()</td>
<td>向每个匹配的元素内部前置内容</td>
</tr>
<tr>
<td>prependTo()</td>
<td>把所有匹配的元素前置到另一个、指定的元素元素集合中</td>
</tr>
<tr>
<td>外部插入</td>
<td></td>
</tr>
<tr>
<td>after()</td>
<td>在每个匹配的元素之后插入内容</td>
</tr>
<tr>
<td>before()</td>
<td>在每个匹配的元素之前插入内容</td>
</tr>
<tr>
<td>insertAfter()</td>
<td>把所有匹配的元素插入到另一个、指定的元素元素集合的后面</td>
</tr>
<tr>
<td>insertBefore()</td>
<td>把所有匹配的元素插入到另一个、指定的元素元素集合的前面</td>
</tr>
<tr>
<td>包裹</td>
<td></td>
</tr>
<tr>
<td>wrap()</td>
<td>把所有匹配的元素用其他元素的结构化标记包裹起来</td>
</tr>
<tr>
<td>unwrap()</td>
<td>这个方法将移出元素的父元素</td>
</tr>
<tr>
<td>wrapAll()</td>
<td>将所有匹配的元素用单个元素包裹起来</td>
</tr>
<tr>
<td>wrapInner()</td>
<td>将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来</td>
</tr>
<tr>
<td>替换</td>
<td></td>
</tr>
<tr>
<td>replaceWith()</td>
<td>将所有匹配的元素替换成指定的HTML或DOM元素</td>
</tr>
<tr>
<td>replaceAll()</td>
<td>用匹配的元素替换掉所有 selector匹配到的元素</td>
</tr>
<tr>
<td>删除</td>
<td></td>
</tr>
<tr>
<td>empty()</td>
<td>删除匹配的元素集合中所有的子节点</td>
</tr>
<tr>
<td>remove()</td>
<td>从DOM中删除所有匹配的元素</td>
</tr>
<tr>
<td>detach()</td>
<td>从DOM中删除所有匹配的元素</td>
</tr>
<tr>
<td>克隆</td>
<td></td>
</tr>
<tr>
<td>clone()</td>
<td>克隆匹配的DOM元素并且选中这些克隆的副本</td>
</tr>
</tbody></table>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.1&#x27;</span>).<span class="title function_">append</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line"> $(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">appendTo</span>($(<span class="string">&#x27;.2&#x27;</span>))</span><br><span class="line">一个是将内容插入到选中的元素中，一个是将选中的内容插入到后面集合中，</span><br><span class="line">注意是添加在原有集合的最后</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.1 span&#x27;</span>).<span class="title function_">prepend</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line"> $(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">prependTo</span>($(<span class="string">&#x27;.2 span&#x27;</span>))</span><br><span class="line">用法和上面方法类似，但是是插入到原有集合的前面</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.1&#x27;</span>).<span class="title function_">before</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line">$(<span class="string">&#x27;.1&#x27;</span>).<span class="title function_">after</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>);</span><br><span class="line">$(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">insertBefore</span>($(<span class="string">&#x27;.2&#x27;</span>))</span><br><span class="line">$(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">insertAfter</span>($(<span class="string">&#x27;.2&#x27;</span>))</span><br><span class="line">用法类似于上面的内部插入</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> $(<span class="string">&#x27;.1 span&#x27;</span>).<span class="title function_">replaceWith</span>(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>)</span><br><span class="line"> $(<span class="string">&#x27;&lt;br&gt;&lt;span&gt;append添加的span&lt;/span&gt;&#x27;</span>).<span class="title function_">replaceAll</span>($(<span class="string">&#x27;.2 span&#x27;</span>))</span><br><span class="line">对于替换来讲，方法和上面几种方法大差不大，但是也是要注意什么时候前面替换后面，什么时候后面替换前面</span><br></pre></td></tr></table></figure>

<h3 id="empty-remove-detach区别"><a href="#empty-remove-detach区别" class="headerlink" title="empty remove detach区别"></a>empty remove detach区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于empty，他只是清除选中的元素里面的子节点元素，本来的节点元素不进行处理，换句话讲，是将选中的节点元素里面赋值为空</span><br><span class="line">remove,删除元素，包括绑定的事件，附加数据</span><br><span class="line">detach 删除被选元素，包括所有文本和子节点。<span class="title function_">detach</span>() 会保留所有绑定的事件、附加的数据</span><br><span class="line"></span><br><span class="line">看下面的例子：</span><br><span class="line">   &lt;p&gt;区别&lt;/p&gt;</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="string">&quot;remove与detach的区别&quot;</span>) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=$(<span class="string">&quot;p&quot;</span>).<span class="title function_">remove</span>()</span><br><span class="line">	删除的p元素的jquery对象， 当重新将保留下来的p元素塞回到body中,当再点击p元素的时候并没有触发click事件，即事件已经被remove事件移除掉。</span><br><span class="line"><span class="keyword">var</span> a=$(<span class="string">&quot;p&quot;</span>).<span class="title function_">detach</span>()</span><br><span class="line">	删除的p元素的jquery对象， 当重新将保留下来的p元素塞回到body中,当再点击p元素的时候触发click事件，即事件依然保留在元素上，detach事件并没有移除掉p元素的事件。</span><br><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).<span class="title function_">after</span>(a)</span><br></pre></td></tr></table></figure>

<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><table>
<thead>
<tr>
<th>事件方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>页面载入</td>
<td></td>
</tr>
<tr>
<td>ready()</td>
<td>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数</td>
</tr>
<tr>
<td>事件处理</td>
<td></td>
</tr>
<tr>
<td>on()</td>
<td>在选择元素上绑定一个或多个事件的事件处理函数</td>
</tr>
<tr>
<td>off()</td>
<td>在选择元素上移除一个或多个事件的事件处理函数</td>
</tr>
<tr>
<td>bind()</td>
<td>为每个匹配元素的特定事件绑定事件处理函数</td>
</tr>
<tr>
<td>unbind()</td>
<td>bind()的反向操作，从每一个匹配的元素中删除绑定的事件</td>
</tr>
<tr>
<td>one()</td>
<td>为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数，这个事件只会触发一次</td>
</tr>
<tr>
<td>trigger()</td>
<td>在每一个匹配的元素上触发某类事件</td>
</tr>
<tr>
<td>triggerHandler()</td>
<td>这个特别的方法将会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认动作，也不会产生事件冒泡</td>
</tr>
<tr>
<td>事件委派</td>
<td></td>
</tr>
<tr>
<td>delegate()</td>
<td>指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数</td>
</tr>
<tr>
<td>undelegate()</td>
<td>删除由 delegate() 方法添加的一个或多个事件处理程序</td>
</tr>
<tr>
<td>事件切换</td>
<td></td>
</tr>
<tr>
<td>hover()</td>
<td>一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法</td>
</tr>
<tr>
<td>toggle()</td>
<td>用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件</td>
</tr>
<tr>
<td>事件</td>
<td></td>
</tr>
<tr>
<td>focus()、focusin()</td>
<td>当元素获得焦点时，触发 focus、focusin 事件</td>
</tr>
<tr>
<td>blur()、focusout()</td>
<td>当元素失去焦点时，触发 blur、focusout 事件</td>
</tr>
<tr>
<td>change()</td>
<td>当元素的值发生改变时，会发生 change 事件</td>
</tr>
<tr>
<td>click()</td>
<td>触发每一个匹配元素的click事件</td>
</tr>
<tr>
<td>dblclick()</td>
<td>当双击元素时，会发生 dblclick 事件</td>
</tr>
<tr>
<td>error()</td>
<td>当元素遇到错误（没有正确载入）时，发生 error 事件</td>
</tr>
<tr>
<td>mousedown()</td>
<td>当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件</td>
</tr>
<tr>
<td>mouseup()</td>
<td>当在元素上放松鼠标按钮时，会发生 mouseup 事件</td>
</tr>
<tr>
<td>mouseenter()</td>
<td>当鼠标指针穿过元素时，会发生 mouseenter 事件</td>
</tr>
<tr>
<td>mouseleave()</td>
<td>当鼠标指针离开元素时，会发生 mouseleave 事件</td>
</tr>
<tr>
<td>mouseover()</td>
<td>当鼠标指针位于元素上方时，会发生 mouseover 事件</td>
</tr>
<tr>
<td>mouseout()</td>
<td>当鼠标指针从元素上移开时，发生 mouseout 事件</td>
</tr>
<tr>
<td>mousemove()</td>
<td>当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件</td>
</tr>
<tr>
<td>keypress()</td>
<td>当键盘或按钮被按下时，发生 keypress 事件</td>
</tr>
<tr>
<td>keydown()</td>
<td>当键盘或按钮被按下时，发生 keydown 事件</td>
</tr>
<tr>
<td>keyup()</td>
<td>当按钮被松开时，发生 keyup 事件</td>
</tr>
<tr>
<td>resize()</td>
<td>当调整浏览器窗口的大小时，发生 resize 事件</td>
</tr>
<tr>
<td>scroll()</td>
<td>当用户滚动指定的元素时，会发生 scroll 事件</td>
</tr>
<tr>
<td>select()</td>
<td>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件</td>
</tr>
<tr>
<td>submit()</td>
<td>当提交表单时，会发生 submit 事件</td>
</tr>
<tr>
<td>unload()</td>
<td>在当用户离开页面时，会发生 unload 事件</td>
</tr>
</tbody></table>
<h3 id="on和bind的区别"><a href="#on和bind的区别" class="headerlink" title="on和bind的区别"></a>on和bind的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于on事件，有四个参数$(selector).on(event,childSelector,data,function)</span><br><span class="line">event	必需。规定要从被选元素移除的一个或多个事件或命名空间。由空格分隔多个事件值，也可以是数组。必须是有效的事件。</span><br><span class="line">childSelector	可选。规定只能添加到指定的子元素上的事件处理程序（且不是选择器本身，比如已废弃的 delegate() 方法）。</span><br><span class="line">data	可选。规定传递到函数的额外数据。</span><br><span class="line">function	可选。规定当事件发生时运行的函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于bind事件 $(selector).bind(event,data,function,map)</span><br><span class="line">event	必需。规定添加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。</span><br><span class="line">data	可选。规定传递到函数的额外数据。</span><br><span class="line">function	必需。规定当事件发生时运行的函数。</span><br><span class="line">map	规定事件映射 (&#123;event:function, event:function, ...&#125;)，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对于两者的区别在于：</span><br><span class="line">bind只能给符合条件的元素本身添加事件 </span><br><span class="line">on可以将子元素的事件委托给父元素进行处理,而且可以给动态添加的元素加上绑定事件</span><br><span class="line"></span><br><span class="line">举个简单的例子：比如下例:</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;第一个子元素&lt;li/&gt;</span><br><span class="line">    &lt;li&gt;第二个子元素&lt;li/&gt;</span><br><span class="line">    &lt;li&gt;第三个子元素&lt;li/&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">我们想给所有li添加click事件,可以用on:我们想给所有li添加click事件,可以用on:</span><br><span class="line"> $(&#x27;ul&#x27;).on(&#x27;click&#x27;,&#x27;li&#x27;, function () &#123;   </span><br><span class="line">        console.log($(this).text());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">也可以用bind:</span><br><span class="line"> $(&#x27;ul li&#x27;).bind(&#x27;click&#x27;, function () &#123; </span><br><span class="line">        console.log($(this).text());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">有什么区别呢?</span><br><span class="line">第一用on绑定实际上是委托给了父级ul,也就是只给 一个元素绑定了事件</span><br><span class="line">第二个是用选择器选择了ul下的所有li元素 依次绑定了事件</span><br><span class="line">假如有很多很多子元素区别就很大了, bind会严重影响性能!</span><br><span class="line"></span><br><span class="line">假如这时候新添一个li:</span><br><span class="line">$(&#x27;ul&#x27;).append(&#x27;&lt;li&gt;第四个子元素&lt;li&gt;&#x27;)；</span><br><span class="line">如果是on绑定则这个li也会有点击事件</span><br><span class="line">如果是bind则没有</span><br><span class="line"></span><br><span class="line">所以一般推荐使用on，on在对子元素的绑定中，类似事件委派的效果</span><br></pre></td></tr></table></figure>

<h3 id="mouseover-mouseout与mouseenter-mouseleave的区别"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别" class="headerlink" title="mouseover&#x2F;mouseout与mouseenter&#x2F;mouseleave的区别"></a><code>mouseover</code>&#x2F;<code>mouseout</code>与<code>mouseenter</code>&#x2F;<code>mouseleave</code>的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mouseover/mouseout进入和离开子元素会再次触发函数，相当于从父元素跨到子元素的阶段，会执行mouseout再接着执行mouseover函数，</span><br><span class="line">mouseenter/mouseleave进入和离开子元素不会再次触发</span><br></pre></td></tr></table></figure>

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><table>
<thead>
<tr>
<th>动画</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>基本</td>
<td></td>
</tr>
<tr>
<td>show()</td>
<td>显示隐藏的匹配元素</td>
</tr>
<tr>
<td>hide()</td>
<td>隐藏显示的元素</td>
</tr>
<tr>
<td>toggle()</td>
<td>用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件</td>
</tr>
<tr>
<td>滑动</td>
<td>无参数默认缓慢，有参数可以分为数字参数和文字参数</td>
</tr>
<tr>
<td>slideDown()</td>
<td>通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>slideUp()</td>
<td>通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>slideToggle()</td>
<td>通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>淡入淡出</td>
<td></td>
</tr>
<tr>
<td>fadeIn()</td>
<td>通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>fadeOut()</td>
<td>通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>fadeTo()</td>
<td>把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>fadeToggle()</td>
<td>通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数</td>
</tr>
<tr>
<td>自定义</td>
<td></td>
</tr>
<tr>
<td>animate()</td>
<td>用于创建自定义动画的函数</td>
</tr>
<tr>
<td>stop()</td>
<td>停止所有在指定元素上正在运行的动画</td>
</tr>
<tr>
<td>finish()</td>
<td>停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画</td>
</tr>
<tr>
<td>delay()</td>
<td>设置一个延时来推迟执行队列中之后的项目</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数([speed,[easing],[fn]])</span><br><span class="line">参数都可以省略， 无动画直接显示</span><br><span class="line">speed 三种预定速度之一的字符串（&#x27;slow&#x27;, &#x27;normal&#x27;, &#x27;fast&#x27;）或表示动画时长的毫秒数值（如：1000）</span><br><span class="line">easing (Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”</span><br><span class="line">fn 回调函数，在动画完成时执行的函数，每个元素执行一次</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hover([over,] out)</span><br><span class="line">over 鼠标移到元素上要触发的函数（相当于mouseenter）</span><br><span class="line">out 鼠标移出元素要触发的函数（相当于mouseleave）</span><br><span class="line">如果只写一个函数，则鼠标经过和离开都会触发它</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animate(params, [speed], [easing], [fn])</span><br><span class="line">params 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号， 如果是复合属性则需要采取驼峰命名法 borderLeft。其余参数都可以省略</span><br></pre></td></tr></table></figure>



<h2 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h2><h4 id="this使用"><a href="#this使用" class="headerlink" title="this使用"></a>this使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于jQuery来讲，进行遍历的时候，this变成了DOM对象，可以打印查看，如果要用Jquery里面方法，那么先要转化为jQuery对象来进行处理$(this)</span><br></pre></td></tr></table></figure>

<h2 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=jQuery&spm=1001.2101.3001.7020">jQuery</a>插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于 jQuery 编写的扩展库</span><br><span class="line">http://plugins.jquery.com/</span><br><span class="line">validation--验证库</span><br><span class="line">https://github.com/jquery-validation/jquery-validation/releases</span><br><span class="line">ui库</span><br><span class="line">http://jqueryui.com/</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery 插件常用的网站</span><br><span class="line">jQuery 插件库 http://www.jq22.com/ 懒加载 </span><br><span class="line">jQuery 之家 http://www.htmleaf.com/</span><br><span class="line">jQuery 插件使用步骤</span><br><span class="line">引入相关文件（jQuery 文件 和 插件文件）    </span><br><span class="line">复制相关html、css、js (调用插件)</span><br><span class="line">jQuery 插件演示</span><br><span class="line"></span><br><span class="line">瀑布流</span><br><span class="line">图片懒加载（图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载）</span><br><span class="line">当我们页面滑动到可视区域，再显示图片。</span><br><span class="line">我们使用jquery插件库  EasyLazyload。</span><br><span class="line">注意，此时的js引入文件和js调用必须写到 DOM元素（图片）最后面</span><br><span class="line">EasyLazyload.js</span><br><span class="line">(3 KB)</span><br><span class="line">EasyLazyload.min.js</span><br><span class="line">(2 KB)</span><br><span class="line">全屏滚动（fullpage.js）</span><br><span class="line">gitHub https://github.com/alvarotrigo/fullPage.js</span><br><span class="line">中文翻译网站 http://www.dowebok.com/demo/2014/77/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bootstrap JS 插件</span><br><span class="line">bootstrap 框架也是依赖于 jQuery 开发的，因此里面的 js插件使用 ，也必须引入 jQuery 文件</span><br><span class="line">https://v3.bootcss.com/</span><br></pre></td></tr></table></figure>

<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">请求报文</span><br><span class="line">请求行</span><br><span class="line">请求类型：<span class="variable constant_">GET</span>/<span class="variable constant_">POST</span>/<span class="variable constant_">PUT</span>/<span class="variable constant_">DELETE</span>/<span class="variable constant_">PATCH</span></span><br><span class="line"><span class="variable constant_">URL</span> 路径：s?ie=utf-<span class="number">8</span></span><br><span class="line"><span class="variable constant_">HTTP</span> 协议版本：<span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line">请求头</span><br><span class="line"><span class="title class_">Host</span>: atguigu.<span class="property">com</span></span><br><span class="line"><span class="title class_">Cookie</span>: name=guigu</span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: chrome <span class="number">83</span></span><br><span class="line">…</span><br><span class="line">空行：固定格式，必须有</span><br><span class="line">请求体：<span class="variable constant_">GET</span>请求，请求体为空；<span class="variable constant_">POST</span>请求，请求体可以不为空</span><br><span class="line">username=admin&amp;password=admin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">响应报文</span><br><span class="line">响应行</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span> 协议版本：<span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line">响应状态码：<span class="number">200</span>/<span class="number">404</span>/<span class="number">500</span></span><br><span class="line">响应状态字符串：<span class="variable constant_">OK</span>/<span class="title class_">Not</span> <span class="title class_">Found</span>/<span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span>，与响应状态码对应</span><br><span class="line">响应头</span><br><span class="line"></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">length</span>: <span class="number">2048</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">encoding</span>: gzip</span><br><span class="line">…</span><br><span class="line">空行：固定格式，必须有</span><br><span class="line"></span><br><span class="line">响应体，一般可以用json格式返回</span><br></pre></td></tr></table></figure>

<h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client error(客户端错误)</td>
<td>客户端请求出错</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态字符串</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>请求资源的 URL 被暂时修改到 Location 提供的 URL</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>资源未变更</td>
</tr>
<tr>
<td>308</td>
<td>Permanent Redirect</td>
<td>永久重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>请求语法有问题，服务器无法识别</td>
</tr>
<tr>
<td>401</td>
<td>UnAuthorized</td>
<td>客户端未授权该请求</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器拒绝响应</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>URL 无效或者 URL 有效但是没有资源</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>服务器作为网关使用时，收到上游服务器返回的无效响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>无法服务。一般发生在因维护而停机或者服务过载</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>网关超时</td>
</tr>
<tr>
<td>505</td>
<td>Http Version Not Supported</td>
<td>发出的请求http版本服务器不支持</td>
</tr>
</tbody></table>
<h2 id="AJAX发生get请求"><a href="#AJAX发生get请求" class="headerlink" title="AJAX发生get请求"></a>AJAX发生get请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、创建对象</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="number">2</span>、初始化</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="attr">http</span>:<span class="comment">//127.0.0.1:8080/demo?a=100&amp;b=200&amp;c=300当然也可以像这样传递数据，后端springboot要用@RequestParam注解去进行接收注入</span></span><br><span class="line"><span class="number">3</span>、发送</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="number">4</span>、事件绑定，处理服务器端返回的结果</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">对于xhr的一些参数</span><br><span class="line">readeyState</span><br><span class="line"><span class="number">0</span>：未初始化</span><br><span class="line"><span class="number">1</span>：open 方法调用完毕</span><br><span class="line"><span class="number">2</span>：send 方法调用完毕</span><br><span class="line"><span class="number">3</span>：服务端返回部分结果</span><br><span class="line"><span class="number">4</span>：服务端返回所有结果</span><br><span class="line"></span><br><span class="line">status：状态码</span><br><span class="line"></span><br><span class="line">statusText：状态字符串</span><br><span class="line"></span><br><span class="line"><span class="title function_">getAllResponseHeaders</span>()：响应头</span><br><span class="line"></span><br><span class="line">response：响应体</span><br></pre></td></tr></table></figure>

<h2 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、创建对象</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="number">2</span>、初始化</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8080/demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、发送</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="number">4</span>、事件绑定，处理服务器端返回的结果</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">如果要发送数据向后端，用@<span class="title class_">RequestBody</span>接收的话，那么就需要进行下面修改</span><br><span class="line"> xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"><span class="comment">//修改传递参数格式，因为后端接收为JSON格式，所以前段得修改为JSON格式才可以</span></span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            <span class="string">&quot;account&quot;</span>: <span class="string">&quot;22222222222220&quot;</span>,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//JSON对象转化为字符串传递，当然也可以简单传递，a=100&amp;b=200&amp;c=300这样，但是一般推荐下面的方法</span></span><br><span class="line"> xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用jQuery发送"><a href="#用jQuery发送" class="headerlink" title="用jQuery发送"></a>用jQuery发送</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="comment">// 请求地址</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8080/demo&#x27;</span>,</span><br><span class="line">    <span class="comment">// 请求参数</span></span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;),</span><br><span class="line">    <span class="comment">// 请求类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">contentType</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="comment">// 响应体类型-----------不推荐</span></span><br><span class="line">    <span class="comment">// dataType: &#x27;json&#x27;,</span></span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">        <span class="comment">// console.log(typeof data, data); // string &#123;name: &quot;Hello jquery&quot;&#125;  开启dataType后：object &#123;name: &quot;Hello jquery&quot;&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="attr">error</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// // 头信息</span></span><br><span class="line">    <span class="comment">// headers: &#123;</span></span><br><span class="line">    <span class="comment">//     c: 300,</span></span><br><span class="line">    <span class="comment">//     d: 400</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="JSONP解决跨域问题—感觉没用-没看"><a href="#JSONP解决跨域问题—感觉没用-没看" class="headerlink" title="JSONP解决跨域问题—感觉没用 没看"></a>JSONP解决跨域问题—感觉没用 没看</h2><h1 id="layui-的layer弹出层"><a href="#layui-的layer弹出层" class="headerlink" title="layui 的layer弹出层"></a>layui 的layer弹出层</h1><p><img src= "/image/loading.gif" data-lazy-src="/image/loading.gif" data-original="https://raw.githubusercontent.com/Curry-jay/image-store/main/PicGo/2025/01/11/image-20250105234257017-0fb210.png" alt="image-20250105234257017"></p>
<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38490457/article/details/109257751?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168183199316800186596889%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168183199316800186596889&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109257751-null-null.142%5Ev84%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=js%E5%AD%A6%E4%B9%A0&spm=1018.2226.3001.4187">学习JavaScript这一篇就够了</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cessstudy/kak11d/fg5v84">鱼雀笔记</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="qq:860211327">Curry Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://curry-jay.github.io/posts/11351.html">https://curry-jay.github.io/posts/11351.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://curry-jay.github.io" target="_blank">Curry的小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/javaScript/">javaScript</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/36266.html" title="ES6语法"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/javaScript/ES6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ES6语法</div></div><div class="info-2"><div class="info-item-1">模版字符串模板字符串（template string）是增强版的字符串，用反引号 ` 标识，特点字符串中可以出现换行符可以使用 $&#123;xxx&#125; 形式输出变量，近似 EL 表达式应用场景：当遇到字符串与变量拼接的情况使用模板字符串let name = &#x27;jack&#x27;;console.log(`hello, $&#123;name&#125;`);let ul = `&lt;ul&gt;            &lt;li&gt;apple&lt;/li&gt;            &lt;li&gt;banana&lt;/li&gt;            &lt;li&gt;peach&lt;/li&gt;          &lt;/ul&gt;  rest参数和spread扩展运算符对于rest参数来讲，相当于对于不确定的函数参数，可以把他转化为数组接收let fn =(a,b,...args) =&gt;&#123;...</div></div></div></a><a class="pagination-related" href="/posts/63612.html" title="C++使用"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/selfStudy/C++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++使用</div></div><div class="info-2"><div class="info-item-1">基础C++里面单引号表示单个字符，双引号表示两个字节 eg:&#x27;a&#x27; 表示一个字符a，“a”表示a\0   a加上结束符号  c++表示八进制和十六进制都是一个字节 \ddd表示八进制 &gt; \234\xdd表示十六进制 &gt;\x232  strlen 和 sizeof区别 strlen计算长度时候，当碰到\0后终止，后面的字符不进行长度的计算而sizeof在进行计算的时候，计算所有的字符注意“”  有个\0结束字符在sizeof的时候也会计算  指数 对于C++来说，指数是E或者e来表示2e-6 -1.5E2  如果结尾加个F(f)表示结果为float类型的数据e(E)后(即指数)必须是整数  const const表示常量，这个变量值不可以发生变化  运算符优先级 逻辑运算符的先后：非&gt;与&gt;或逻辑运算符 &gt; 条件运算符&gt;值运算符  预处理指令 ——感觉不重要 #define  #ifdef #ifndef...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/36266.html" title="ES6语法"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/javaScript/ES6.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-05</div><div class="info-item-2">ES6语法</div></div><div class="info-2"><div class="info-item-1">模版字符串模板字符串（template string）是增强版的字符串，用反引号 ` 标识，特点字符串中可以出现换行符可以使用 $&#123;xxx&#125; 形式输出变量，近似 EL 表达式应用场景：当遇到字符串与变量拼接的情况使用模板字符串let name = &#x27;jack&#x27;;console.log(`hello, $&#123;name&#125;`);let ul = `&lt;ul&gt;            &lt;li&gt;apple&lt;/li&gt;            &lt;li&gt;banana&lt;/li&gt;            &lt;li&gt;peach&lt;/li&gt;          &lt;/ul&gt;  rest参数和spread扩展运算符对于rest参数来讲，相当于对于不确定的函数参数，可以把他转化为数组接收let fn =(a,b,...args) =&gt;&#123;...</div></div></div></a><a class="pagination-related" href="/posts/19874.html" title="NodeJs"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/NodeJs.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-06</div><div class="info-item-2">NodeJs</div></div><div class="info-2"><div class="info-item-1">Nodejs基础安装以及认识认识nodejsnodejs就是一款应用程序，是一款软件，可以运行JavaScript作用：开发服务器应用，开发工具类应用，开发桌面端应用  下载和安装https://nodejs.org/en选择LTS类型进行安装，长期维护稳定版本验证安装：打开cmd ，node -v查看版本号  cmd基本用法（复习）切换盘符     D：查看当前目录下的文件 dir   dir /s  查看当前目录下所有的文件，包括子文件切换文件  cd 文件名称  切换到上一级 cd ..停止运行 ctrl+c用TAb键可以选择dir  使用node运行js文件用 cmd 将目录切换到js文件目录， node 文件名.js 就可以运行在vscode中运行：右键文件 &gt; 在集成终端中打开，之后和cmd一样 的操作 node 文件名.js  nodejs中不可以使用webAPI  因为nodejs对象中不包含dom和bom对象有一样的  console 和 定时器对象  顶级对象在nodejs中的顶级对象不是window 而是global对象 或者globalThis ...</div></div></div></a><a class="pagination-related" href="/posts/54938.html" title="基础HTML+CSS"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/html.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-06</div><div class="info-item-2">基础HTML+CSS</div></div><div class="info-2"><div class="info-item-1">VS自用快捷键！可以自动补全一个网页自带的一些信息ctrl+k 格式化代码ctrl+l 选中一行ctrl+enter 自动运行    基础HTML和CSS标签metameta标签来说，主要来设置网页的源数据meta主要用于设置网页中的一些元数据，元数据并不是给用户看的,是给浏览器或者搜索引擎看的属性：charset:指定网页的字符集	 name:指定的数据的名称  一般常用的属性有以下两个	 	 	keywords:表示网站的关键字，可以同时指定多个关键字，关键字间使用，隔开。进行搜索的时候用作关键字来识别	 	description:表示网站的描述信息,	 content：制定的数据内容，会作为搜索结果的文字进行展示	title 内容会作为搜索结果的找链接展示出来  eg: &lt;meta charset=&quot;utf8&quot; version=&#x27;1&#x27;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,...</div></div></div></a><a class="pagination-related" href="/posts/29954.html" title="前端遗忘"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/background.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-05</div><div class="info-item-2">前端遗忘</div></div><div class="info-2"><div class="info-item-1">前端遗忘字体居中相当于对于一个块元素，都可以试试，整个占据一整行对于字体的居中，ul和h1在进行居中的时候，块元素居中，即包裹不仅仅包括自己，可以采用这种方法  text-align: center;  表格线条合并对每一个单元格和表格，都有边框，对他们的边框进行重合  border-collapse: collapse;  利用Jquery对集合遍历$(rowData).each(function (index, Student) &#123;&#125;）  表单参数获取let params = $(&quot;#stuAddForm&quot;).serialize();  清空表单$(&quot;#stuAddForm&quot;)[0].reset();  ajax设置contentType: &#x27;application/json&#x27;,设置传递的对象是JSON对象JSON.stringify() JSON对象转化为字符串  获取表格的值$(&quot;#stuAddForm...</div></div></div></a><a class="pagination-related" href="/posts/43782.html" title="Vue"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/Vue/Vue.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-27</div><div class="info-item-2">Vue</div></div><div class="info-2"><div class="info-item-1">VUE初始化npm i vue@2.6.13具体操作可以看nodejs文档列表模块：npm ls卸载模块：npm uninstall 模块名更新模块：npm update 模块名运行工程：npm run dev/test编译工程：npm run build  创建，构建一个IDEA（javascript项目） 并进入目录  vue init webpack     入门使用相当于new一个Vue对象  new Vue(&#123;        //选择一个组件和它进行绑定,产生一个绑定关系，和组件绑定起来        el: &quot;#app&quot;,        //数据进行绑定        data: &#123;    title: &#x27;VUE入门讲解&#x27;,&#125;        &#125;）          之后可以通过胡须表达式就可以获取到数据   &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;可以用@click...</div></div></div></a><a class="pagination-related" href="/posts/21575.html" title="vue所有流程（网课学习版本）"><img class="cover" src= "/image/loading.gif" data-lazy-src="/image/top/front/Vue/Vue.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-10</div><div class="info-item-2">vue所有流程（网课学习版本）</div></div><div class="info-2"><div class="info-item-1">环境配置nodejs相当于后端运算javaScript的运行环境 npm -v：查看npm安装的版本。npm init：会引导你建立一个package.json文件，包括名称、版本、作者等信息。npm list：查看当前目录下已安装的node包。npm ls：查看当前目录下已安装的node包。npm install moduleNames：安装Node模块到本地目录node_modules下。npm install &lt; name &gt; -g：将包安装到全局环境中。npm install &lt; name &gt; --save：安装的同时，将信息写入package.json中，项目路径中若是有package.json文件时，直接使用npm install方法就能够根据dependencies配置安装全部的依赖包，这样代码提交到git时，就不用提交node_modules这个文件夹了。npm install &lt; name&gt; --save-dev：安装的同时，将信息写入package.json中项目路径中若是有package.json文件时，直接使用npm...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/image/loading.gif" data-lazy-src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Curry Jay</div><div class="author-info-description">xjtu软件工程在读研究生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Curry-jay"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客，欢迎光临我的博客，刚开始搭建内容</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#javaScript%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">javaScript基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F-%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">表示形式&#x2F;引入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">输入和输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8Ejs%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">对于js代码的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F"><span class="toc-number">1.2.</span> <span class="toc-text">大小写敏感</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8Elet-var-const%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">对于let,var,const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-number">1.6.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.</span> <span class="toc-text">对象概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">局部变量和全局变量创建区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.11.</span> <span class="toc-text">对于获取一个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.12.</span> <span class="toc-text">this作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTML%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.13.</span> <span class="toc-text">常见的HTML事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.14.</span> <span class="toc-text">String字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%B8%80%E7%82%B9"><span class="toc-number">1.14.1.</span> <span class="toc-text">注意一点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.15.</span> <span class="toc-text">break语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">null和undefined的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.17.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debugger%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.18.</span> <span class="toc-text">debugger关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%98use-strict%E2%80%99%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.19.</span> <span class="toc-text">‘use strict’严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E9%AA%8C%E8%AF%81API"><span class="toc-number">1.20.</span> <span class="toc-text">JavaScript验证API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#validity%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">1.20.1.</span> <span class="toc-text">validity的一些属性值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json"><span class="toc-number">1.21.</span> <span class="toc-text">json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8Ejavascript-void-0"><span class="toc-number">1.22.</span> <span class="toc-text">#与javascript:void(0)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E6%8E%A5%E5%8F%A3%E5%92%8Cfor-of"><span class="toc-number">1.23.</span> <span class="toc-text">Iterator 接口和for of</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.23.1.</span> <span class="toc-text">最简单实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E6%9C%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9iterator%E4%BD%BF%E7%94%A8"><span class="toc-number">1.23.2.</span> <span class="toc-text">现有数据结构对iterator使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.23.3.</span> <span class="toc-text">for…of循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E2%80%A6in-%E5%92%8Cfor%E2%80%A6of%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.4.</span> <span class="toc-text">for…in 和for…of区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.5.</span> <span class="toc-text">其他遍历语法区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">通过值传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">通过对象传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">2.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">2.6.</span> <span class="toc-text">柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.7.</span> <span class="toc-text">原型与原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">显式原型与隐式原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.9.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">测试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.11.</span> <span class="toc-text">构造函数、实例、原型对象三者之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">2.12.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#javascript%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">javascript异步调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0this%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">回调函数this问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.3.</span> <span class="toc-text">回调函数传参问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E8%A7%84%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">promise规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#then%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">.then方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#catch%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">.catch方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">finally方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#all%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">all方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#race%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.5.</span> <span class="toc-text">race函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allsettled"><span class="toc-number">3.3.6.</span> <span class="toc-text">allsettled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-number">3.3.7.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resolve"><span class="toc-number">3.3.8.</span> <span class="toc-text">resolve</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.3.8.1.</span> <span class="toc-text">参数形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reject"><span class="toc-number">3.3.9.</span> <span class="toc-text">reject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">3.3.10.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">Generator函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yield%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">yield表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next"><span class="toc-number">3.4.2.</span> <span class="toc-text">next</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next%E5%92%8Cyield%E5%8F%82%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">next和yield参数区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8for-of%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.4.</span> <span class="toc-text">用for of遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.5.</span> <span class="toc-text">throw函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-4"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.6.</span> <span class="toc-text">return函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-throw-return"><span class="toc-number">3.4.7.</span> <span class="toc-text">next() throw() return()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.8.</span> <span class="toc-text">yield*表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">3.5.</span> <span class="toc-text">async await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM%E8%AF%AD%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">DOM语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BEhtml%E5%85%83%E7%B4%A0"><span class="toc-number">4.1.</span> <span class="toc-text">查找html元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98HTML"><span class="toc-number">4.2.</span> <span class="toc-text">改变HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98CSS"><span class="toc-number">4.3.</span> <span class="toc-text">改变CSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94"><span class="toc-number">4.4.</span> <span class="toc-text">DOM事件响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">DOM事件对象的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.6.</span> <span class="toc-text">鼠标事件对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-EventListener"><span class="toc-number">4.7.</span> <span class="toc-text">DOM EventListener()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE%E5%8E%9F%E7%90%86"><span class="toc-number">4.8.</span> <span class="toc-text">事件委派原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">4.9.</span> <span class="toc-text">阻止默认事件执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E5%85%83%E7%B4%A0%EF%BC%88%E8%8A%82%E7%82%B9%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-number">4.10.</span> <span class="toc-text">DOM元素（节点）操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E9%9B%86%E5%90%88"><span class="toc-number">4.11.</span> <span class="toc-text">DOM集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTMLCollection-%E4%B8%8E-NodeList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.12.</span> <span class="toc-text">HTMLCollection 与 NodeList 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">4.13.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">JavaScript对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prototype-%E7%BB%A7%E6%89%BF"><span class="toc-number">5.2.</span> <span class="toc-text">prototype 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">最好的创建方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">5.4.</span> <span class="toc-text">组合继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Window-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">Window - 浏览器对象模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%88API%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">函数（API）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#isNaN"><span class="toc-number">7.1.</span> <span class="toc-text">isNaN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-number">7.2.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-%E5%B1%9E%E6%80%A7"><span class="toc-number">7.3.</span> <span class="toc-text">constructor 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-from"><span class="toc-number">7.4.</span> <span class="toc-text">Array.from</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setInterval-%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">setInterval() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setTimeout-%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">setTimeout() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter-%E5%87%BD%E6%95%B0"><span class="toc-number">7.7.</span> <span class="toc-text">filter()函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jQuery"><span class="toc-number">8.</span> <span class="toc-text">jQuery</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99%E2%80%94%E5%A5%BD%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">在线网站—好用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">基本选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">层级选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">8.2.3.</span> <span class="toc-text">过滤选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">8.2.4.</span> <span class="toc-text">表单选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">8.2.5.</span> <span class="toc-text">筛选选择器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BF%AD%E4%BB%A3"><span class="toc-number">8.3.</span> <span class="toc-text">隐式迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">基本工具方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.</span> <span class="toc-text">操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E6%93%8D%E4%BD%9C"><span class="toc-number">8.6.</span> <span class="toc-text">CSS操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C"><span class="toc-number">8.7.</span> <span class="toc-text">JS文档操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.7.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#empty-remove-detach%E5%8C%BA%E5%88%AB"><span class="toc-number">8.7.2.</span> <span class="toc-text">empty remove detach区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">8.8.</span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#on%E5%92%8Cbind%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.8.1.</span> <span class="toc-text">on和bind的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mouseover-mouseout%E4%B8%8Emouseenter-mouseleave%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.8.2.</span> <span class="toc-text">mouseover&#x2F;mouseout与mouseenter&#x2F;mouseleave的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">8.9.</span> <span class="toc-text">动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-5"><span class="toc-number">8.10.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E4%BD%BF%E7%94%A8"><span class="toc-number">8.10.0.1.</span> <span class="toc-text">this使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E6%8F%92%E4%BB%B6"><span class="toc-number">8.11.</span> <span class="toc-text">jQuery插件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AJAX"><span class="toc-number">9.</span> <span class="toc-text">AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.1.</span> <span class="toc-text">HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">状态码分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AJAX%E5%8F%91%E7%94%9Fget%E8%AF%B7%E6%B1%82"><span class="toc-number">9.3.</span> <span class="toc-text">AJAX发生get请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81post%E8%AF%B7%E6%B1%82"><span class="toc-number">9.4.</span> <span class="toc-text">发送post请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8jQuery%E5%8F%91%E9%80%81"><span class="toc-number">9.5.</span> <span class="toc-text">用jQuery发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E2%80%94%E6%84%9F%E8%A7%89%E6%B2%A1%E7%94%A8-%E6%B2%A1%E7%9C%8B"><span class="toc-number">9.6.</span> <span class="toc-text">JSONP解决跨域问题—感觉没用 没看</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#layui-%E7%9A%84layer%E5%BC%B9%E5%87%BA%E5%B1%82"><span class="toc-number">10.</span> <span class="toc-text">layui 的layer弹出层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80"><span class="toc-number">11.</span> <span class="toc-text">参考网址</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/55889.html" title="mybatisPlus复习"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/mybatisPlus.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatisPlus复习"/></a><div class="content"><a class="title" href="/posts/55889.html" title="mybatisPlus复习">mybatisPlus复习</a><time datetime="2025-07-26T09:26:46.000Z" title="发表于 2025-07-26 17:26:46">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/58965.html" title="Redis原理和实战"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/Database/Redis-1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis原理和实战"/></a><div class="content"><a class="title" href="/posts/58965.html" title="Redis原理和实战">Redis原理和实战</a><time datetime="2025-07-13T13:05:12.000Z" title="发表于 2025-07-13 21:05:12">2025-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43782.html" title="Vue"><img src= "/image/loading.gif" data-lazy-src="/image/top/front/Vue/Vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue"/></a><div class="content"><a class="title" href="/posts/43782.html" title="Vue">Vue</a><time datetime="2025-06-27T10:20:49.839Z" title="发表于 2025-06-27 18:20:49">2025-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/12365.html" title="LLaMA-Factory"><img src= "/image/loading.gif" data-lazy-src="/image/top/llama/llama-factory.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LLaMA-Factory"/></a><div class="content"><a class="title" href="/posts/12365.html" title="LLaMA-Factory">LLaMA-Factory</a><time datetime="2025-04-25T08:43:47.000Z" title="发表于 2025-04-25 16:43:47">2025-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/33708.html" title="RabbitMQ"><img src= "/image/loading.gif" data-lazy-src="/image/top/back/MassageQueue/RabbitMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RabbitMQ"/></a><div class="content"><a class="title" href="/posts/33708.html" title="RabbitMQ">RabbitMQ</a><time datetime="2025-03-17T05:28:06.000Z" title="发表于 2025-03-17 13:28:06">2025-03-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/top/front/javaScript/javaScript.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Curry Jay</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎光临我的小屋!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.2.2"></script><script src="/js/main.js?v=5.2.2"></script><script src="/js/tw_cn.js?v=5.2.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="/config/js/catagory.js?1"></script><script src="https://cdn.staticfile.net/jquery/3.7.1/jquery.min.js"></script><script type="text/javascript" src="/config/js/rightmenu.js?1"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script><script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/index.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.2.2"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/生活/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 生活趣闻 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/后端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 后端学习 (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/其他/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧑‍💻 其他内容 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🕵️ 前端学习 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/比赛/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">⛹️‍♂️ 比赛内容 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/学校学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🏫 学校学习记录 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://curry-jay.github.io/categories/软件使用/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🖥️ 软件使用技巧 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://curry-jay.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #49B1F5}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18872.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "/image/loading.gif" data-lazy-src="/image/top_first.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18872.html&quot;);" href="javascript:void(0);" alt="">欢迎来到我的小屋</a><div class="blog-slider__text">由于笔记放在实验室电脑和自己电脑上查询不方便，所以想做一个博客将这些东西整合起来！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18872.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/48081.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "/image/loading.gif" data-lazy-src="/image/top/Live/toDoList.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/48081.html&quot;);" href="javascript:void(0);" alt="">待办清单</a><div class="blog-slider__text">统计一下待办清单!</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/48081.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>